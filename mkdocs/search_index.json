{
    "docs": [
        {
            "location": "/",
            "text": "Documentation de SimPLU3D\n\uf0c1\n\n\nSimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties 3D en optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utilis\u00e9s pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementations locales d'urbanisme) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisation ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation GitHub \nSimPLU3D\n.\n\n\n\n\nPrincipe de fonctionnement de SimPLU3D\n\uf0c1\n\n\nCette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de \nPlans Locaux d'Urbanisme (PLU)\n et permet de r\u00e9pondre \u00e0 ce type de questions :\n\n\n\n\n\n\nQuelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ?\n\n\n\n\n\n\nComment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU  ?\n\n\n\n\n\n\nEst-ce que des b\u00e2timents produisant une ombre trop importante sur les parcelles voisines risquent d'\u00eatre construits ?\n\n\n\n\n\n\nSimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter \nla liste des r\u00e9alisations et publications\n.\n\n\nSimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire \nLASTIG\n de l'\nInstitut National de l'Information G\u00e9ographique et Foresti\u00e8re\n. N'h\u00e9sitez pas \u00e0 \nnous contacter\n pour nous fait un retour sur SimPLU3D ou pour utiliser le code.\n\n\nCette documentation a pour but de montrer comment utiliser et param\u00e9trer l'approche SimPLU3D en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation \n(par ici)\n.\n\n\nLa conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se :\n\n\n\n\nBrasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014 \nM\u00e9moire\n, \nPr\u00e9sentation",
            "title": "Home"
        },
        {
            "location": "/#documentation-de-simplu3d",
            "text": "SimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties 3D en optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utilis\u00e9s pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementations locales d'urbanisme) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisation ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation GitHub  SimPLU3D .",
            "title": "Documentation de SimPLU3D"
        },
        {
            "location": "/#principe-de-fonctionnement-de-simplu3d",
            "text": "Cette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de  Plans Locaux d'Urbanisme (PLU)  et permet de r\u00e9pondre \u00e0 ce type de questions :    Quelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ?    Comment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU  ?    Est-ce que des b\u00e2timents produisant une ombre trop importante sur les parcelles voisines risquent d'\u00eatre construits ?    SimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter  la liste des r\u00e9alisations et publications .  SimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire  LASTIG  de l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . N'h\u00e9sitez pas \u00e0  nous contacter  pour nous fait un retour sur SimPLU3D ou pour utiliser le code.  Cette documentation a pour but de montrer comment utiliser et param\u00e9trer l'approche SimPLU3D en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation  (par ici) .  La conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se :   Brasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014  M\u00e9moire ,  Pr\u00e9sentation",
            "title": "Principe de fonctionnement de SimPLU3D"
        },
        {
            "location": "/about/",
            "text": "En savoir plus sur le projet SimPLU3D\n\uf0c1\n\n\nContributeurs\n\uf0c1\n\n\n\n\nMicka\u00ebl Brasebin\n : chercheur LASTIG - IGN  ;\n\n\nJulien Perret\n : chercheur LASTIG - IGN  ;\n\n\nMicka\u00ebl Borne\n : d\u00e9veloppeur SAI - IGN ;\n\n\nPaul Chapron\n : chercheur LASTIG - IGN  ;\n\n\nImran Lokhat\n : d\u00e9veloppeur LASTIG - IGN ;\n\n\nMaxime Colomb\n : doctorant LASTIG - IGN .\n\n\n\n\nFinanceurs\n\uf0c1\n\n\nSimPLU3D est un projet d\u00e9velopp\u00e9 par des chercheurs et ing\u00e9nieurs du laboratoire \nLASTIG\n et financ\u00e9 majoritairement par l'\nInstitut National de l'Information G\u00e9ographique et Foresti\u00e8re\n.\n\n\nLe projet a \u00e9galement \u00e9t\u00e9 financ\u00e9 par le fond FUI du projet TerraMagna et la r\u00e9gion Ile-de-France \u00e0 travers le projet FEDER e-PLU.\n\n\nContacts\n\uf0c1\n\n\nVous pouvez contacter Julien Perret ou Micka\u00ebl Brasebin ({nom.pr\u00e9nom} (AT) {gmail} (POINT) {com}) pour discuter de l'utilisation de SimPLU3D.\n\n\nPour signaler un bug n'h\u00e9sitez pas \u00e0 poster une issue sur le ou les projets concern\u00e9s.",
            "title": "About"
        },
        {
            "location": "/about/#en-savoir-plus-sur-le-projet-simplu3d",
            "text": "",
            "title": "En savoir plus sur le projet SimPLU3D"
        },
        {
            "location": "/about/#contributeurs",
            "text": "Micka\u00ebl Brasebin  : chercheur LASTIG - IGN  ;  Julien Perret  : chercheur LASTIG - IGN  ;  Micka\u00ebl Borne  : d\u00e9veloppeur SAI - IGN ;  Paul Chapron  : chercheur LASTIG - IGN  ;  Imran Lokhat  : d\u00e9veloppeur LASTIG - IGN ;  Maxime Colomb  : doctorant LASTIG - IGN .",
            "title": "Contributeurs"
        },
        {
            "location": "/about/#financeurs",
            "text": "SimPLU3D est un projet d\u00e9velopp\u00e9 par des chercheurs et ing\u00e9nieurs du laboratoire  LASTIG  et financ\u00e9 majoritairement par l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re .  Le projet a \u00e9galement \u00e9t\u00e9 financ\u00e9 par le fond FUI du projet TerraMagna et la r\u00e9gion Ile-de-France \u00e0 travers le projet FEDER e-PLU.",
            "title": "Financeurs"
        },
        {
            "location": "/about/#contacts",
            "text": "Vous pouvez contacter Julien Perret ou Micka\u00ebl Brasebin ({nom.pr\u00e9nom} (AT) {gmail} (POINT) {com}) pour discuter de l'utilisation de SimPLU3D.  Pour signaler un bug n'h\u00e9sitez pas \u00e0 poster une issue sur le ou les projets concern\u00e9s.",
            "title": "Contacts"
        },
        {
            "location": "/bibliographie/",
            "text": "Bibliographie\n\uf0c1\n\n\nQuelques ressources pour aller plus loin :\n\n\n\n\nL'ensemble de la conception de SimPLU3D est d\u00e9crit dans la th\u00e8se de Micka\u00ebl Brasebin :\n\n\n\n\n\n\nBrasebin, M., Apr. 2014. Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti. Ph.D. thesis, Universit\u00e9 Paris-Est. \nM\u00e9moire\n, \nPr\u00e9sentation\n\n\n\n\n\n\nLe mod\u00e8le g\u00e9ographique et la d\u00e9finition de r\u00e8gles en OCL  :\n\n\n\n\n\n\nBrasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, \ndoi:10.3390/ijgi5020014.\n.\n\n\n\n\n\n\nLa g\u00e9n\u00e9ration de formes b\u00e2ties :\n\n\n\n\n\n\nBrasebin M., Perret, J., Musti\u00e8re S., Weber C. (2017) 3D urban data to assess local urban regulation influence, Computers, Environment and Urban Systems, 2017, ISSN 0198-9715, \nhttps://doi.org/10.1016/j.compenvurbsys.2017.10.002\n\n\n\n\n\n\nLes cas d'usage autour du couplage entre SimPLU3D et OpenMOLE :\n\n\n\n\n\n\nBrasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017). \nArticle\n , \nPr\u00e9sentation\n\n\n\n\n\n\nLe recuit simul\u00e9 et la librjmcmc (https://github.com/IGNF/librjmcmc4j) :\n\n\n\n\n\n\nBre\u0301dif, M., Tournaire, O., Aug. 2012. librjmcmc: An open-source generic\n  c++ library for stochastic optimization. In: The XXII Congress of the\n  International Society of Photogrammetry and Remote Sensing.\n\n\n\n\nExp\u00e9rimentations et r\u00e9alisations :\n\uf0c1\n\n\n\n\nSimulation de la constructibilit\u00e9 en Ile-de-France\n (2015 - 2019) : il s'agit d'un projet en collaboration avec l'\nIAUIDF\n et la \nDRIEA\n visant \u00e0 \u00e9valuer le potentiel de l'approche SimPLU3D pour d\u00e9terminer la constructibilit\u00e9 \u00e0 l'\u00e9chelle de l'IDF. (Pour en savoir plus, (Brasebin et al, 2017), \nCode\n) ;\n\n\nD\u00e9monstrateur pour l'aide \u00e0 la conception de PLU\n : ce projet en partenariat avec l'\nISC-PIF\n vise \u00e0 \u00e9valuer ce qu'il est possible \u00e0 l'\u00e9chelle d'un \u00eelot en faisant varier les param\u00e8tres du PLU (Pour en savoir plus, voir (Brasebin et al, 2017), \nCode\n, \nD\u00e9monstrateur\n) ;\n\n\nPLU++ : vers une concertation plus participative et plus efficace de PLU\n (2015 - 2017) : dans le cadre de ce projet de recherche en collaboration avec  l'\nEIVP\n, une r\u00e9flexion a \u00e9t\u00e9 men\u00e9e sur la d\u00e9fintion des types de repr\u00e9sentation et des interactions \u00e0 utiliser dans ce contexte. (Pour en savoir plus, \nsite Internet du projet\n) ;\n\n\nD\u00e9monstrateur SimPLU3D pour l'instruction de permis de construire\n : site Internet de d\u00e9monstration pour montrer comment SimPLU3D peut faciliter l'instruction de permis de  construire en v\u00e9rifiant automatiquement un certain nombre de r\u00e8gles d'urbanisme (\nSite Internet du d\u00e9monstrateur\n).\n\n\nArtiScales\n : il s'agit d'un couplage avec le mod\u00e8le \nMup-CITY\n pour la production de formes r\u00e9alistes de d\u00e9veloppement r\u00e9sidentiel, de l\u2019\u00e9chelle du b\u00e2timent \u00e0 celle de l\u2019ensemble d\u2019une r\u00e9gion urbaine dans le cadre du travail de th\u00e8se de \nMaxime Colomb\n. (\nOrganisation du projet ArtiScales\n) ;\n\n\nDECODURBA\n : un outil pour aider le citoyen \u00e0 la construction d'une maison individuelle. Cette proposition a re\u00e7u un prix durant le hackhathon Hackhurba organis\u00e9 par le minist\u00e8re de la transition \u00e9cologique et sociale (\nSite du hackhathon\n).\n\n\n\n\nLa vid\u00e9o ci-dessous montre en vid\u00e9o quelques r\u00e9sultats de ces r\u00e9alisations :",
            "title": "Bibliographie"
        },
        {
            "location": "/bibliographie/#bibliographie",
            "text": "Quelques ressources pour aller plus loin :   L'ensemble de la conception de SimPLU3D est d\u00e9crit dans la th\u00e8se de Micka\u00ebl Brasebin :    Brasebin, M., Apr. 2014. Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti. Ph.D. thesis, Universit\u00e9 Paris-Est.  M\u00e9moire ,  Pr\u00e9sentation    Le mod\u00e8le g\u00e9ographique et la d\u00e9finition de r\u00e8gles en OCL  :    Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14,  doi:10.3390/ijgi5020014. .    La g\u00e9n\u00e9ration de formes b\u00e2ties :    Brasebin M., Perret, J., Musti\u00e8re S., Weber C. (2017) 3D urban data to assess local urban regulation influence, Computers, Environment and Urban Systems, 2017, ISSN 0198-9715,  https://doi.org/10.1016/j.compenvurbsys.2017.10.002    Les cas d'usage autour du couplage entre SimPLU3D et OpenMOLE :    Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017).  Article  ,  Pr\u00e9sentation    Le recuit simul\u00e9 et la librjmcmc (https://github.com/IGNF/librjmcmc4j) :    Bre\u0301dif, M., Tournaire, O., Aug. 2012. librjmcmc: An open-source generic\n  c++ library for stochastic optimization. In: The XXII Congress of the\n  International Society of Photogrammetry and Remote Sensing.",
            "title": "Bibliographie"
        },
        {
            "location": "/bibliographie/#experimentations-et-realisations",
            "text": "Simulation de la constructibilit\u00e9 en Ile-de-France  (2015 - 2019) : il s'agit d'un projet en collaboration avec l' IAUIDF  et la  DRIEA  visant \u00e0 \u00e9valuer le potentiel de l'approche SimPLU3D pour d\u00e9terminer la constructibilit\u00e9 \u00e0 l'\u00e9chelle de l'IDF. (Pour en savoir plus, (Brasebin et al, 2017),  Code ) ;  D\u00e9monstrateur pour l'aide \u00e0 la conception de PLU  : ce projet en partenariat avec l' ISC-PIF  vise \u00e0 \u00e9valuer ce qu'il est possible \u00e0 l'\u00e9chelle d'un \u00eelot en faisant varier les param\u00e8tres du PLU (Pour en savoir plus, voir (Brasebin et al, 2017),  Code ,  D\u00e9monstrateur ) ;  PLU++ : vers une concertation plus participative et plus efficace de PLU  (2015 - 2017) : dans le cadre de ce projet de recherche en collaboration avec  l' EIVP , une r\u00e9flexion a \u00e9t\u00e9 men\u00e9e sur la d\u00e9fintion des types de repr\u00e9sentation et des interactions \u00e0 utiliser dans ce contexte. (Pour en savoir plus,  site Internet du projet ) ;  D\u00e9monstrateur SimPLU3D pour l'instruction de permis de construire  : site Internet de d\u00e9monstration pour montrer comment SimPLU3D peut faciliter l'instruction de permis de  construire en v\u00e9rifiant automatiquement un certain nombre de r\u00e8gles d'urbanisme ( Site Internet du d\u00e9monstrateur ).  ArtiScales  : il s'agit d'un couplage avec le mod\u00e8le  Mup-CITY  pour la production de formes r\u00e9alistes de d\u00e9veloppement r\u00e9sidentiel, de l\u2019\u00e9chelle du b\u00e2timent \u00e0 celle de l\u2019ensemble d\u2019une r\u00e9gion urbaine dans le cadre du travail de th\u00e8se de  Maxime Colomb . ( Organisation du projet ArtiScales ) ;  DECODURBA  : un outil pour aider le citoyen \u00e0 la construction d'une maison individuelle. Cette proposition a re\u00e7u un prix durant le hackhathon Hackhurba organis\u00e9 par le minist\u00e8re de la transition \u00e9cologique et sociale ( Site du hackhathon ).   La vid\u00e9o ci-dessous montre en vid\u00e9o quelques r\u00e9sultats de ces r\u00e9alisations :",
            "title": "Exp\u00e9rimentations et r\u00e9alisations :"
        },
        {
            "location": "/development/",
            "text": "Futurs d\u00e9veloppements\n\uf0c1\n\n\nCette page liste les futurs d\u00e9veloppements pour les projets de SimPLU3D :\n\n\n\n\n\n\nPersistance de l'environnement g\u00e9ographique\n : pour l'instant, l'instanciation du mod\u00e8le et les \u00e9tapes d'int\u00e9gration s'effectuent lors de chaque chargement. Il pourrait \u00eatre n\u00e9cessaire de mettre en place un chargement direct des donn\u00e9es (c'est \u00e0 dire sans passer par les \u00e9tapes d'int\u00e9gration). Cela pourrait, par exemple, permettre de reprendre manuellement une \u00e9tape automatique du processus d'int\u00e9gration, comme l'affectation d'un type aux limites s\u00e9paratives de parcelles ou g\u00e9rer du versionnement.\n\n\n\n\n\n\nGestion du multi-objet\n : SimPLU3D ne g\u00e9n\u00e8re actuellement que des objets d'une seule classe, pourtant la libjrmcmc4j permet de g\u00e9n\u00e9rer diff\u00e9rents objets de diff\u00e9rentes classes. Il pourrait \u00eatre int\u00e9ressant de mieux formaliser la gestion du multi-objet afin de g\u00e9n\u00e9rer simultan\u00e9ment diff\u00e9rents objets sur un parcelle comme par exemple, des formes b\u00e2ties, de la v\u00e9g\u00e9tation et des garages. Un premier exemple a \u00e9t\u00e9 mis en \u0153uvre dans ce \ncode du projet SimPLU3D-IAUIDF\n, mais cet aspect n'est pas encore suffisamment bien formalis\u00e9 pour pouvoir \u00eatre simplement r\u00e9utilis\u00e9 dans les projets de SimPLU3D.\n\n\n\n\n\n\nAspects architecturaux\n : les grammaires utilis\u00e9es dans SimPLU3D sont relativement simples, il s'agit d'un ensemble de formes sans lien les unes avec les autres sur lesquelles des contraintes sont ajout\u00e9es. Elles ne se basent pas sur des grammaires architecturales qui permettent de produire des b\u00e2timents r\u00e9alistes avec un haut niveau de d\u00e9tail. Il pourrait \u00eatre impl\u00e9ment\u00e9 des m\u00e9canismes plus complexes de formalisation des formes et d'optimisation comme ceux d\u00e9crits dans l'article ;\n\n\n\n\n\n\n\n\nTalton, J. O., Lou, Y., Lesser, S., Duke, J., M\u011bch, R., Koltun, V., Apr. 2011. Metropolis procedural modeling. ACM Trans. Graph. 30 (2). URL \nhttp://doi.acm.org/10.1145/1944846.1944851",
            "title": "Development"
        },
        {
            "location": "/development/#futurs-developpements",
            "text": "Cette page liste les futurs d\u00e9veloppements pour les projets de SimPLU3D :    Persistance de l'environnement g\u00e9ographique  : pour l'instant, l'instanciation du mod\u00e8le et les \u00e9tapes d'int\u00e9gration s'effectuent lors de chaque chargement. Il pourrait \u00eatre n\u00e9cessaire de mettre en place un chargement direct des donn\u00e9es (c'est \u00e0 dire sans passer par les \u00e9tapes d'int\u00e9gration). Cela pourrait, par exemple, permettre de reprendre manuellement une \u00e9tape automatique du processus d'int\u00e9gration, comme l'affectation d'un type aux limites s\u00e9paratives de parcelles ou g\u00e9rer du versionnement.    Gestion du multi-objet  : SimPLU3D ne g\u00e9n\u00e8re actuellement que des objets d'une seule classe, pourtant la libjrmcmc4j permet de g\u00e9n\u00e9rer diff\u00e9rents objets de diff\u00e9rentes classes. Il pourrait \u00eatre int\u00e9ressant de mieux formaliser la gestion du multi-objet afin de g\u00e9n\u00e9rer simultan\u00e9ment diff\u00e9rents objets sur un parcelle comme par exemple, des formes b\u00e2ties, de la v\u00e9g\u00e9tation et des garages. Un premier exemple a \u00e9t\u00e9 mis en \u0153uvre dans ce  code du projet SimPLU3D-IAUIDF , mais cet aspect n'est pas encore suffisamment bien formalis\u00e9 pour pouvoir \u00eatre simplement r\u00e9utilis\u00e9 dans les projets de SimPLU3D.    Aspects architecturaux  : les grammaires utilis\u00e9es dans SimPLU3D sont relativement simples, il s'agit d'un ensemble de formes sans lien les unes avec les autres sur lesquelles des contraintes sont ajout\u00e9es. Elles ne se basent pas sur des grammaires architecturales qui permettent de produire des b\u00e2timents r\u00e9alistes avec un haut niveau de d\u00e9tail. Il pourrait \u00eatre impl\u00e9ment\u00e9 des m\u00e9canismes plus complexes de formalisation des formes et d'optimisation comme ceux d\u00e9crits dans l'article ;     Talton, J. O., Lou, Y., Lesser, S., Duke, J., M\u011bch, R., Koltun, V., Apr. 2011. Metropolis procedural modeling. ACM Trans. Graph. 30 (2). URL  http://doi.acm.org/10.1145/1944846.1944851",
            "title": "Futurs d\u00e9veloppements"
        },
        {
            "location": "/export/",
            "text": "Exporter des r\u00e9sultats de simulation\n\uf0c1\n\n\nExport g\u00e9n\u00e9ral\n\uf0c1\n\n\nLes objets produits par le simulateur sont stock\u00e9s dans une instance de la classe  \nGraphConfiguration\n. Il est possible d'it\u00e9rer sur les objets g\u00e9n\u00e9r\u00e9s via le graphe associ\u00e9. Le code ci-dessous montrer comment exporter sous forme d'un ShapeFile les r\u00e9sultats d'une simulation :\n\n\n// Run of the optimisation on a parcel with the predicate\nGraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred);\n\n// Witting the output\nIFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>();\n// For all generated boxes\nfor (GraphVertex<Cuboid> v : cc.getGraph().vertexSet()) {\n\n  // Output feature with generated geometry\n  IFeature feat = new DefaultFeature(v.getValue().generated3DGeom());\n\n\n  iFeatC.add(feat);\n\n}\n\nShapefileWriter.write(featC,\"tmp/result.shp\");\n\n\n\n\nExport de bo\u00eetes\n\uf0c1\n\n\nComme les bo\u00eetes sont les objets actuellement les plus utilis\u00e9es comme sorties de SimPLU3D, diff\u00e9rentes m\u00e9thodes pour les exporter avec diff\u00e9rentes transformations ont \u00e9t\u00e9 impl\u00e9ment\u00e9es dans le projet SimPLU3D.\n\n\nChacune des classes mentionn\u00e9es ci-dessous poss\u00e8de un \nmain\n permettant leur utilisation.\n\n\nExport simple des bo\u00eetes\n\uf0c1\n\n\nLa classe \nfr.ign.cogit.simplu3d.io.shapefile.SaveGeneratedObjects\n  permet d'exporter les bo\u00eetes en ShapeFile (m\u00e9thode \nsaveShapefile\n) ou dans une base PostGIS (m\u00e9thode\n save\n) sous forme de MultiPolygon 3D (issus de la m\u00e9thode \ngenerated3DGeom\n). Dans les donn\u00e9es en sortie, chaque ligne correspond \u00e0 une bo\u00eete.\n\n\nExport d\u00e9coup\u00e9\n\uf0c1\n\n\nComme les bo\u00eetes g\u00e9n\u00e9r\u00e9es peuvent s'intersecter, ces intersections sont potentiellement des sources de probl\u00e8me pour calculer des indicateurs sur les formes r\u00e9sultantes ou pour les visualiser.\n\n\nAinsi, la classe \nfr.ign.cogit.simplu3d.util.merge.SDPCalc\n permet d'exporter avec la m\u00e9thode \ngetGeometryPairByGroup\n les bo\u00eetes sous la forme d'une partition des g\u00e9om\u00e9tries r\u00e9sultats avec une hauteur affect\u00e9e \u00e0 chaque patch. Le r\u00e9sultat contient pour chaque enregistrement un polygone 2D et une hauteur pour reg\u00e9n\u00e9rer la forme en 3D.\n\n\nCet export facilite le calcul de la surface de plancher et de la surface 2D de la construction (m\u00e9thode \nprocess\n et m\u00e9thode \nprocessSurface\n).\n\n\nExport fusionn\u00e9\n\uf0c1\n\n\nLa classe \nfr.ign.cogit.simplu3d.util.merge.MergeCuboid\n propose une fusion 3D des bo\u00eetes r\u00e9sultantes via la m\u00e9thode \nmergeFromShapefile\n. Les faces int\u00e9rieures sont supprim\u00e9es et les bo\u00eetes g\u00e9n\u00e9r\u00e9es en 3D. Ce cas est tr\u00e8s utile pour la visualisation et le calcul de la surface ext\u00e9rieure avec la m\u00e9thode \ngetSurface\n.\n\n\nL'attribut statique de cette classe \nzMIN\n permet de fixer l'altitude minimale au dessus de laquelle les bo\u00eetes seront extrud\u00e9es.\n\n\nSynth\u00e8se des exports\n\uf0c1\n\n\n\n\nL'image ci-dessus illustre les diff\u00e9rents types d'exports. Si de base la vue 3D est la m\u00eame pour les trois r\u00e9sultats, les exports sont diff\u00e9rents dans leur mod\u00e9lisation des entit\u00e9s et des g\u00e9om\u00e9tries. La seconde partie de l'image montre dans une vue 2D la s\u00e9lection d'une entit\u00e9 (en jaune) dans les trois types d'export :\n\n\n\n\nExport simple\n : une entit\u00e9 = une bo\u00eete avec une hauteur. Il y a donc beaucoup d'intersections entre objets ;\n\n\nExport d\u00e9coup\u00e9\n :  une entit\u00e9 = une g\u00e9om\u00e9trie d\u00e9coup\u00e9e par l'intersection des autres g\u00e9om\u00e9tries. Chaque composante g\u00e9om\u00e9trique peut \u00eatre extrud\u00e9e ce qui donne un d\u00e9doublement des faces verticales \u00e0 l'intersection entre deux g\u00e9om\u00e9tries d\u00e9coup\u00e9es ;\n\n\nExport fusionn\u00e9\n : une entit\u00e9 = une forme b\u00e2tie, c'est \u00e0 dire la fusion des g\u00e9om\u00e9tries qui s'intersectent. Ici, le r\u00e9sultat est g\u00e9om\u00e9triquement propre, il n'y a pas de doublon au niveau des faces verticales.",
            "title": "Export"
        },
        {
            "location": "/export/#exporter-des-resultats-de-simulation",
            "text": "",
            "title": "Exporter des r\u00e9sultats de simulation"
        },
        {
            "location": "/export/#export-general",
            "text": "Les objets produits par le simulateur sont stock\u00e9s dans une instance de la classe   GraphConfiguration . Il est possible d'it\u00e9rer sur les objets g\u00e9n\u00e9r\u00e9s via le graphe associ\u00e9. Le code ci-dessous montrer comment exporter sous forme d'un ShapeFile les r\u00e9sultats d'une simulation :  // Run of the optimisation on a parcel with the predicate\nGraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred);\n\n// Witting the output\nIFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>();\n// For all generated boxes\nfor (GraphVertex<Cuboid> v : cc.getGraph().vertexSet()) {\n\n  // Output feature with generated geometry\n  IFeature feat = new DefaultFeature(v.getValue().generated3DGeom());\n\n\n  iFeatC.add(feat);\n\n}\n\nShapefileWriter.write(featC,\"tmp/result.shp\");",
            "title": "Export g\u00e9n\u00e9ral"
        },
        {
            "location": "/export/#export-de-boites",
            "text": "Comme les bo\u00eetes sont les objets actuellement les plus utilis\u00e9es comme sorties de SimPLU3D, diff\u00e9rentes m\u00e9thodes pour les exporter avec diff\u00e9rentes transformations ont \u00e9t\u00e9 impl\u00e9ment\u00e9es dans le projet SimPLU3D.  Chacune des classes mentionn\u00e9es ci-dessous poss\u00e8de un  main  permettant leur utilisation.",
            "title": "Export de bo\u00eetes"
        },
        {
            "location": "/export/#export-simple-des-boites",
            "text": "La classe  fr.ign.cogit.simplu3d.io.shapefile.SaveGeneratedObjects   permet d'exporter les bo\u00eetes en ShapeFile (m\u00e9thode  saveShapefile ) ou dans une base PostGIS (m\u00e9thode  save ) sous forme de MultiPolygon 3D (issus de la m\u00e9thode  generated3DGeom ). Dans les donn\u00e9es en sortie, chaque ligne correspond \u00e0 une bo\u00eete.",
            "title": "Export simple des bo\u00eetes"
        },
        {
            "location": "/export/#export-decoupe",
            "text": "Comme les bo\u00eetes g\u00e9n\u00e9r\u00e9es peuvent s'intersecter, ces intersections sont potentiellement des sources de probl\u00e8me pour calculer des indicateurs sur les formes r\u00e9sultantes ou pour les visualiser.  Ainsi, la classe  fr.ign.cogit.simplu3d.util.merge.SDPCalc  permet d'exporter avec la m\u00e9thode  getGeometryPairByGroup  les bo\u00eetes sous la forme d'une partition des g\u00e9om\u00e9tries r\u00e9sultats avec une hauteur affect\u00e9e \u00e0 chaque patch. Le r\u00e9sultat contient pour chaque enregistrement un polygone 2D et une hauteur pour reg\u00e9n\u00e9rer la forme en 3D.  Cet export facilite le calcul de la surface de plancher et de la surface 2D de la construction (m\u00e9thode  process  et m\u00e9thode  processSurface ).",
            "title": "Export d\u00e9coup\u00e9"
        },
        {
            "location": "/export/#export-fusionne",
            "text": "La classe  fr.ign.cogit.simplu3d.util.merge.MergeCuboid  propose une fusion 3D des bo\u00eetes r\u00e9sultantes via la m\u00e9thode  mergeFromShapefile . Les faces int\u00e9rieures sont supprim\u00e9es et les bo\u00eetes g\u00e9n\u00e9r\u00e9es en 3D. Ce cas est tr\u00e8s utile pour la visualisation et le calcul de la surface ext\u00e9rieure avec la m\u00e9thode  getSurface .  L'attribut statique de cette classe  zMIN  permet de fixer l'altitude minimale au dessus de laquelle les bo\u00eetes seront extrud\u00e9es.",
            "title": "Export fusionn\u00e9"
        },
        {
            "location": "/export/#synthese-des-exports",
            "text": "L'image ci-dessus illustre les diff\u00e9rents types d'exports. Si de base la vue 3D est la m\u00eame pour les trois r\u00e9sultats, les exports sont diff\u00e9rents dans leur mod\u00e9lisation des entit\u00e9s et des g\u00e9om\u00e9tries. La seconde partie de l'image montre dans une vue 2D la s\u00e9lection d'une entit\u00e9 (en jaune) dans les trois types d'export :   Export simple  : une entit\u00e9 = une bo\u00eete avec une hauteur. Il y a donc beaucoup d'intersections entre objets ;  Export d\u00e9coup\u00e9  :  une entit\u00e9 = une g\u00e9om\u00e9trie d\u00e9coup\u00e9e par l'intersection des autres g\u00e9om\u00e9tries. Chaque composante g\u00e9om\u00e9trique peut \u00eatre extrud\u00e9e ce qui donne un d\u00e9doublement des faces verticales \u00e0 l'intersection entre deux g\u00e9om\u00e9tries d\u00e9coup\u00e9es ;  Export fusionn\u00e9  : une entit\u00e9 = une forme b\u00e2tie, c'est \u00e0 dire la fusion des g\u00e9om\u00e9tries qui s'intersectent. Ici, le r\u00e9sultat est g\u00e9om\u00e9triquement propre, il n'y a pas de doublon au niveau des faces verticales.",
            "title": "Synth\u00e8se des exports"
        },
        {
            "location": "/begin/first_simulation/",
            "text": "Introduction\n\uf0c1\n\n\nL'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9e de bo\u00eetes qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi et r\u00e9utilis\u00e9 dans cette documentation. Pour commencer, il est n\u00e9cessaire  d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la \npage d'installation\n.\n\n\nLe code utilis\u00e9 dans cette page se trouve dans la classe :  \nfr.ign.simplu3d.firstSimulation.BasicSimulator\n.\n\n\nDonn\u00e9es d'entr\u00e9e\n\uf0c1\n\n\nLes donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources \nresources/firstSimulation/\n. Il s'agit du plus petit ensemble de donn\u00e9es n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers :\n\n\n\n\ndata\n: qui contient un fichier ShapeFile de parcelles (parcelle.shp). Chaque parcelle a une g\u00e9om\u00e9trie surfacique et un attribut \nid\n. Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans \nla section consacr\u00e9e \u00e0 l'environnement g\u00e9ographique\n) ;\n\n\nscenario\n : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de formes (d\u00e9crits dans la section d\u00e9di\u00e9e aux \nparam\u00e8tres de la g\u00e9n\u00e9ration de formes\n) et des visiteurs qui indiqueront l'\u00e9tat d'avancement pendant la simulation (\nd\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs\n).\n\n\n\n\n\n\nCode de simulation\n\uf0c1\n\n\nLe code comment\u00e9 \u00e0 ex\u00e9cuter est repris ci-dessous. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation :\n\n\n\n\nla cr\u00e9ation d'un \nenvironnement g\u00e9ographique\n ;\n\n\nla d\u00e9finition de \ncontraintes morphologiques\n, \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ;\n\n\nla d\u00e9finition d'un \ng\u00e9n\u00e9rateur de formes\n, bas\u00e9 sur des boites ;\n\n\nl'\nexport de r\u00e9sultats\n.\n\n\n\n\npublic static void main(String[] args) throws Exception {\n\n  //Step 0 ; Defining an output existing folder\n  String outputFolder = \"/tmp/\";\n\n  // Step 1 : Creating the geographic environnement using the repository that contains the data\n\n  // Load default environment (data are in resource directory)\n  Environnement env = LoaderSHP.loadNoDTM(\n      new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath()));\n\n  // Select a parcel on which generation is proceeded\n  BasicPropertyUnit bPU = env.getBpU().get(2);\n\n  //Step 2 : Defining the regulation that will be applied during the simulation\n\n  // Rules parameters.8\n  // Distance to road\n  double distReculVoirie = 2;\n  // Distance to bottom of the parcel\n  double distReculFond = 3;\n  // Distance to lateral parcel limits\n  double distReculLat = 4;\n  // Distance between two buildings of a parcel\n  double distanceInterBati = 0;\n  // Maximal ratio built area\n  double maximalCES = 0.5;\n\n  //Instanciation of a predicate class\n  SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>(\n      bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES);\n\n\n\n  //Step 3 : Defining the regulation that will be applied during the simulation\n\n\n  // Instantiation of the sampler\n  OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection();\n\n\n  // Loading the parameters for the building shape generation\n  String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath();\n  String fileName = \"params.json\";\n  SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName));\n\n\n  // Run of the optimisation on a parcel with the predicate\n  GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred);\n\n  //4 - Writting the output\n  SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0);\n\n}\n\n\n\n\nEx\u00e9cution du code de simulation\n\uf0c1\n\n\nAvant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable \noutputFolder\n qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s.\n\n\nUne fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code.\n\n\nPendant l'ex\u00e9cution, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section \nsuivre l'\u00e9volution d'une simulation\n).\nDeux sorties sont visualisables pendant la simulation :\n\n\n\n\n\n\nDans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives au nombre d'objets et \u00e0 la valeur de la fonction d'optimisation ;\n\n\n\n\n\n\nDans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est l'oppos\u00e9 du volume de la configuration courante (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant).\n\n\n\n\n\n\n\n\nR\u00e9sultats de la premi\u00e8re simulation\n\uf0c1\n\n\nLa sortie est stock\u00e9e sous la forme du ShapeFile \nout.shp\n qui contient les diff\u00e9rentes boites avec des attributs stock\u00e9 dans le dossier  \noutputFolder\n :\n\n\n\n\nid\n : l'identifiant de la parcelle simul\u00e9e ;\n\n\nhauteur\n : la hauteur de la boite ;\n\n\nlongueur\n : la longueur de la boite ;\n\n\nlargeur\n : la largeur de la boite ;\n\n\norient\n : l'azimut de la boite ;\n\n\ncenterX\n, \ncenterY\n : les coordonn\u00e9es du centre de la boite.\n\n\n\n\nLa g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ.\n\n\n\n\nVous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diff\u00e9rentes variables de r\u00e8gles. \nDans la section suivante\n, nous d\u00e9taillons le principe de fonctionnement de la simulation.\n\n\nLe r\u00e9sultat est visualisable dans un SIG 2D ou 3D classique.",
            "title": "First simulation"
        },
        {
            "location": "/begin/first_simulation/#introduction",
            "text": "L'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9e de bo\u00eetes qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi et r\u00e9utilis\u00e9 dans cette documentation. Pour commencer, il est n\u00e9cessaire  d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la  page d'installation .  Le code utilis\u00e9 dans cette page se trouve dans la classe :   fr.ign.simplu3d.firstSimulation.BasicSimulator .",
            "title": "Introduction"
        },
        {
            "location": "/begin/first_simulation/#donnees-dentree",
            "text": "Les donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources  resources/firstSimulation/ . Il s'agit du plus petit ensemble de donn\u00e9es n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers :   data : qui contient un fichier ShapeFile de parcelles (parcelle.shp). Chaque parcelle a une g\u00e9om\u00e9trie surfacique et un attribut  id . Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans  la section consacr\u00e9e \u00e0 l'environnement g\u00e9ographique ) ;  scenario  : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de formes (d\u00e9crits dans la section d\u00e9di\u00e9e aux  param\u00e8tres de la g\u00e9n\u00e9ration de formes ) et des visiteurs qui indiqueront l'\u00e9tat d'avancement pendant la simulation ( d\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs ).",
            "title": "Donn\u00e9es d'entr\u00e9e"
        },
        {
            "location": "/begin/first_simulation/#code-de-simulation",
            "text": "Le code comment\u00e9 \u00e0 ex\u00e9cuter est repris ci-dessous. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation :   la cr\u00e9ation d'un  environnement g\u00e9ographique  ;  la d\u00e9finition de  contraintes morphologiques , \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ;  la d\u00e9finition d'un  g\u00e9n\u00e9rateur de formes , bas\u00e9 sur des boites ;  l' export de r\u00e9sultats .   public static void main(String[] args) throws Exception {\n\n  //Step 0 ; Defining an output existing folder\n  String outputFolder = \"/tmp/\";\n\n  // Step 1 : Creating the geographic environnement using the repository that contains the data\n\n  // Load default environment (data are in resource directory)\n  Environnement env = LoaderSHP.loadNoDTM(\n      new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath()));\n\n  // Select a parcel on which generation is proceeded\n  BasicPropertyUnit bPU = env.getBpU().get(2);\n\n  //Step 2 : Defining the regulation that will be applied during the simulation\n\n  // Rules parameters.8\n  // Distance to road\n  double distReculVoirie = 2;\n  // Distance to bottom of the parcel\n  double distReculFond = 3;\n  // Distance to lateral parcel limits\n  double distReculLat = 4;\n  // Distance between two buildings of a parcel\n  double distanceInterBati = 0;\n  // Maximal ratio built area\n  double maximalCES = 0.5;\n\n  //Instanciation of a predicate class\n  SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>(\n      bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES);\n\n\n\n  //Step 3 : Defining the regulation that will be applied during the simulation\n\n\n  // Instantiation of the sampler\n  OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection();\n\n\n  // Loading the parameters for the building shape generation\n  String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath();\n  String fileName = \"params.json\";\n  SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName));\n\n\n  // Run of the optimisation on a parcel with the predicate\n  GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred);\n\n  //4 - Writting the output\n  SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0);\n\n}",
            "title": "Code de simulation"
        },
        {
            "location": "/begin/first_simulation/#execution-du-code-de-simulation",
            "text": "Avant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable  outputFolder  qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s.  Une fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code.  Pendant l'ex\u00e9cution, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section  suivre l'\u00e9volution d'une simulation ).\nDeux sorties sont visualisables pendant la simulation :    Dans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives au nombre d'objets et \u00e0 la valeur de la fonction d'optimisation ;    Dans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est l'oppos\u00e9 du volume de la configuration courante (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant).",
            "title": "Ex\u00e9cution du code de simulation"
        },
        {
            "location": "/begin/first_simulation/#resultats-de-la-premiere-simulation",
            "text": "La sortie est stock\u00e9e sous la forme du ShapeFile  out.shp  qui contient les diff\u00e9rentes boites avec des attributs stock\u00e9 dans le dossier   outputFolder  :   id  : l'identifiant de la parcelle simul\u00e9e ;  hauteur  : la hauteur de la boite ;  longueur  : la longueur de la boite ;  largeur  : la largeur de la boite ;  orient  : l'azimut de la boite ;  centerX ,  centerY  : les coordonn\u00e9es du centre de la boite.   La g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ.   Vous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diff\u00e9rentes variables de r\u00e8gles.  Dans la section suivante , nous d\u00e9taillons le principe de fonctionnement de la simulation.  Le r\u00e9sultat est visualisable dans un SIG 2D ou 3D classique.",
            "title": "R\u00e9sultats de la premi\u00e8re simulation"
        },
        {
            "location": "/begin/installation/",
            "text": "Installer SimPLU3D\n\uf0c1\n\n\nLes biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN \nhttps://forge-cogit.ign.fr/nexus/#welcome\n. Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet \nSimPLU3D-tutorial\n ou sinon vous pouvez directement installer les biblioth\u00e8ques dans votre projet.\n\n\n\n\n \nAttention\n: il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions :\n\n\n\n\n\n\nInstaller localement le certificat comme d\u00e9crit dans le lien suivant \nhttp://ignf.github.io/geoxygene/documentation/developer/install.html\n\n\n\n\n\n\nFaire une installation non s\u00e9curis\u00e9e lors du build du projet projet : \nmvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true\n\n\n\n\n\n\n\n\nInstaller le code SimPLU3D-tutorial\n\uf0c1\n\n\nLes \u00e9tapes suivantes sont n\u00e9cessaires :\n\n\n1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes : \nhttp://ignf.github.io/geoxygene/documentation/developer/install.html\n\n\n2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial\n\n\n3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\"\n\n\n4 - Lancer une installation avec Maven :\n\n\n\n\nClick droit sur le projet et \"\nRun as Maven Install\n\"\n\n\nou directement en ligne de commande : \nmvn clean install\n\n\n\n\n5 - Lancer une construction du projet avec Eclipse : \nProject > Build project\n\n\nVous pouvez d\u00e9sormais ex\u00e9cuter la \npremi\u00e8re simulation\n.\n\n\nN\u00e9anmoins, pour avoir acc\u00e8s au code source pendant le tutoriel, il est recommand\u00e9 d'installer en local les codes issus de \nSimPLU3D\n et \nSimPLU3D-rules\n.\n\n\nInstaller SimPLU3D dans un autre projet\n\uf0c1\n\n\nL'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes :\n\n\n1 - Cr\u00e9ation d'un projet Maven\n\n\n2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises \ndependencies\n, en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D.\n\n\n<dependency>\n  <groupId>fr.ign.cogit</groupId>\n  <artifactId>simplu3d</artifactId>\n  <version>1.2-SNAPSHOT</version>\n</dependency>\n\n\n\n\n3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises \nrepositories\n\n\n<repository>\n  <id>ign-snapshots</id>\n  <name>Cogit Snapshots Repository</name>\n  <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url>\n  <snapshots>\n    <enabled>true</enabled>\n  </snapshots>\n  <releases>\n    <enabled>false</enabled>\n  </releases>\n</repository>\n<repository>\n  <id>ign-releases</id>\n  <name>Cogit Releases Repository</name>\n  <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url>\n  <snapshots>\n    <enabled>false</enabled>\n  </snapshots>\n  <releases>\n    <enabled>true</enabled>\n  </releases>\n</repository>\n\n\n\n\n4 - Faire un build du projet en utilisant par exemple : \nmaven install\n.",
            "title": "Installation"
        },
        {
            "location": "/begin/installation/#installer-simplu3d",
            "text": "Les biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN  https://forge-cogit.ign.fr/nexus/#welcome . Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet  SimPLU3D-tutorial  ou sinon vous pouvez directement installer les biblioth\u00e8ques dans votre projet.     Attention : il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions :    Installer localement le certificat comme d\u00e9crit dans le lien suivant  http://ignf.github.io/geoxygene/documentation/developer/install.html    Faire une installation non s\u00e9curis\u00e9e lors du build du projet projet :  mvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true",
            "title": "Installer SimPLU3D"
        },
        {
            "location": "/begin/installation/#installer-le-code-simplu3d-tutorial",
            "text": "Les \u00e9tapes suivantes sont n\u00e9cessaires :  1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes :  http://ignf.github.io/geoxygene/documentation/developer/install.html  2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial  3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\"  4 - Lancer une installation avec Maven :   Click droit sur le projet et \" Run as Maven Install \"  ou directement en ligne de commande :  mvn clean install   5 - Lancer une construction du projet avec Eclipse :  Project > Build project  Vous pouvez d\u00e9sormais ex\u00e9cuter la  premi\u00e8re simulation .  N\u00e9anmoins, pour avoir acc\u00e8s au code source pendant le tutoriel, il est recommand\u00e9 d'installer en local les codes issus de  SimPLU3D  et  SimPLU3D-rules .",
            "title": "Installer le code SimPLU3D-tutorial"
        },
        {
            "location": "/begin/installation/#installer-simplu3d-dans-un-autre-projet",
            "text": "L'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes :  1 - Cr\u00e9ation d'un projet Maven  2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises  dependencies , en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D.  <dependency>\n  <groupId>fr.ign.cogit</groupId>\n  <artifactId>simplu3d</artifactId>\n  <version>1.2-SNAPSHOT</version>\n</dependency>  3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises  repositories  <repository>\n  <id>ign-snapshots</id>\n  <name>Cogit Snapshots Repository</name>\n  <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url>\n  <snapshots>\n    <enabled>true</enabled>\n  </snapshots>\n  <releases>\n    <enabled>false</enabled>\n  </releases>\n</repository>\n<repository>\n  <id>ign-releases</id>\n  <name>Cogit Releases Repository</name>\n  <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url>\n  <snapshots>\n    <enabled>false</enabled>\n  </snapshots>\n  <releases>\n    <enabled>true</enabled>\n  </releases>\n</repository>  4 - Faire un build du projet en utilisant par exemple :  maven install .",
            "title": "Installer SimPLU3D dans un autre projet"
        },
        {
            "location": "/begin/intro/",
            "text": "Introduction\n\uf0c1\n\n\nSimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re.\n\n\nCela signifie que pour \u00eatre capable d'utiliser SimPLU3D, il est n\u00e9cessaire d'avoir des comp\u00e9tences :\n\n\n\n\ndans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des generics ;\n\n\ndans le gestionnaire de projet Maven afin de pouvoir importer les biblioth\u00e8ques de SimPLU3D ;\n\n\nsi possible, sur le fonctionnement de \nGeOxygene\n et notamment \nde son module 3D\n. Cela peut \u00eatre n\u00e9cessaire \u00e9tant donn\u00e9 que cette biblioth\u00e8que est utilis\u00e9e pour les op\u00e9rations SIG (n\u00e9anmoins, si vous n'\u00eates pas familier avec ce projet, les classes et m\u00e9thodes utilis\u00e9es sont relativement communes aux autres API de d\u00e9veloppement SIG).\n\n\n\n\nLa documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D :\n\n\n\n\nL'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son \nenvironnement g\u00e9ographique\n ;\n\n\nLa g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation\n ;\n\n\nLa d\u00e9finition des contraintes morphologiques\n qui contraignent la g\u00e9n\u00e9ration.\n\n\n\n\nPour illustrer comment utiliser SimPLU3D, des codes comment\u00e9s sont mis \u00e0 disposition dans le projet \nSimPLU3D-tutorial\n. Ces codes partent de l'exemple d'une \npremi\u00e8re simulation\n et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles.\n\n\nPour d\u00e9buter, il est tout d'abord n\u00e9cessaire \nd'installer SimPLU3D\n.",
            "title": "Intro"
        },
        {
            "location": "/begin/intro/#introduction",
            "text": "SimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re.  Cela signifie que pour \u00eatre capable d'utiliser SimPLU3D, il est n\u00e9cessaire d'avoir des comp\u00e9tences :   dans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des generics ;  dans le gestionnaire de projet Maven afin de pouvoir importer les biblioth\u00e8ques de SimPLU3D ;  si possible, sur le fonctionnement de  GeOxygene  et notamment  de son module 3D . Cela peut \u00eatre n\u00e9cessaire \u00e9tant donn\u00e9 que cette biblioth\u00e8que est utilis\u00e9e pour les op\u00e9rations SIG (n\u00e9anmoins, si vous n'\u00eates pas familier avec ce projet, les classes et m\u00e9thodes utilis\u00e9es sont relativement communes aux autres API de d\u00e9veloppement SIG).   La documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D :   L'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son  environnement g\u00e9ographique  ;  La g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation  ;  La d\u00e9finition des contraintes morphologiques  qui contraignent la g\u00e9n\u00e9ration.   Pour illustrer comment utiliser SimPLU3D, des codes comment\u00e9s sont mis \u00e0 disposition dans le projet  SimPLU3D-tutorial . Ces codes partent de l'exemple d'une  premi\u00e8re simulation  et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles.  Pour d\u00e9buter, il est tout d'abord n\u00e9cessaire  d'installer SimPLU3D .",
            "title": "Introduction"
        },
        {
            "location": "/envgeo/integration-test/",
            "text": "V\u00e9rifier l'int\u00e9gration des donn\u00e9es\n\uf0c1\n\n\nL'objectif de cette page est de proposer deux m\u00e9thodes pour v\u00e9rifier la bonne int\u00e9gration des donn\u00e9es \u00e0 partir d'un jeu de donn\u00e9es complet. Il est possible soit :\n- d'exporter les instances du mod\u00e8le sous forme de ShapeFiles ;\n- de visualisation en 3D les informations du mod\u00e8le.\n\n\nCes codes sont disponibles dans le projet du tutoriel dans le package \nfr.ign.simplu3d.testIntegration\n.\n\n\n\n\n \nAttention\n: : pour ces codes, la visualisation 3D et le chargement de MNT n\u00e9cessitent l'utilisation de biblioth\u00e8ques natives Java 3D (qui se trouvent dans le projet SimPLU3d-tutorial). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant :\n\n\n-Djava.library.path=./lib/native_libraries/linux-amd64\n  \n\n\nLa ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.\n\n\n\n\nJeu de donn\u00e9es\n\uf0c1\n\n\nUn jeu de donn\u00e9es complet suivant les \nsp\u00e9cifications du processus d'int\u00e9gration\n est disponible dans le dossier \nresources/completeDataSet\n. On peut voir ci-dessous une carte de ces donn\u00e9es :\n\n\n\n\nOn peut noter dans ce jeu de donn\u00e9es la pr\u00e9sence d'un MNT et de b\u00e2timents 3D avec un toit typifi\u00e9 (ce qui explique les polygones internes aux polygones de b\u00e2timents).\n\n\nExport des informations du mod\u00e8le sous forme de Shapefile\n\uf0c1\n\n\nLa classe \nExportAsShape\n permet d'exporter l'instance de la classe \nEnvironnement\n sous forme de Shapefiles. Le code n\u00e9cessite de d\u00e9terminer un dossier de sortie pour pouvoir \u00eatre appliqu\u00e9 (et il utilise le dossier de ressource qui se trouve dans le projet).\n\n\nL'ex\u00e9cution du code g\u00e9n\u00e8re une s\u00e9rie de ShapeFiles repr\u00e9sent\u00e9s dans la carte suivante.\n\n\n\n\nLes g\u00e9om\u00e9tries en sortie sont triangul\u00e9es car plaqu\u00e9es sur le MNT (s'il est utilis\u00e9). On retrouve les fichiers suivantes :\n\n\n\n\n\n\n\n\nNom du fichier\n\n\nContenu\n\n\nAttributs int\u00e9ressants\n\n\n\n\n\n\n\n\n\n\nbpu.shp\n\n\nUnit\u00e9s fonci\u00e8res\n\n\n\n\n\n\n\n\nparcelles.shp\n\n\nParcelles\n\n\nID\n : Code \n \nBounNum\n : Nombre de limites s\u00e9paratives \n \nBuildNum\n : Nombre de b\u00e2timents\n\n\n\n\n\n\nsubParcels.shp\n\n\nSous-parcelles\n\n\nNB Bat\n : Nombre de parties de b\u00e2timents\n\n\n\n\n\n\nbordures.shp\n\n\nLimites s\u00e9paratives des parcelles\n\n\nType\n : type de la limite \n \nIDPAR\n : identifiant de la parcelle \n \nAdj\n : Identifiant de la parcelle adjacente \n  \nSIDE\n : c\u00f4t\u00e9 de la limite (droite ou gauche)\n\n\n\n\n\n\nbordures_translated.shp\n\n\nLimites s\u00e9paratives translat\u00e9e\n\n\nType\n : type de la limite \n \nSIDE\n : c\u00f4t\u00e9 de la limite (droite ou gauche)\n\n\n\n\n\n\nopposites.shp\n\n\nLien entre une limite et la limite oppos\u00e9e\n\n\n\n\n\n\n\n\nfootprints.shp\n\n\nEmprise des b\u00e2timents 3D\n\n\n\n\n\n\n\n\nfaitage.shp\n\n\nFa\u00eetage des b\u00e2timents\n\n\n\n\n\n\n\n\npignon.shp\n\n\nPignons des b\u00e2timents\n\n\n\n\n\n\n\n\nroads.shp\n\n\nSurface des routes\n\n\nNom\n : nom des routes\n\n\n\n\n\n\n\n\nLes limites s\u00e9paratives du fichier \nbordures_translate.shp\n sont translat\u00e9es vers l'int\u00e9rieur des parcelles auxquelles ils appartiennent pour des raison de lisibilit\u00e9 (afin d'\u00e9viter les superposition entre limites appartenant \u00e0 des parcelles adjacentes).\nPour les valeurs des \u00e9num\u00e9ration \nSIDE\n et \nType\n des limites s\u00e9paratives, vous pouvez vous r\u00e9f\u00e9rer aux \u00e9num\u00e9rations \nParcelBoundaryType\n et \nParcelBoundarySide\n.\n\n\nVisualisation 3D des informations du mod\u00e8le\n\uf0c1\n\n\nLa classe \nIntegration3DViewer\n permet une visualisation 3D d'un environnement. Il est possible de d\u00e9terminer via une liste de th\u00e8mes, les informations \u00e0 afficher dans la vue 3D. La liste des th\u00e8mes disponibles est consultable via l'\u00e9num\u00e9ration \nRepEnvironnement.Theme\n. Pour chaque th\u00e8me, un rendu est pr\u00e9d\u00e9fini afin de visualiser les informations correspondantes.\n\n\nLe visualisateur 3D utilis\u00e9 est celui de GeOxygene3D vous trouverez plus de documentation sur comment repr\u00e9senter des donn\u00e9es et sur comment naviguer sur \nle site de GeOxygene\n.",
            "title": "Integration test"
        },
        {
            "location": "/envgeo/integration-test/#verifier-lintegration-des-donnees",
            "text": "L'objectif de cette page est de proposer deux m\u00e9thodes pour v\u00e9rifier la bonne int\u00e9gration des donn\u00e9es \u00e0 partir d'un jeu de donn\u00e9es complet. Il est possible soit :\n- d'exporter les instances du mod\u00e8le sous forme de ShapeFiles ;\n- de visualisation en 3D les informations du mod\u00e8le.  Ces codes sont disponibles dans le projet du tutoriel dans le package  fr.ign.simplu3d.testIntegration .     Attention : : pour ces codes, la visualisation 3D et le chargement de MNT n\u00e9cessitent l'utilisation de biblioth\u00e8ques natives Java 3D (qui se trouvent dans le projet SimPLU3d-tutorial). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant :  -Djava.library.path=./lib/native_libraries/linux-amd64     La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.",
            "title": "V\u00e9rifier l'int\u00e9gration des donn\u00e9es"
        },
        {
            "location": "/envgeo/integration-test/#jeu-de-donnees",
            "text": "Un jeu de donn\u00e9es complet suivant les  sp\u00e9cifications du processus d'int\u00e9gration  est disponible dans le dossier  resources/completeDataSet . On peut voir ci-dessous une carte de ces donn\u00e9es :   On peut noter dans ce jeu de donn\u00e9es la pr\u00e9sence d'un MNT et de b\u00e2timents 3D avec un toit typifi\u00e9 (ce qui explique les polygones internes aux polygones de b\u00e2timents).",
            "title": "Jeu de donn\u00e9es"
        },
        {
            "location": "/envgeo/integration-test/#export-des-informations-du-modele-sous-forme-de-shapefile",
            "text": "La classe  ExportAsShape  permet d'exporter l'instance de la classe  Environnement  sous forme de Shapefiles. Le code n\u00e9cessite de d\u00e9terminer un dossier de sortie pour pouvoir \u00eatre appliqu\u00e9 (et il utilise le dossier de ressource qui se trouve dans le projet).  L'ex\u00e9cution du code g\u00e9n\u00e8re une s\u00e9rie de ShapeFiles repr\u00e9sent\u00e9s dans la carte suivante.   Les g\u00e9om\u00e9tries en sortie sont triangul\u00e9es car plaqu\u00e9es sur le MNT (s'il est utilis\u00e9). On retrouve les fichiers suivantes :     Nom du fichier  Contenu  Attributs int\u00e9ressants      bpu.shp  Unit\u00e9s fonci\u00e8res     parcelles.shp  Parcelles  ID  : Code    BounNum  : Nombre de limites s\u00e9paratives    BuildNum  : Nombre de b\u00e2timents    subParcels.shp  Sous-parcelles  NB Bat  : Nombre de parties de b\u00e2timents    bordures.shp  Limites s\u00e9paratives des parcelles  Type  : type de la limite    IDPAR  : identifiant de la parcelle    Adj  : Identifiant de la parcelle adjacente     SIDE  : c\u00f4t\u00e9 de la limite (droite ou gauche)    bordures_translated.shp  Limites s\u00e9paratives translat\u00e9e  Type  : type de la limite    SIDE  : c\u00f4t\u00e9 de la limite (droite ou gauche)    opposites.shp  Lien entre une limite et la limite oppos\u00e9e     footprints.shp  Emprise des b\u00e2timents 3D     faitage.shp  Fa\u00eetage des b\u00e2timents     pignon.shp  Pignons des b\u00e2timents     roads.shp  Surface des routes  Nom  : nom des routes     Les limites s\u00e9paratives du fichier  bordures_translate.shp  sont translat\u00e9es vers l'int\u00e9rieur des parcelles auxquelles ils appartiennent pour des raison de lisibilit\u00e9 (afin d'\u00e9viter les superposition entre limites appartenant \u00e0 des parcelles adjacentes).\nPour les valeurs des \u00e9num\u00e9ration  SIDE  et  Type  des limites s\u00e9paratives, vous pouvez vous r\u00e9f\u00e9rer aux \u00e9num\u00e9rations  ParcelBoundaryType  et  ParcelBoundarySide .",
            "title": "Export des informations du mod\u00e8le sous forme de Shapefile"
        },
        {
            "location": "/envgeo/integration-test/#visualisation-3d-des-informations-du-modele",
            "text": "La classe  Integration3DViewer  permet une visualisation 3D d'un environnement. Il est possible de d\u00e9terminer via une liste de th\u00e8mes, les informations \u00e0 afficher dans la vue 3D. La liste des th\u00e8mes disponibles est consultable via l'\u00e9num\u00e9ration  RepEnvironnement.Theme . Pour chaque th\u00e8me, un rendu est pr\u00e9d\u00e9fini afin de visualiser les informations correspondantes.  Le visualisateur 3D utilis\u00e9 est celui de GeOxygene3D vous trouverez plus de documentation sur comment repr\u00e9senter des donn\u00e9es et sur comment naviguer sur  le site de GeOxygene .",
            "title": "Visualisation 3D des informations du mod\u00e8le"
        },
        {
            "location": "/envgeo/integration/",
            "text": "Processus d'int\u00e9gration\n\uf0c1\n\n\nUn processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe \nEnvironnement\n en renseignant un certain nombre d'attributs.\n\n\nLe processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe \nfr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP\n du d\u00e9pot \nSimPLU3D-rules\n)  ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe \nfr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS\n, m\u00eame d\u00e9pot). Quel que soit l'approche choisie, les deux classes ont une m\u00e9thode \nload\n, qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de \nIFeature\n de GeOxygene et faire appelle \u00e0 la m\u00e9thode \nload\n de la classe \nfr.ign.cogit.simplu3d.io.LoadFromCollection\n qui va instancier les entit\u00e9s du mod\u00e8le.\n\n\nDans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en \nfonction de la source de donn\u00e9es utilis\u00e9e\n, puis d\u00e9crire dans le d\u00e9tail \nle processus d'int\u00e9gration\n.\n\n\n\n\n \nAttention\n: actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen direct d'instancier le mod\u00e8le g\u00e9ographique convenablement.\n\n\n\n\nSources de donn\u00e9es utilis\u00e9es\n\uf0c1\n\n\nLa donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es  d\u00e9pendent du choix de la source de donn\u00e9es  \nShapeFiles\n ou \nPostGIS\n. Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires.  Cependant, \nles noms des attributs utilis\u00e9s\n sont les m\u00eames quelle que soit la source utilis\u00e9e et sont stock\u00e9s au m\u00eame endroit dans le code.\n\n\nSource de donn\u00e9es ShapeFile\n\uf0c1\n\n\nLa classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP.\n\n\n\n\n\n\n\n\nSource de donn\u00e9es\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType de g\u00e9om\u00e9trie\n\n\n\n\n\n\n\n\n\n\nDocument d'Urbanisme\n\n\nNOM_FICHIER_PLU\n\n\ndoc_urba.shp\n\n\nNon utilis\u00e9e\n\n\n\n\n\n\nZonage r\u00e9glementaire\n\n\nNOM_FICHIER_ZONAGE\n\n\nzone_urba.shp\n\n\n(Multi-) Polygone 2D (sans intersection)\n\n\n\n\n\n\nParcelles\n\n\nNOM_FICHIER_PARCELLE\n\n\nparcelle.shp\n\n\nPolygone 2D (sans intersection)\n\n\n\n\n\n\nB\u00e2timents\n\n\nNOM_FICHIER_BATIMENTS\n\n\nbatiment.shp\n\n\nMulti-Polygone 3D\n\n\n\n\n\n\nRoute\n\n\nNOM_FICHIER_VOIRIE\n\n\nroute.shp\n\n\n(Multi-) Lin\u00e9aire 2D ou 3D\n\n\n\n\n\n\nMNT\n\n\nNOM_FICHIER_TERRAIN\n\n\nmnt.asc\n\n\nMNT grille maill\u00e9\n\n\n\n\n\n\nPrescriptions ponctuelles\n\n\nNOM_FICHIER_PRESC_PONCTUELLE\n\n\nprescription_pct.shp\n\n\n(Multi -) Ponctuelle 2D\n\n\n\n\n\n\nPrescriptions lin\u00e9aires\n\n\nNOM_FICHIER_PRESC_LINEAIRE\n\n\nprescription_lin.shp\n\n\n(Multi-) Lin\u00e9aire 2D\n\n\n\n\n\n\nPrescriptions surfaciques\n\n\nNOM_FICHIER_PRESC_SURFACIQUE\n\n\nprescription_surf.shp\n\n\n(Multi-) Surfacique 2D\n\n\n\n\n\n\n\n\nSource de donn\u00e9es PostGIS\n\uf0c1\n\n\nLa classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tables est \nfr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS\n. Le MNT est stock\u00e9 comme un raster dans PostGIS.\n\n\n\n\n\n\n\n\nSource de donn\u00e9es\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType de g\u00e9om\u00e9trie\n\n\n\n\n\n\n\n\n\n\nDocument d'Urbanisme\n\n\nNOM_TABLE_PLU\n\n\nplu\n\n\nNon utilis\u00e9es\n\n\n\n\n\n\nZonage r\u00e9glementaire\n\n\nNOM_TABLE_ZONAGE\n\n\nzonage\n\n\n(Multi-) Polygone 2D (sans intersection)\n\n\n\n\n\n\nParcelles\n\n\nNOM_FICHIER_PARCELLE\n\n\nparcelle\n\n\nPolygones 2D (sans intersection)\n\n\n\n\n\n\nB\u00e2timents\n\n\nNOM_TABLE_BATIMENTS\n\n\nbatiment\n\n\nMulti-Polygone 3D\n\n\n\n\n\n\nRoute\n\n\nNOM_TABLE_VOIRIE\n\n\nroute\n\n\n(Multi-) Lin\u00e9aire 2D ou 3D\n\n\n\n\n\n\nMNT\n\n\nNOM_FICHIER_TERRAIN\n\n\nmnt\n\n\nMNT grille maill\u00e9\n\n\n\n\n\n\nPrescriptions ponctuelles\n\n\nNOM_TABLE_PRESC_PCT\n\n\nprescriptionpct\n\n\n(Multi -) Ponctuelle 2D\n\n\n\n\n\n\nPrescriptions lin\u00e9aires\n\n\nNOM_TABLE_PRESC_LINEAIRE\n\n\nprescriptionlin\n\n\n(Multi-) Lin\u00e9aire 2D\n\n\n\n\n\n\nPrescriptions surfaciques\n\n\nNOM_TABLE_PRESC_SURF\n\n\nprescriptionsurf\n\n\n(Multi-) Surfacique 2D\n\n\n\n\n\n\n\n\nNom des attributs\n\uf0c1\n\n\nPour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe : \nfr.ign.cogit.simplu3d.io.feature.AttribNames\n.  \n\n\nDocument d'urbanisme\n\uf0c1\n\n\nLes attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme.\n\n\n\n\n\n\n\n\nAttribut\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType\n\n\n\n\n\n\n\n\n\n\nIdentifiant\n\n\nATT_ID_URBA\n\n\nIDURBA\n\n\nString\n\n\n\n\n\n\nType de document\n\n\nATT_TYPE_DOC\n\n\nTYPEDOC\n\n\nString\n\n\n\n\n\n\nDate Approbation\n\n\nATT_DATE_APPRO\n\n\nDATAPPRO\n\n\nDate (yyyyMMdd)\n\n\n\n\n\n\nDate Fin\n\n\nATT_DATE_FIN\n\n\nDATEFIN\n\n\nDate (yyyyMMdd)\n\n\n\n\n\n\nIntercommunalit\u00e9\n\n\nATT_INTER_CO\n\n\nINTERCO\n\n\nString\n\n\n\n\n\n\nNum\u00e9ro SIREN\n\n\nATT_SIREN\n\n\nSIREN\n\n\nString\n\n\n\n\n\n\n\u00c9tat du document\n\n\nATT_ETAT\n\n\nETAT\n\n\nString\n\n\n\n\n\n\nNom de la r\u00e9gion\n\n\nATT_NOM_REG\n\n\nNOMREG\n\n\nString\n\n\n\n\n\n\nURL de la r\u00e9gion\n\n\nATT_URL_REG\n\n\nURLREG\n\n\nString\n\n\n\n\n\n\nNom du plan\n\n\nATT_NOM_PLAN\n\n\nNOMPLAN\n\n\nString\n\n\n\n\n\n\nURL du plan\n\n\nATT_URL_PLAN\n\n\nURLPLAN\n\n\nString\n\n\n\n\n\n\nSite web\n\n\nATT_SITE_WEB\n\n\nSITEWEB\n\n\nString\n\n\n\n\n\n\nType ref\n\n\nATT_TYPE_REF\n\n\nTYPEREF\n\n\nString\n\n\n\n\n\n\nDate de r\u00e9f\u00e9rence\n\n\nATT_DATE_REF\n\n\nDATEREF\n\n\nDate (yyyy)\n\n\n\n\n\n\n\n\nZonage r\u00e9glementaire\n\uf0c1\n\n\nLes attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme.\n\n\n\n\n\n\n\n\nAttribut\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType\n\n\n\n\n\n\n\n\n\n\nLibell\u00e9\n\n\nATT_LIBELLE\n\n\nLIBELLE\n\n\nString\n\n\n\n\n\n\nLibell\u00e9 long\n\n\nATT_LIBELONG\n\n\nLIBELONG\n\n\nString\n\n\n\n\n\n\nType de zone\n\n\nATT_TYPE_ZONE\n\n\nTYPEZONE\n\n\nString\n\n\n\n\n\n\nDestination dominante\n\n\nATT_DESTDOMI\n\n\nDESTDOMI\n\n\nString\n\n\n\n\n\n\nNom de fichier associ\u00e9\n\n\nATT_NOMFIC\n\n\nNOMFIC\n\n\nString\n\n\n\n\n\n\nURL du fichier associ\u00e9\n\n\nATT_URLFIC\n\n\nURLFIC\n\n\nString\n\n\n\n\n\n\nINSEE\n\n\nATT_INSEE\n\n\nINSEE\n\n\nString\n\n\n\n\n\n\nDate d'approbation\n\n\nVALIDITY_DATE_APPRO\n\n\nDATAPPRO\n\n\nDate (yyyyMMdd)\n\n\n\n\n\n\nDate de validation\n\n\nVALIDITY_DATE_VALID\n\n\nDATVALID\n\n\nDate (yyyyMMdd)\n\n\n\n\n\n\nCommentaires \u00e9ventuels\n\n\nATT_TEXT\n\n\nTEXT\n\n\nString\n\n\n\n\n\n\n\n\nParcelles\n\uf0c1\n\n\nChaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut \nATT_CODE_PARC\n ou est construit par la concat\u00e9nation des attributs valeurs des \nATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO\n et accessible par la m\u00e9thode \ngetCode\n de la classe * fr.ign.cogit.simplu3d.model.CadastralParcel*.\n\n\nL'attribut \nATT_HAS_TO_BE_SIMULATED\n est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false).\n\n\n\n\n\n\n\n\nAttribut\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType\n\n\n\n\n\n\n\n\n\n\nIdentifiant de la parcelle\n\n\nATT_CODE_PARC\n\n\nCODE\n\n\nString\n\n\n\n\n\n\nCode du d\u00e9partement\n\n\nATT_BDP_CODE_DEP\n\n\nCODE_DEP\n\n\nString\n\n\n\n\n\n\nCode de la commune\n\n\nATT_BDP_CODE_COM\n\n\nCODE_COM\n\n\nString\n\n\n\n\n\n\nCompl\u00e9ment pour code INSEE\n\n\nATT_BDP_COM_ABS\n\n\nCOM_ABS\n\n\nString\n\n\n\n\n\n\nSection cadastrale\n\n\nATT_BDP_SECTION\n\n\nSECTION\n\n\nString\n\n\n\n\n\n\nNum\u00e9ro de parcelle\n\n\nATT_BDP_NUMERO\n\n\nNUMERO\n\n\nString\n\n\n\n\n\n\nIndique si la parcelle doit \u00eatre simul\u00e9e\n\n\nATT_HAS_TO_BE_SIMULATED\n\n\nSIMUL\n\n\nBoolean, Integer, String\n\n\n\n\n\n\n\n\nB\u00e2timents\n\uf0c1\n\n\nPas d'attribut utilis\u00e9.\n\n\nRoute\n\uf0c1\n\n\n\n\n\n\n\n\nAttribut\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType\n\n\n\n\n\n\n\n\n\n\nNom de la rue\n\n\nATT_NOM_RUE\n\n\nNOM_RUE_G\n\n\nString\n\n\n\n\n\n\nLargeur en m\n\n\nATT_LARGEUR\n\n\nLARGEUR\n\n\nDouble\n\n\n\n\n\n\nType de la rue\n\n\nATT_TYPE_ROAD\n\n\nNATURE\n\n\nString\n\n\n\n\n\n\n\n\nMNT\n\uf0c1\n\n\nPas d'attribut utilis\u00e9.\n\n\nPrescriptions ponctuelles, lin\u00e9aires et surfaciques\n\uf0c1\n\n\n\n\n\n\n\n\nAttribut\n\n\nNom de la variable\n\n\nValeur par d\u00e9faut\n\n\nType\n\n\n\n\n\n\n\n\n\n\nType de prescription\n\n\nATT_TYPE_PRESCRIPTION\n\n\nTYPEPSC\n\n\nString\n\n\n\n\n\n\nLibell\u00e9 de la prescription\n\n\nATT_LABEL\n\n\nLIBELLE\n\n\nDouble\n\n\n\n\n\n\nValeur de recul\n\n\nATT_RECOIL\n\n\nRECOIL\n\n\nString\n\n\n\n\n\n\n\n\nCode d'int\u00e9gration\n\uf0c1\n\n\nLe code d'int\u00e9gration se trouve ci-dessous, il est compos\u00e9 de 12 \u00e9tapes.\n\n\n\n\nCr\u00e9ation de l'objet PLU\n\n\nCr\u00e9ation des zones et assignation des r\u00e8gles aux zones\n\n\nAssignement des zonages au PLU\n\n\nChargement des parcelles et cr\u00e9ations des bordures\n\n\nImport des sous parcelles\n\n\nCr\u00e9ation des unit\u00e9s foncir\u00e8es\n\n\nImport des b\u00e2timents\n    7.1 Assignation des batiments aux BpU\n\n\nChargement des voiries\n\n\nAffectation des liens entre une bordure et ses objets adjacents (bordure sur route => route + relation entre les limites de parcelles)\n\n\nD\u00e9tection des limites s\u00e9paratives oppos\u00e9es\n\n\nImport des alignements\n\n\nAffectation de la coordonn\u00e9es Z \u00e0 l'ensemble des \u00e9l\u00e9ments \n\n\n\n\nQuelques \u00e9tapes sont param\u00e9trables :\n\n\nLa premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible d'activer la transformation avec le boolean \nEnvironnement.TRANSLATE_TO_ZERO\n et en assignant des coordonn\u00e9es (classe \nDirectPosition\n de GeOxygene) \u00e0 l'attribut statique \nEnvironnement.dpTranslate\n.\n\n\nPendant l'\u00e9tape d'annotation des limites s\u00e9paratives en limites de fond, lat\u00e9rales et de voirie (\u00e9tape\n  4), le processus d\u00e9termine automatiquement ces types suivant une \u00e9valuation du d\u00e9passement de la limite s\u00e9parative par rapport au point d'intersection avec la voirie (cf image suivante). Par d\u00e9faut, la valeur de d\u00e9passement jusqu'\u00e0 laquelle les limites sont affect\u00e9es comme lat\u00e9rales est de 3 m, mais elle peut \u00eatre fix\u00e9e en modifiant la valeur  \nAbstractBoundaryAnalyzer.setThresholdIni(double)\n. Pour les parcelles plus petites, le seuil est automatiquement ajust\u00e9 pour atteindre 1/3 de la largeur de la bo\u00eete englobante orient\u00e9e.\n\n\nPour une parcelle n'ayant pas d'acc\u00e8s \u00e0 la voirie, toutes les limites sont de type \"Fond\". Le c\u00f4t\u00e9 (GAUCHE ou DROITE) des limites lat\u00e9rales est d\u00e9termin\u00e9e en regardant la parcelle depuis la voirie. Si une parcelle donne sur plusieurs voiries, les c\u00f4t\u00e9s DROITE et GAUCHE sont d\u00e9termin\u00e9s al\u00e9atoirement.\n\n\n\n\nPour les \u00e9tapes qui recherchent des objets \u00e0 proximit\u00e9 des limites s\u00e9paratives comme les \u00e9tapes 9 et 10, il est possible de fixer la distance maximale de recherche en fixant les valeurs : \nNearestRoadFinder.setMaximumDistance()\n pour la recherche de la voirie la plus proche d'une limite cadastrale et  \nOppositeBoundaryFinder.setMaximalValue()\n pour la recherche de la limite oppos\u00e9e \u00e0 une limite cadastrale.\n\n\nAfin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D  parcelles, prescriptions, zonages et \u00e9ventuellement voiries (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe \nfr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ\n. Deux types de transformation sont possibles :\n- Si le MNT est d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ;\n- S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut).\n\n\npublic static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl,\n    IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl,\n    IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions,\n    AbstractDTM dtm, Environnement env) throws Exception {\n\n  // Etape 0 : doit on translater tous les objets ?\n\n  if (Environnement.TRANSLATE_TO_ZERO) {\n    Environnement.dpTranslate = zoneColl.envelope().center();\n    for (IFeature feat : zoneColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : parcelleColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : voirieColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : batiColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : prescriptions) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n  }\n\n  // Etape 1 : cr\u00e9ation de l'objet PLU\n  logger.info(\"Read UrbaDocument...\");\n  UrbaDocument plu;\n  if (featPLU == null) {\n    plu = new UrbaDocument();\n  } else {\n    UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader();\n    plu = urbaDocumentReader.read(featPLU);\n  }\n  env.setUrbaDocument(plu);\n\n  // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones\n  logger.info(\"Loading UrbaZone...\");\n  UrbaZoneReader urbaZoneReader = new UrbaZoneReader();\n  IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>();\n  zones.addAll(urbaZoneReader.readAll(zoneColl));\n\n  // Etape 3 : assignement des zonages au PLU\n  env.setUrbaZones(zones);\n\n  logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\");\n  // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures\n  IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader\n      .assignBordureToParcelleWithOrientation(parcelleColl);\n  env.setCadastralParcels(parcelles);\n\n  // Etape 5 : import des sous parcelles\n  logger.info(\"Loading SubParcels...\");\n  {\n    IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>();\n    SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones);\n    for (CadastralParcel cadastralParcel : parcelles) {\n      sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel));\n    }\n    env.setSubParcels(sousParcelles);\n  }\n\n  // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es\n  logger.info(\"Loading BasicPropertyUnits...\");\n  BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles);\n  IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits();\n  env.setBpU(collBPU);\n\n  // Etape 7 : import des b\u00e2timents\n  logger.info(\"Loading Buildings...\");\n  BuildingReader buildingReader = new BuildingReader();\n  Collection<Building> buildings = buildingReader.readAll(batiColl);\n  env.getBuildings().addAll(buildings);\n\n  // Etape 7.1 : assignation des batiments aux BpU\n  logger.info(\"Assigning building to SubParcels...\");\n  AssignBuildingPartToSubParcel.assign(buildings, collBPU);\n\n  // Etape 8 : chargement des voiries\n  logger.info(\"Loading Roads...\");\n  RoadReader roadReader = new RoadReader();\n  IFeatureCollection<Road> roads = new FT_FeatureCollection<>();\n  roads.addAll(roadReader.readAll(voirieColl));\n  env.setRoads(roads);\n\n  // Etape 9 : on affecte les liens entres une bordure et ses objets\n  // adjacents (bordure sur route => route + relation entre les limites de\n  // parcelles)\n  logger.info(\"Assigning Roads to ParcelBoundaries...\");\n  AssignRoadToParcelBoundary.process(parcelles, roads);\n\n  // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es\n  logger.info(\"Assigning opposite boundaries to parcel boundaries...\");\n  AssignOppositeToBoundary.process(parcelles);\n\n  // Etape 11 : on importe les alignements\n  logger.info(\"Loading Prescriptions...\");\n  {\n    PrescriptionReader prescriptionReader = new PrescriptionReader();\n    Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions);\n    env.getPrescriptions().addAll(prescriptionsRead);\n  }\n\n  logger.info(\"Assign Z to features...\");\n  // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles,\n  // sous-parcelles route sans z, zonage, les bordures etc...\n  env.setTerrain(dtm);\n  try {\n    AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED);\n    AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED);\n    AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED);\n    AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED);\n    AssignZ.toZone(env.getUrbaZones(), dtm, false);\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n\n  logger.info(\"Loading complete\");\n\n  return env;\n}\n\n\n\n\nDans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).",
            "title": "Integration"
        },
        {
            "location": "/envgeo/integration/#processus-dintegration",
            "text": "Un processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe  Environnement  en renseignant un certain nombre d'attributs.  Le processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe  fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP  du d\u00e9pot  SimPLU3D-rules )  ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe  fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS , m\u00eame d\u00e9pot). Quel que soit l'approche choisie, les deux classes ont une m\u00e9thode  load , qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de  IFeature  de GeOxygene et faire appelle \u00e0 la m\u00e9thode  load  de la classe  fr.ign.cogit.simplu3d.io.LoadFromCollection  qui va instancier les entit\u00e9s du mod\u00e8le.  Dans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en  fonction de la source de donn\u00e9es utilis\u00e9e , puis d\u00e9crire dans le d\u00e9tail  le processus d'int\u00e9gration .     Attention : actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen direct d'instancier le mod\u00e8le g\u00e9ographique convenablement.",
            "title": "Processus d'int\u00e9gration"
        },
        {
            "location": "/envgeo/integration/#sources-de-donnees-utilisees",
            "text": "La donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es  d\u00e9pendent du choix de la source de donn\u00e9es   ShapeFiles  ou  PostGIS . Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires.  Cependant,  les noms des attributs utilis\u00e9s  sont les m\u00eames quelle que soit la source utilis\u00e9e et sont stock\u00e9s au m\u00eame endroit dans le code.",
            "title": "Sources de donn\u00e9es utilis\u00e9es"
        },
        {
            "location": "/envgeo/integration/#source-de-donnees-shapefile",
            "text": "La classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP.     Source de donn\u00e9es  Nom de la variable  Valeur par d\u00e9faut  Type de g\u00e9om\u00e9trie      Document d'Urbanisme  NOM_FICHIER_PLU  doc_urba.shp  Non utilis\u00e9e    Zonage r\u00e9glementaire  NOM_FICHIER_ZONAGE  zone_urba.shp  (Multi-) Polygone 2D (sans intersection)    Parcelles  NOM_FICHIER_PARCELLE  parcelle.shp  Polygone 2D (sans intersection)    B\u00e2timents  NOM_FICHIER_BATIMENTS  batiment.shp  Multi-Polygone 3D    Route  NOM_FICHIER_VOIRIE  route.shp  (Multi-) Lin\u00e9aire 2D ou 3D    MNT  NOM_FICHIER_TERRAIN  mnt.asc  MNT grille maill\u00e9    Prescriptions ponctuelles  NOM_FICHIER_PRESC_PONCTUELLE  prescription_pct.shp  (Multi -) Ponctuelle 2D    Prescriptions lin\u00e9aires  NOM_FICHIER_PRESC_LINEAIRE  prescription_lin.shp  (Multi-) Lin\u00e9aire 2D    Prescriptions surfaciques  NOM_FICHIER_PRESC_SURFACIQUE  prescription_surf.shp  (Multi-) Surfacique 2D",
            "title": "Source de donn\u00e9es ShapeFile"
        },
        {
            "location": "/envgeo/integration/#source-de-donnees-postgis",
            "text": "La classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tables est  fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS . Le MNT est stock\u00e9 comme un raster dans PostGIS.     Source de donn\u00e9es  Nom de la variable  Valeur par d\u00e9faut  Type de g\u00e9om\u00e9trie      Document d'Urbanisme  NOM_TABLE_PLU  plu  Non utilis\u00e9es    Zonage r\u00e9glementaire  NOM_TABLE_ZONAGE  zonage  (Multi-) Polygone 2D (sans intersection)    Parcelles  NOM_FICHIER_PARCELLE  parcelle  Polygones 2D (sans intersection)    B\u00e2timents  NOM_TABLE_BATIMENTS  batiment  Multi-Polygone 3D    Route  NOM_TABLE_VOIRIE  route  (Multi-) Lin\u00e9aire 2D ou 3D    MNT  NOM_FICHIER_TERRAIN  mnt  MNT grille maill\u00e9    Prescriptions ponctuelles  NOM_TABLE_PRESC_PCT  prescriptionpct  (Multi -) Ponctuelle 2D    Prescriptions lin\u00e9aires  NOM_TABLE_PRESC_LINEAIRE  prescriptionlin  (Multi-) Lin\u00e9aire 2D    Prescriptions surfaciques  NOM_TABLE_PRESC_SURF  prescriptionsurf  (Multi-) Surfacique 2D",
            "title": "Source de donn\u00e9es PostGIS"
        },
        {
            "location": "/envgeo/integration/#nom-des-attributs",
            "text": "Pour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe :  fr.ign.cogit.simplu3d.io.feature.AttribNames .",
            "title": "Nom des attributs"
        },
        {
            "location": "/envgeo/integration/#document-durbanisme",
            "text": "Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme.     Attribut  Nom de la variable  Valeur par d\u00e9faut  Type      Identifiant  ATT_ID_URBA  IDURBA  String    Type de document  ATT_TYPE_DOC  TYPEDOC  String    Date Approbation  ATT_DATE_APPRO  DATAPPRO  Date (yyyyMMdd)    Date Fin  ATT_DATE_FIN  DATEFIN  Date (yyyyMMdd)    Intercommunalit\u00e9  ATT_INTER_CO  INTERCO  String    Num\u00e9ro SIREN  ATT_SIREN  SIREN  String    \u00c9tat du document  ATT_ETAT  ETAT  String    Nom de la r\u00e9gion  ATT_NOM_REG  NOMREG  String    URL de la r\u00e9gion  ATT_URL_REG  URLREG  String    Nom du plan  ATT_NOM_PLAN  NOMPLAN  String    URL du plan  ATT_URL_PLAN  URLPLAN  String    Site web  ATT_SITE_WEB  SITEWEB  String    Type ref  ATT_TYPE_REF  TYPEREF  String    Date de r\u00e9f\u00e9rence  ATT_DATE_REF  DATEREF  Date (yyyy)",
            "title": "Document d'urbanisme"
        },
        {
            "location": "/envgeo/integration/#zonage-reglementaire",
            "text": "Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme.     Attribut  Nom de la variable  Valeur par d\u00e9faut  Type      Libell\u00e9  ATT_LIBELLE  LIBELLE  String    Libell\u00e9 long  ATT_LIBELONG  LIBELONG  String    Type de zone  ATT_TYPE_ZONE  TYPEZONE  String    Destination dominante  ATT_DESTDOMI  DESTDOMI  String    Nom de fichier associ\u00e9  ATT_NOMFIC  NOMFIC  String    URL du fichier associ\u00e9  ATT_URLFIC  URLFIC  String    INSEE  ATT_INSEE  INSEE  String    Date d'approbation  VALIDITY_DATE_APPRO  DATAPPRO  Date (yyyyMMdd)    Date de validation  VALIDITY_DATE_VALID  DATVALID  Date (yyyyMMdd)    Commentaires \u00e9ventuels  ATT_TEXT  TEXT  String",
            "title": "Zonage r\u00e9glementaire"
        },
        {
            "location": "/envgeo/integration/#parcelles",
            "text": "Chaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut  ATT_CODE_PARC  ou est construit par la concat\u00e9nation des attributs valeurs des  ATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO  et accessible par la m\u00e9thode  getCode  de la classe * fr.ign.cogit.simplu3d.model.CadastralParcel*.  L'attribut  ATT_HAS_TO_BE_SIMULATED  est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false).     Attribut  Nom de la variable  Valeur par d\u00e9faut  Type      Identifiant de la parcelle  ATT_CODE_PARC  CODE  String    Code du d\u00e9partement  ATT_BDP_CODE_DEP  CODE_DEP  String    Code de la commune  ATT_BDP_CODE_COM  CODE_COM  String    Compl\u00e9ment pour code INSEE  ATT_BDP_COM_ABS  COM_ABS  String    Section cadastrale  ATT_BDP_SECTION  SECTION  String    Num\u00e9ro de parcelle  ATT_BDP_NUMERO  NUMERO  String    Indique si la parcelle doit \u00eatre simul\u00e9e  ATT_HAS_TO_BE_SIMULATED  SIMUL  Boolean, Integer, String",
            "title": "Parcelles"
        },
        {
            "location": "/envgeo/integration/#batiments",
            "text": "Pas d'attribut utilis\u00e9.",
            "title": "B\u00e2timents"
        },
        {
            "location": "/envgeo/integration/#route",
            "text": "Attribut  Nom de la variable  Valeur par d\u00e9faut  Type      Nom de la rue  ATT_NOM_RUE  NOM_RUE_G  String    Largeur en m  ATT_LARGEUR  LARGEUR  Double    Type de la rue  ATT_TYPE_ROAD  NATURE  String",
            "title": "Route"
        },
        {
            "location": "/envgeo/integration/#mnt",
            "text": "Pas d'attribut utilis\u00e9.",
            "title": "MNT"
        },
        {
            "location": "/envgeo/integration/#prescriptions-ponctuelles-lineaires-et-surfaciques",
            "text": "Attribut  Nom de la variable  Valeur par d\u00e9faut  Type      Type de prescription  ATT_TYPE_PRESCRIPTION  TYPEPSC  String    Libell\u00e9 de la prescription  ATT_LABEL  LIBELLE  Double    Valeur de recul  ATT_RECOIL  RECOIL  String",
            "title": "Prescriptions ponctuelles, lin\u00e9aires et surfaciques"
        },
        {
            "location": "/envgeo/integration/#code-dintegration",
            "text": "Le code d'int\u00e9gration se trouve ci-dessous, il est compos\u00e9 de 12 \u00e9tapes.   Cr\u00e9ation de l'objet PLU  Cr\u00e9ation des zones et assignation des r\u00e8gles aux zones  Assignement des zonages au PLU  Chargement des parcelles et cr\u00e9ations des bordures  Import des sous parcelles  Cr\u00e9ation des unit\u00e9s foncir\u00e8es  Import des b\u00e2timents\n    7.1 Assignation des batiments aux BpU  Chargement des voiries  Affectation des liens entre une bordure et ses objets adjacents (bordure sur route => route + relation entre les limites de parcelles)  D\u00e9tection des limites s\u00e9paratives oppos\u00e9es  Import des alignements  Affectation de la coordonn\u00e9es Z \u00e0 l'ensemble des \u00e9l\u00e9ments    Quelques \u00e9tapes sont param\u00e9trables :  La premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible d'activer la transformation avec le boolean  Environnement.TRANSLATE_TO_ZERO  et en assignant des coordonn\u00e9es (classe  DirectPosition  de GeOxygene) \u00e0 l'attribut statique  Environnement.dpTranslate .  Pendant l'\u00e9tape d'annotation des limites s\u00e9paratives en limites de fond, lat\u00e9rales et de voirie (\u00e9tape\n  4), le processus d\u00e9termine automatiquement ces types suivant une \u00e9valuation du d\u00e9passement de la limite s\u00e9parative par rapport au point d'intersection avec la voirie (cf image suivante). Par d\u00e9faut, la valeur de d\u00e9passement jusqu'\u00e0 laquelle les limites sont affect\u00e9es comme lat\u00e9rales est de 3 m, mais elle peut \u00eatre fix\u00e9e en modifiant la valeur   AbstractBoundaryAnalyzer.setThresholdIni(double) . Pour les parcelles plus petites, le seuil est automatiquement ajust\u00e9 pour atteindre 1/3 de la largeur de la bo\u00eete englobante orient\u00e9e.  Pour une parcelle n'ayant pas d'acc\u00e8s \u00e0 la voirie, toutes les limites sont de type \"Fond\". Le c\u00f4t\u00e9 (GAUCHE ou DROITE) des limites lat\u00e9rales est d\u00e9termin\u00e9e en regardant la parcelle depuis la voirie. Si une parcelle donne sur plusieurs voiries, les c\u00f4t\u00e9s DROITE et GAUCHE sont d\u00e9termin\u00e9s al\u00e9atoirement.   Pour les \u00e9tapes qui recherchent des objets \u00e0 proximit\u00e9 des limites s\u00e9paratives comme les \u00e9tapes 9 et 10, il est possible de fixer la distance maximale de recherche en fixant les valeurs :  NearestRoadFinder.setMaximumDistance()  pour la recherche de la voirie la plus proche d'une limite cadastrale et   OppositeBoundaryFinder.setMaximalValue()  pour la recherche de la limite oppos\u00e9e \u00e0 une limite cadastrale.  Afin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D  parcelles, prescriptions, zonages et \u00e9ventuellement voiries (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe  fr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ . Deux types de transformation sont possibles :\n- Si le MNT est d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ;\n- S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut).  public static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl,\n    IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl,\n    IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions,\n    AbstractDTM dtm, Environnement env) throws Exception {\n\n  // Etape 0 : doit on translater tous les objets ?\n\n  if (Environnement.TRANSLATE_TO_ZERO) {\n    Environnement.dpTranslate = zoneColl.envelope().center();\n    for (IFeature feat : zoneColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : parcelleColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : voirieColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : batiColl) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n    for (IFeature feat : prescriptions) {\n      feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(),\n          -Environnement.dpTranslate.getY(), 0));\n    }\n  }\n\n  // Etape 1 : cr\u00e9ation de l'objet PLU\n  logger.info(\"Read UrbaDocument...\");\n  UrbaDocument plu;\n  if (featPLU == null) {\n    plu = new UrbaDocument();\n  } else {\n    UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader();\n    plu = urbaDocumentReader.read(featPLU);\n  }\n  env.setUrbaDocument(plu);\n\n  // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones\n  logger.info(\"Loading UrbaZone...\");\n  UrbaZoneReader urbaZoneReader = new UrbaZoneReader();\n  IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>();\n  zones.addAll(urbaZoneReader.readAll(zoneColl));\n\n  // Etape 3 : assignement des zonages au PLU\n  env.setUrbaZones(zones);\n\n  logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\");\n  // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures\n  IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader\n      .assignBordureToParcelleWithOrientation(parcelleColl);\n  env.setCadastralParcels(parcelles);\n\n  // Etape 5 : import des sous parcelles\n  logger.info(\"Loading SubParcels...\");\n  {\n    IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>();\n    SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones);\n    for (CadastralParcel cadastralParcel : parcelles) {\n      sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel));\n    }\n    env.setSubParcels(sousParcelles);\n  }\n\n  // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es\n  logger.info(\"Loading BasicPropertyUnits...\");\n  BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles);\n  IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits();\n  env.setBpU(collBPU);\n\n  // Etape 7 : import des b\u00e2timents\n  logger.info(\"Loading Buildings...\");\n  BuildingReader buildingReader = new BuildingReader();\n  Collection<Building> buildings = buildingReader.readAll(batiColl);\n  env.getBuildings().addAll(buildings);\n\n  // Etape 7.1 : assignation des batiments aux BpU\n  logger.info(\"Assigning building to SubParcels...\");\n  AssignBuildingPartToSubParcel.assign(buildings, collBPU);\n\n  // Etape 8 : chargement des voiries\n  logger.info(\"Loading Roads...\");\n  RoadReader roadReader = new RoadReader();\n  IFeatureCollection<Road> roads = new FT_FeatureCollection<>();\n  roads.addAll(roadReader.readAll(voirieColl));\n  env.setRoads(roads);\n\n  // Etape 9 : on affecte les liens entres une bordure et ses objets\n  // adjacents (bordure sur route => route + relation entre les limites de\n  // parcelles)\n  logger.info(\"Assigning Roads to ParcelBoundaries...\");\n  AssignRoadToParcelBoundary.process(parcelles, roads);\n\n  // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es\n  logger.info(\"Assigning opposite boundaries to parcel boundaries...\");\n  AssignOppositeToBoundary.process(parcelles);\n\n  // Etape 11 : on importe les alignements\n  logger.info(\"Loading Prescriptions...\");\n  {\n    PrescriptionReader prescriptionReader = new PrescriptionReader();\n    Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions);\n    env.getPrescriptions().addAll(prescriptionsRead);\n  }\n\n  logger.info(\"Assign Z to features...\");\n  // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles,\n  // sous-parcelles route sans z, zonage, les bordures etc...\n  env.setTerrain(dtm);\n  try {\n    AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED);\n    AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED);\n    AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED);\n    AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED);\n    AssignZ.toZone(env.getUrbaZones(), dtm, false);\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n\n  logger.info(\"Loading complete\");\n\n  return env;\n}  Dans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).",
            "title": "Code d'int\u00e9gration"
        },
        {
            "location": "/envgeo/intro/",
            "text": "Introduction \u00e0 l'environnement g\u00e9ographique\n\uf0c1\n\n\nL'environnement g\u00e9ographique de SimPLU3D permet de d\u00e9crire l'ensemble des objets g\u00e9ographiques n\u00e9cessaires \u00e0 la g\u00e9n\u00e9ration de formes b\u00e2ties et notamment \u00e0 la v\u00e9rification des contraintes morphologiques. Ces objets g\u00e9ographiques peuvent concerner d'autres objets de la ville qui seront utilis\u00e9s pour v\u00e9rifier le respect des contraintes morphologiques (Par exemple, les routes,les limites s\u00e9paratives des parcelles, etc.) ou en lien avec l'application de r\u00e8glements d'urbanisme d'un territoire (Par exemple, les plans de zonage ou les servitudes d'utilit\u00e9 publique).\n\n\nL'ensemble des codes g\u00e9rant cet aspect se trouve dans le d\u00e9p\u00f4t \nSimPLU3D-rules\n dont la javadoc est consultable en ligne : \nhttps://SimPLU3D.github.io/simplu3D-rules\n. Il contient :\n\n\n\n\nun mod\u00e8le g\u00e9ographique\n ;\n\n\ndes \nm\u00e9thodes automatiques d'int\u00e9gration\n, pour renseigner automatiquement les classes, les attributs et les relations n\u00e9cessaires au mod\u00e8le \u00e0 partir de donn\u00e9es g\u00e9ographiques usuelles \u00e0 partir de sources de donn\u00e9es ShapeFile ou PostGIS ;\n\n\nun \nexporteur\n pour visualiser dans un SIG les \u00e9l\u00e9ments cr\u00e9\u00e9s.",
            "title": "Intro"
        },
        {
            "location": "/envgeo/intro/#introduction-a-lenvironnement-geographique",
            "text": "L'environnement g\u00e9ographique de SimPLU3D permet de d\u00e9crire l'ensemble des objets g\u00e9ographiques n\u00e9cessaires \u00e0 la g\u00e9n\u00e9ration de formes b\u00e2ties et notamment \u00e0 la v\u00e9rification des contraintes morphologiques. Ces objets g\u00e9ographiques peuvent concerner d'autres objets de la ville qui seront utilis\u00e9s pour v\u00e9rifier le respect des contraintes morphologiques (Par exemple, les routes,les limites s\u00e9paratives des parcelles, etc.) ou en lien avec l'application de r\u00e8glements d'urbanisme d'un territoire (Par exemple, les plans de zonage ou les servitudes d'utilit\u00e9 publique).  L'ensemble des codes g\u00e9rant cet aspect se trouve dans le d\u00e9p\u00f4t  SimPLU3D-rules  dont la javadoc est consultable en ligne :  https://SimPLU3D.github.io/simplu3D-rules . Il contient :   un mod\u00e8le g\u00e9ographique  ;  des  m\u00e9thodes automatiques d'int\u00e9gration , pour renseigner automatiquement les classes, les attributs et les relations n\u00e9cessaires au mod\u00e8le \u00e0 partir de donn\u00e9es g\u00e9ographiques usuelles \u00e0 partir de sources de donn\u00e9es ShapeFile ou PostGIS ;  un  exporteur  pour visualiser dans un SIG les \u00e9l\u00e9ments cr\u00e9\u00e9s.",
            "title": "Introduction \u00e0 l'environnement g\u00e9ographique"
        },
        {
            "location": "/envgeo/modelgeo/",
            "text": "Mod\u00e8le g\u00e9ographique d\u00e9taill\u00e9\n\uf0c1\n\n\nLe mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels il est possible de d\u00e9finir des contraintes morphologiques et notamment de d\u00e9crire une r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des \nPlans Locaux d'Urbanisme\n. Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents. Ce mod\u00e8le a \u00e9t\u00e9 produit \u00e0 partir de la lecture de plusieurs PLU et des \nfiches m\u00e9thodologiques d'\u00e9criture des PLU du GRIDAUH\n. Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante :\n\n\n\n\nle mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non la r\u00e8gle form\u00e9e par cette phrase. La prise en compte de telles contraintes est d\u00e9crite dans la section \nd\u00e9finition de contraintes morphologiques\n.\n\n\nPour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique :\n\n\n\n\nBrasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, \ndoi:10.3390/ijgi5020014\n\n\n\n\nVue global du mod\u00e8le\n\uf0c1\n\n\nLe mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package \nfr.ign.cogit.simplu3d.model\n du projet \nSimPLU3D-rules\n. La javadoc est \nconsultable en ligne\n. Vous pouvez cliquer sur les diff\u00e9rents sch\u00e9mas UML pr\u00e9sent\u00e9s dans cette section afin de les consulter en pleine r\u00e9solution.\n\n\n\n\nLa figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es :\n\n\n\n\nles classes repr\u00e9sentant la r\u00e9glementation\n, c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ;\n\n\nles classes mod\u00e9lisant le parcellaire\n ;\n\n\nles classes concernant la mod\u00e9lisation 3D des b\u00e2timents\n ;\n\n\nles classes concernant les espaces publiques\n.\n\n\n\n\nAvant de pr\u00e9senter les classes, la classe \nparent \nEnvironnement\n sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le.\n\n\nLe mod\u00e8le est certes complexe dans l'absolu, n\u00e9anmoins il n'est pas n\u00e9cessaire (comme pr\u00e9sent\u00e9 dans l'\nexemple de la simulation basique\n) de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une \nautre page\n.\n\n\nLes diagrammes de classes sont g\u00e9n\u00e9r\u00e9s avec le plugin \nObjectAID d'Eclipse\n et les fichiers sont disponibles dans le dossier \ndiagram\n de SimPLU3D-rules\n.\n\n\nClasse Environnement\n\uf0c1\n\n\nLa classe \nEnvironnement\n est une classe centrale dans le mod\u00e8le de SimPLU3D car elle est le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques.\n\n\n\n\nElle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et s'il est d\u00e9fini au terrain qui servira de r\u00e9f\u00e9rence d'altitudes pour les donn\u00e9es n'ayant pas de g\u00e9om\u00e9trie 3D.\n\n\nL'instanciation d'un environnement s'effectue :\n\n\n\n\nsoit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur \nles processus d'int\u00e9gration\n) ;\n\n\nsoit par le biais de la m\u00e9thode statique \nEnvironnement.createEnvironnement()\n qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide.\n\n\n\n\nDans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique \nEnvironnement.getInstance()\n.\n\n\nL'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. L'attribut statique \nTRANSLATE_TO_ZERO\n indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et \ndpTranslate\n la valeur de cette translation.\n\n\nClasses de r\u00e9glementation\n\uf0c1\n\n\nLes classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent et \u00e0 quels endroits. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS concernant la d\u00e9mat\u00e9rialisation des documents d'urbanisme. Cette norme vise \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce standard (\ndisponible en ligne\n). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9s dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas pour les attributs purement informatifs et qui n'ont, a priori, pas d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire.\n\n\n\n\nLa classe \nUrbaDocument\n est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration \nUrbaDocumentType\n comme les valeurs POS, PLU, etc. . La classe  \nUrbaDocument\n poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode \ngetGeom()\n). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque \nUrbaZone\n et accessibles \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface \nIZoneRegulation\n). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone (voir\nl'exemple sur les formats de r\u00e8gles\n). Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie (\ngetUrbaZone()\n) et un convertisseur en texte pour consulter les informations contenues (\ntoText()\n).\n\n\nLa classe \nPrescription\n vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, lin\u00e9aire ou surfacique  et a un type qui est d\u00e9fini \u00e0 travers l'\u00e9num\u00e9ration \nPrescriptionType\n. Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans cette norme.\n\n\nClasses du parcellaire\n\uf0c1\n\n\n\n\nCes classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image, on trouve les diff\u00e9rentes relations d'inclusion entre \nBasicPropertyUnit\n, \nCadastralParcel\n et \nSubParcel\n) les diff\u00e9rentes relations entre les parcelles, leurs limites s\u00e9paratives (\nParcelBoundary\n) et les objets environnants.\n\n\n\n\nLes unit\u00e9s fonci\u00e8res (classe \nBasicPropertyUnit\n) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re. Elles regroupent un ensemble de parcelles cadastrales (classe \nCadastralParcel\n). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents (\ngetBuildings()\n) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode \ngetPol2D()\n et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode \ngenerateGeom()\n.\n\n\nLes parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles (\nSubParcel\n). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 (\nUrbaZone\n). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode (\ngetCode()\n) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode \nhasToBeSimulated()\n). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets (\nParcelBoundary\n) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode \ngetBoundaries()\n) ou de les filtrer en fonction de leurs attributs (m\u00e9thode \ngetBoundariesByType()\n ou \ngetBoundariesBySide()\n). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode \ngetGeom()\n.\n\n\nLes sous-parcelles (classe \nSubParcel\n) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe \nUrbaZone\n). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode \ngetUrbaZone()\n. Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode (\ngetBoundaries()\n).  La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode \ngetGeom()\n.\n\n\nLes limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par \ngetGeom()\n). Ils mod\u00e9lisent les limites des parcelles ou des sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration \nParcelBoundaryType\n et accessible par la m\u00e9thode \ngetType()\n) :\n\n\n\n\nBOT\n : pour les limites de fond de parcelle ;\n\n\nLAT\n :  pour les limites lat\u00e9rales parcelle ;\n\n\nUNKNOWN\n : pour les limites dont on ne conna\u00eet pas le type ;\n\n\nINTRA\n : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ;\n\n\nROAD\n : pour les limites donnant sur une route (\ncf les classes concernant les espaces publiques\n) ;\n\n\nPUB\n : pour les limites donnant sur l'espace publique  (\ncf les classes concernant les espaces publiques\n).\n\n\n\n\nLes limites de type \nLAT\n ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration \nParcelBoundarySide\n et accessible par la m\u00e9thode \ngetSide()\n) qui peut prendre les valeur \nRIGHT\n ou \nLEFT\n pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche.\n\n\nLes limites permettent d'acc\u00e9der aux objets topologiquement voisins comme  une route (\ngetRoad()\n), un espace public (\ngetPublicSpace()\n) ou une parcelle (\ngetCadastralParcel()\n). Les deux premiers objets ne sont acessibles que pour les limites de type \nROAD\n ou \nPUB\n et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode \ngetFeatAdj()\n mais n\u00e9cessite de caster l'objet en sortie.\n\n\nLa m\u00e9thode \ngetOppositeBoundary()\n permet d'obtenir pour les limites de type \nROAD\n ou \nPUB\n, si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle.\n\n\nClasses des b\u00e2timents\n\uf0c1\n\n\nLes classes mod\u00e9lisant les b\u00e2timents sont issues du standard \nCityGML V2.0\n.\n\n\n\n\nIl y a deux classes de b\u00e2timents : les b\u00e2timents (classe \nBuilding\n) et les parties de b\u00e2timents (classe \nBuildingPart\n) qui instancient toutes les deux la classe abstraite \nAbstractBuilding\n. Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D  et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode \ngetBPU()\n). Ces b\u00e2timents sont d\u00e9coup\u00e9s en parties de b\u00e2timent en fonction des sous-parcelles (accessibles avec la m\u00e9thode \ngetSubParcel()\n).  \n\n\nLa plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite \nAbstractBuilding\n, parmi celles-ci les plus importantes pour un usage de SimPLU3D sont :\n\n\n\n\nisNew()\n : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ;\n\n\ngetLOD2MultiSurface()\n : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ;\n\n\ngetBuildingParts()\n : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ;\n\n\ngetDestination()\n : renvoie le type du b\u00e2timent ;\n\n\ngetFootPrint()\n : renvoie en 2D l'emprise du b\u00e2timent.\n\n\n\n\n\n\nDeux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes :\n\n\n\n\nprospect(IGeometry geom, double slope, double hIni)\n : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie.\n\n\nheight(int pB, int pH)\n : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas.\n\n\nValeurs de point haut :\n\n\n0\n : point en haut du plus haut \u00e9tage du b\u00e2timent ;\n\n\n1\n : point le plus bas du toit ;\n\n\n2\n : point le plus haut du b\u00e2timents.\n\n\n\n\n\n\nValeurs de point bas :\n\n\n0\n : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ;\n\n\n1\n :  point le plus bas de la parcelle ;\n\n\n2\n : point le plus bas du terrain ;\n\n\n3\n :  point le plus haut du terrain.\n\n\n\n\n\n\n\n\nLes b\u00e2timents sont compos\u00e9s d'un objet de toit (classe \nRoofSurface\n) accessible par la m\u00e9thode \ngetRoof()\n et des objets de type surface de murs classe \nWallSurface\n accessibles par la m\u00e9thode \ngetWallSurfaces()\n. L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits.\n\n\n\n\nLe toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode \ngetGutter()\n) en vert dans l'image, des ar\u00eates de pignons (\ngetGable()\n) en orange dans l'image et des ar\u00eates sommets (\ngetRoofing()\n) en bordeau sur l'image. Des angles minimaux (m\u00e9thode \ngetAngleMin()\n) et maximaux (m\u00e9thode \ngetAngleMax()\n) sont \u00e9galement disponibles.\n\n\nConcernant les surfaces de mur, chaque objet de la classe \nWallSurface\n repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration \nWallSurfaceType\n) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode \nisWindowLess()\n).\n\n\nCes deux types de surface poss\u00e8dent des mat\u00e9riaux (classe \nMateriau\n) qui ont un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuels placage de textures.\n\n\nClasses de l'espace publique\n\uf0c1\n\n\n\n\nCes classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les formes b\u00e2ties simul\u00e9es. Ces objets sont accessibles via les limites s\u00e9paratives (classe \nParcelBoundary\n).\n\n\nLa classe \nPublicSpace\n repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode \ngetType()\n).\n\n\nLes routes (classe \nRoad\n) ont quelques informations attributaires classiques comme un nom (m\u00e9thode \ngetName()\n), une largeur (m\u00e9thode \ngetWidth()\n) et une liste d'usages (m\u00e9thode \ngetUsages()\n). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe (\ngetAxis()\n) ou par une surface (\ngetGeom()\n).",
            "title": "Modelgeo"
        },
        {
            "location": "/envgeo/modelgeo/#modele-geographique-detaille",
            "text": "Le mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels il est possible de d\u00e9finir des contraintes morphologiques et notamment de d\u00e9crire une r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des  Plans Locaux d'Urbanisme . Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents. Ce mod\u00e8le a \u00e9t\u00e9 produit \u00e0 partir de la lecture de plusieurs PLU et des  fiches m\u00e9thodologiques d'\u00e9criture des PLU du GRIDAUH . Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante :   le mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non la r\u00e8gle form\u00e9e par cette phrase. La prise en compte de telles contraintes est d\u00e9crite dans la section  d\u00e9finition de contraintes morphologiques .  Pour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique :   Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14,  doi:10.3390/ijgi5020014",
            "title": "Mod\u00e8le g\u00e9ographique d\u00e9taill\u00e9"
        },
        {
            "location": "/envgeo/modelgeo/#vue-global-du-modele",
            "text": "Le mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package  fr.ign.cogit.simplu3d.model  du projet  SimPLU3D-rules . La javadoc est  consultable en ligne . Vous pouvez cliquer sur les diff\u00e9rents sch\u00e9mas UML pr\u00e9sent\u00e9s dans cette section afin de les consulter en pleine r\u00e9solution.   La figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es :   les classes repr\u00e9sentant la r\u00e9glementation , c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ;  les classes mod\u00e9lisant le parcellaire  ;  les classes concernant la mod\u00e9lisation 3D des b\u00e2timents  ;  les classes concernant les espaces publiques .   Avant de pr\u00e9senter les classes, la classe  parent  Environnement  sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le.  Le mod\u00e8le est certes complexe dans l'absolu, n\u00e9anmoins il n'est pas n\u00e9cessaire (comme pr\u00e9sent\u00e9 dans l' exemple de la simulation basique ) de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une  autre page .  Les diagrammes de classes sont g\u00e9n\u00e9r\u00e9s avec le plugin  ObjectAID d'Eclipse  et les fichiers sont disponibles dans le dossier  diagram  de SimPLU3D-rules .",
            "title": "Vue global du mod\u00e8le"
        },
        {
            "location": "/envgeo/modelgeo/#classe-environnement",
            "text": "La classe  Environnement  est une classe centrale dans le mod\u00e8le de SimPLU3D car elle est le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques.   Elle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et s'il est d\u00e9fini au terrain qui servira de r\u00e9f\u00e9rence d'altitudes pour les donn\u00e9es n'ayant pas de g\u00e9om\u00e9trie 3D.  L'instanciation d'un environnement s'effectue :   soit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur  les processus d'int\u00e9gration ) ;  soit par le biais de la m\u00e9thode statique  Environnement.createEnvironnement()  qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide.   Dans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique  Environnement.getInstance() .  L'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. L'attribut statique  TRANSLATE_TO_ZERO  indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et  dpTranslate  la valeur de cette translation.",
            "title": "Classe Environnement"
        },
        {
            "location": "/envgeo/modelgeo/#classes-de-reglementation",
            "text": "Les classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent et \u00e0 quels endroits. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS concernant la d\u00e9mat\u00e9rialisation des documents d'urbanisme. Cette norme vise \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce standard ( disponible en ligne ). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9s dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas pour les attributs purement informatifs et qui n'ont, a priori, pas d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire.   La classe  UrbaDocument  est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration  UrbaDocumentType  comme les valeurs POS, PLU, etc. . La classe   UrbaDocument  poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode  getGeom() ). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque  UrbaZone  et accessibles \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface  IZoneRegulation ). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone (voir l'exemple sur les formats de r\u00e8gles ). Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie ( getUrbaZone() ) et un convertisseur en texte pour consulter les informations contenues ( toText() ).  La classe  Prescription  vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, lin\u00e9aire ou surfacique  et a un type qui est d\u00e9fini \u00e0 travers l'\u00e9num\u00e9ration  PrescriptionType . Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans cette norme.",
            "title": "Classes de r\u00e9glementation"
        },
        {
            "location": "/envgeo/modelgeo/#classes-du-parcellaire",
            "text": "Ces classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image, on trouve les diff\u00e9rentes relations d'inclusion entre  BasicPropertyUnit ,  CadastralParcel  et  SubParcel ) les diff\u00e9rentes relations entre les parcelles, leurs limites s\u00e9paratives ( ParcelBoundary ) et les objets environnants.   Les unit\u00e9s fonci\u00e8res (classe  BasicPropertyUnit ) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re. Elles regroupent un ensemble de parcelles cadastrales (classe  CadastralParcel ). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents ( getBuildings() ) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode  getPol2D()  et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode  generateGeom() .  Les parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles ( SubParcel ). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 ( UrbaZone ). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode ( getCode() ) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode  hasToBeSimulated() ). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets ( ParcelBoundary ) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode  getBoundaries() ) ou de les filtrer en fonction de leurs attributs (m\u00e9thode  getBoundariesByType()  ou  getBoundariesBySide() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode  getGeom() .  Les sous-parcelles (classe  SubParcel ) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe  UrbaZone ). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode  getUrbaZone() . Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode ( getBoundaries() ).  La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode  getGeom() .  Les limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par  getGeom() ). Ils mod\u00e9lisent les limites des parcelles ou des sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration  ParcelBoundaryType  et accessible par la m\u00e9thode  getType() ) :   BOT  : pour les limites de fond de parcelle ;  LAT  :  pour les limites lat\u00e9rales parcelle ;  UNKNOWN  : pour les limites dont on ne conna\u00eet pas le type ;  INTRA  : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ;  ROAD  : pour les limites donnant sur une route ( cf les classes concernant les espaces publiques ) ;  PUB  : pour les limites donnant sur l'espace publique  ( cf les classes concernant les espaces publiques ).   Les limites de type  LAT  ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration  ParcelBoundarySide  et accessible par la m\u00e9thode  getSide() ) qui peut prendre les valeur  RIGHT  ou  LEFT  pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche.  Les limites permettent d'acc\u00e9der aux objets topologiquement voisins comme  une route ( getRoad() ), un espace public ( getPublicSpace() ) ou une parcelle ( getCadastralParcel() ). Les deux premiers objets ne sont acessibles que pour les limites de type  ROAD  ou  PUB  et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode  getFeatAdj()  mais n\u00e9cessite de caster l'objet en sortie.  La m\u00e9thode  getOppositeBoundary()  permet d'obtenir pour les limites de type  ROAD  ou  PUB , si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle.",
            "title": "Classes du parcellaire"
        },
        {
            "location": "/envgeo/modelgeo/#classes-des-batiments",
            "text": "Les classes mod\u00e9lisant les b\u00e2timents sont issues du standard  CityGML V2.0 .   Il y a deux classes de b\u00e2timents : les b\u00e2timents (classe  Building ) et les parties de b\u00e2timents (classe  BuildingPart ) qui instancient toutes les deux la classe abstraite  AbstractBuilding . Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D  et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode  getBPU() ). Ces b\u00e2timents sont d\u00e9coup\u00e9s en parties de b\u00e2timent en fonction des sous-parcelles (accessibles avec la m\u00e9thode  getSubParcel() ).    La plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite  AbstractBuilding , parmi celles-ci les plus importantes pour un usage de SimPLU3D sont :   isNew()  : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ;  getLOD2MultiSurface()  : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ;  getBuildingParts()  : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ;  getDestination()  : renvoie le type du b\u00e2timent ;  getFootPrint()  : renvoie en 2D l'emprise du b\u00e2timent.    Deux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes :   prospect(IGeometry geom, double slope, double hIni)  : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie.  height(int pB, int pH)  : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas.  Valeurs de point haut :  0  : point en haut du plus haut \u00e9tage du b\u00e2timent ;  1  : point le plus bas du toit ;  2  : point le plus haut du b\u00e2timents.    Valeurs de point bas :  0  : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ;  1  :  point le plus bas de la parcelle ;  2  : point le plus bas du terrain ;  3  :  point le plus haut du terrain.     Les b\u00e2timents sont compos\u00e9s d'un objet de toit (classe  RoofSurface ) accessible par la m\u00e9thode  getRoof()  et des objets de type surface de murs classe  WallSurface  accessibles par la m\u00e9thode  getWallSurfaces() . L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits.   Le toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode  getGutter() ) en vert dans l'image, des ar\u00eates de pignons ( getGable() ) en orange dans l'image et des ar\u00eates sommets ( getRoofing() ) en bordeau sur l'image. Des angles minimaux (m\u00e9thode  getAngleMin() ) et maximaux (m\u00e9thode  getAngleMax() ) sont \u00e9galement disponibles.  Concernant les surfaces de mur, chaque objet de la classe  WallSurface  repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration  WallSurfaceType ) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode  isWindowLess() ).  Ces deux types de surface poss\u00e8dent des mat\u00e9riaux (classe  Materiau ) qui ont un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuels placage de textures.",
            "title": "Classes des b\u00e2timents"
        },
        {
            "location": "/envgeo/modelgeo/#classes-de-lespace-publique",
            "text": "Ces classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les formes b\u00e2ties simul\u00e9es. Ces objets sont accessibles via les limites s\u00e9paratives (classe  ParcelBoundary ).  La classe  PublicSpace  repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode  getType() ).  Les routes (classe  Road ) ont quelques informations attributaires classiques comme un nom (m\u00e9thode  getName() ), une largeur (m\u00e9thode  getWidth() ) et une liste d'usages (m\u00e9thode  getUsages() ). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe ( getAxis() ) ou par une surface ( getGeom() ).",
            "title": "Classes de l'espace publique"
        },
        {
            "location": "/generator/custom-generator/",
            "text": "Param\u00e9trer les bo\u00eetes d'une configuration\n\uf0c1\n\n\nDans cette partie, nous d\u00e9crivons comment le syst\u00e8me d\u00e9finit la cr\u00e9ation de nouveaux objets param\u00e9triques et les modifications qui leur seront apport\u00e9es durant l'optimisation. Il s'agit de l'\u00e9tape 1 du code d\u00e9crit dans la section \nprincipe de simulation\n. Cet exemple s'appuie sur la g\u00e9n\u00e9ration de bo\u00eetes, mais il est possible de d\u00e9finir d'autres types de g\u00e9om\u00e9tries (cela sera d\u00e9crit dans la section \nG\u00e9n\u00e9rer d'autres types de formes\n).\n\n\nLes parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans \nla derni\u00e8re partie de la page sur l'impl\u00e9mentation\n (\u00e9tape 1) , c'est \u00e0 dire le code suivant :\n\n\n// Step 1 :\n\n// Sampler creation (definition of the class and of the kernel modifications)\n// Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications)\nSampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p,\nbpu, pred, geom);\n\n\n\n\nD\u00e9finition des formes g\u00e9n\u00e9rables\n\uf0c1\n\n\nPour rappel, le processus d'optimisation vise \u00e0 g\u00e9n\u00e9rer une configuration compos\u00e9e de \nn\n bo\u00eetes chaque bo\u00eete pouvant \u00eatre d\u00e9finie par un vecteur de dimension 6 :\n\n\nb\n = (\nx\n, \ny\n, \nl\n, \nw\n, \nh\n, \n\u03b8\n).\n\n\nAfin de pouvoir \u00e9chantillonner, il est n\u00e9cessaire de d\u00e9finir les intervalles dans lesquels le tirage des bo\u00eetes sera effectu\u00e9 :\n\n\n\n\nxmin\n < \nx\n < \nxmax\n\n\nymin\n < \ny\n < \nymax\n\n\nmin\u03b8\n < \n\u03b8\n < \nmax\u03b8\n\n\nminwid\n < \nw\n < \nmaxwid\n\n\nminlen\n < \nl\n < \nmaxlen\n\n\nminheight\n < \nh\n < \nmaxheight\n\n\n\n\nLes deux premi\u00e8res valeurs sont contraintes par l'enveloppe contenant la g\u00e9om\u00e9trie dans laquelle les centres de bo\u00eetes seront \u00e9chantillonn\u00e9s.\n\n\nDans l'exemple de la \npremi\u00e8re simulation\n, \nmin\u03b8\n et \nmax\u03b8\n sont fix\u00e9s  \u00e0 \n0\n et \n\u03c0\n afin de permettre tout type d'orientation. Les autres param\u00e8tres sont fix\u00e9s dans le fichier de configuration \nparams.json\n.\n\n\nAfin que le syst\u00e8me puisse g\u00e9n\u00e9rer des formes, il est n\u00e9cessaire de d\u00e9finir une classe \nBuilder\n qui permet d'instancier les objets \u00e0 partir d'un tableau contenant les param\u00e8tres de la forme. Dans l'exemple, il s'agit de la classe \nCuboidBuilder\n.\n\n\nD\u00e9finition des modifications\n\uf0c1\n\n\nUne modification al\u00e9atoire est est d\u00e9termin\u00e9e par le choix d\u2019un des noyaux de proposition. Chaque noyau a la m\u00eame probabilit\u00e9 d'\u00eatre s\u00e9lectionn\u00e9. Dans le cadre de l'exemple, 6 noyaux sont utilis\u00e9s :\n\n\n\n\najout/suppression d\u2019une nouvelle bo\u00eete ;\n\n\ntranslation d\u2019une bo\u00eete ;\n\n\nchangement de la longueur d\u2019une bo\u00eete ;\n\n\nchangement de la largeur d\u2019une bo\u00eete ;\n\n\nchangement de la hauteur d\u2019une bo\u00eete ;\n\n\nrotation d\u2019une bo\u00eete.\n\n\n\n\nExcept\u00e9s les modifications issues du premier noyau, toutes les modifications sont impl\u00e9ment\u00e9es comme la suppression et l'ajout d'une bo\u00eete. Par exemple, une modification de type changement de longueur d'une bo\u00eete \nb\n = (\nx\n, \ny\n, \nl\n, \nw\n, \nh\n, \n\u03b8\n) est traduite comme la suppression de cette bo\u00eete et la cr\u00e9ation d'une nouvelle bo\u00eete avec une longueur diff\u00e9rente, d\u00e9finie comme : \nb'\n = (\nx\n, \ny\n, \nl\n + (\n1 - rand\n)  x \nampli\n, \nw\n, \nh\n, \n\u03b8\n) o\u00f9 \nrand\n est un nombre al\u00e9atoire pris dans [0,1] et \nampli\n est un coefficient d'amplification du d\u00e9placement (r\u00e9el strictement positif).\nAinsi, dans la simulation exemple, les coefficients des amplifications (\namplitudeMove\n, \namplitudeMaxDim\n, \namplitudeHeight\n, \namplitudeRotate\n) sont stock\u00e9s dans le fichier de param\u00e9trage \nparams.json\n.\n\n\nLes modifications sont impl\u00e9ment\u00e9es \u00e0 partir de la classe \nKernel\n de la librjmcmc4j qui d\u00e9finit comment modifier un objet de la classe param\u00e9trique utilis\u00e9e \u00e0 partir d'un tirage al\u00e9atoire.\n\n\nCr\u00e9ation de l'\u00e9chantillonneur de Green\n\uf0c1\n\n\nLes derni\u00e8res \u00e9tapes visent \u00e0 d\u00e9finir l'objet qui va effectuer les tirages al\u00e9atoires des bo\u00eetes qui seront cr\u00e9\u00e9es (classe \nDirectSampler\n de librjmcmc4j) et l'\u00e9chantillonneur de Green qui va d\u00e9finir les modifications \u00e0 appliquer pendant la simulation et notamment la probabilit\u00e9 d'acception durant le process.\n\n\nImpl\u00e9mentation\n\uf0c1\n\n\nLe code ci-dessous reprend l'impl\u00e9mentation de la cr\u00e9ation d'un \u00e9chantilloneur.\n\n\n\n    /**\n     * Creation of the sampler\n     * @param rng  a random generator\n     * @param p    the parameters loaded from the json file\n     * @param bpU  the basic property unit on which the simulation will be proceeded\n     * @param pred a predicate that will check the respect of the rules\n     * @param geom a geometry that will contains all the cuboid\n     * @return a sampler that will be used during the simulation process\n     */\n    public Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> create_sampler(RandomGenerator rng,\n            SimpluParameters p, BasicPropertyUnit bpU,\n            ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred,\n            IGeometry geom) {\n\n\n        //Step 1 : Creation of the object that will control the birth and death of cuboid\n\n        //Getting minimal and maximal dimension from the parameter file\n        double minlen = Double.isNaN(this.minLengthBox) ? p.getDouble(\"minlen\") : this.minLengthBox;\n        double maxlen = Double.isNaN(this.maxLengthBox) ? p.getDouble(\"maxlen\") : this.maxLengthBox;\n\n        double minwid = Double.isNaN(this.minWidthBox) ? p.getDouble(\"minwid\") : this.minWidthBox;\n        double maxwid = Double.isNaN(this.maxWidthBox) ? p.getDouble(\"maxwid\") : this.maxWidthBox;\n\n        double minheight = p.getDouble(\"minheight\");\n        double maxheight = p.getDouble(\"maxheight\");\n\n\n        //Builder class of the object\n        ObjectBuilder<Cuboid> builder = new CuboidBuilder();\n\n        //The geometry in which the sampler will be instanciated\n        if (geom != null) {\n            samplingSurface = geom;\n        }\n\n        if (samplingSurface == null) {\n            samplingSurface = bpU.getGeom();\n        }\n        IEnvelope env = samplingSurface.getEnvelope();\n\n        //Instanciation of the object dedicated for the creation of new cuboid during the process\n        //Passing the building, the class (TransformToSurface) that will make\n        // the transformation between random numbers and coordinates inside the samplingSurface\n        UniformBirth<Cuboid> birth = new UniformBirth<Cuboid>(rng,\n                new Cuboid(env.minX(), env.minY(), minlen, minwid, minheight, 0),\n                new Cuboid(env.maxX(), env.maxY(), maxlen, maxwid, maxheight, Math.PI), builder,\n                TransformToSurface.class, samplingSurface);\n\n\n\n        //Step 2  : Listing the modification kernel\n\n        //List of kernel for modification during the process\n        List<Kernel<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> kernels = new ArrayList<>();\n\n        //A factory to create proper kernels\n        KernelFactory<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> factory = new KernelFactory<>();\n\n        //Adding the birth/death kernel\n        kernels.add(\n                factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\"));\n        //Adding the other modification kernel\n        double amplitudeMove = p.getDouble(\"amplitudeMove\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveCuboid(amplitudeMove), 0.2, \"Move\"));\n        double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180;\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new RotateCuboid(amplitudeRotate), 0.2,\n                \"Rotate\"));\n        double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeWidth(amplitudeMaxDim), 0.2,\n                \"ChgWidth\"));\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeLength(amplitudeMaxDim), 0.2,\n                \"ChgLength\"));\n        double amplitudeHeight = p.getDouble(\"amplitudeHeight\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeHeight(amplitudeHeight), 0.2,\n                \"ChgHeight\"));\n\n        //Step 3  : Creation of the sampler for the brith/death of cuboid\n\n        // This distribution create a biais to make the system tends around a certain number of boxes\n        PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\"));\n        //Creation of the sampler with the modification in itself\n        DirectSampler<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> ds = new DirectRejectionSampler<>(\n                distribution, birth, pred);\n\n        //Step 4  : Creation of the GreenSampler that will be used during the optimization process\n        //It notably control the acception ratio and that the created objects and that the proposed configurations area generated\n        //According to the uniformbirth\n        Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> s = new GreenSamplerBlockTemperature<>(rng,\n                ds, new MetropolisAcceptance<SimpleTemperature>(), kernels);\n        return s;\n    }",
            "title": "Custom generator"
        },
        {
            "location": "/generator/custom-generator/#parametrer-les-boites-dune-configuration",
            "text": "Dans cette partie, nous d\u00e9crivons comment le syst\u00e8me d\u00e9finit la cr\u00e9ation de nouveaux objets param\u00e9triques et les modifications qui leur seront apport\u00e9es durant l'optimisation. Il s'agit de l'\u00e9tape 1 du code d\u00e9crit dans la section  principe de simulation . Cet exemple s'appuie sur la g\u00e9n\u00e9ration de bo\u00eetes, mais il est possible de d\u00e9finir d'autres types de g\u00e9om\u00e9tries (cela sera d\u00e9crit dans la section  G\u00e9n\u00e9rer d'autres types de formes ).  Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans  la derni\u00e8re partie de la page sur l'impl\u00e9mentation  (\u00e9tape 1) , c'est \u00e0 dire le code suivant :  // Step 1 :\n\n// Sampler creation (definition of the class and of the kernel modifications)\n// Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications)\nSampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p,\nbpu, pred, geom);",
            "title": "Param\u00e9trer les bo\u00eetes d'une configuration"
        },
        {
            "location": "/generator/custom-generator/#definition-des-formes-generables",
            "text": "Pour rappel, le processus d'optimisation vise \u00e0 g\u00e9n\u00e9rer une configuration compos\u00e9e de  n  bo\u00eetes chaque bo\u00eete pouvant \u00eatre d\u00e9finie par un vecteur de dimension 6 :  b  = ( x ,  y ,  l ,  w ,  h ,  \u03b8 ).  Afin de pouvoir \u00e9chantillonner, il est n\u00e9cessaire de d\u00e9finir les intervalles dans lesquels le tirage des bo\u00eetes sera effectu\u00e9 :   xmin  <  x  <  xmax  ymin  <  y  <  ymax  min\u03b8  <  \u03b8  <  max\u03b8  minwid  <  w  <  maxwid  minlen  <  l  <  maxlen  minheight  <  h  <  maxheight   Les deux premi\u00e8res valeurs sont contraintes par l'enveloppe contenant la g\u00e9om\u00e9trie dans laquelle les centres de bo\u00eetes seront \u00e9chantillonn\u00e9s.  Dans l'exemple de la  premi\u00e8re simulation ,  min\u03b8  et  max\u03b8  sont fix\u00e9s  \u00e0  0  et  \u03c0  afin de permettre tout type d'orientation. Les autres param\u00e8tres sont fix\u00e9s dans le fichier de configuration  params.json .  Afin que le syst\u00e8me puisse g\u00e9n\u00e9rer des formes, il est n\u00e9cessaire de d\u00e9finir une classe  Builder  qui permet d'instancier les objets \u00e0 partir d'un tableau contenant les param\u00e8tres de la forme. Dans l'exemple, il s'agit de la classe  CuboidBuilder .",
            "title": "D\u00e9finition des formes g\u00e9n\u00e9rables"
        },
        {
            "location": "/generator/custom-generator/#definition-des-modifications",
            "text": "Une modification al\u00e9atoire est est d\u00e9termin\u00e9e par le choix d\u2019un des noyaux de proposition. Chaque noyau a la m\u00eame probabilit\u00e9 d'\u00eatre s\u00e9lectionn\u00e9. Dans le cadre de l'exemple, 6 noyaux sont utilis\u00e9s :   ajout/suppression d\u2019une nouvelle bo\u00eete ;  translation d\u2019une bo\u00eete ;  changement de la longueur d\u2019une bo\u00eete ;  changement de la largeur d\u2019une bo\u00eete ;  changement de la hauteur d\u2019une bo\u00eete ;  rotation d\u2019une bo\u00eete.   Except\u00e9s les modifications issues du premier noyau, toutes les modifications sont impl\u00e9ment\u00e9es comme la suppression et l'ajout d'une bo\u00eete. Par exemple, une modification de type changement de longueur d'une bo\u00eete  b  = ( x ,  y ,  l ,  w ,  h ,  \u03b8 ) est traduite comme la suppression de cette bo\u00eete et la cr\u00e9ation d'une nouvelle bo\u00eete avec une longueur diff\u00e9rente, d\u00e9finie comme :  b'  = ( x ,  y ,  l  + ( 1 - rand )  x  ampli ,  w ,  h ,  \u03b8 ) o\u00f9  rand  est un nombre al\u00e9atoire pris dans [0,1] et  ampli  est un coefficient d'amplification du d\u00e9placement (r\u00e9el strictement positif).\nAinsi, dans la simulation exemple, les coefficients des amplifications ( amplitudeMove ,  amplitudeMaxDim ,  amplitudeHeight ,  amplitudeRotate ) sont stock\u00e9s dans le fichier de param\u00e9trage  params.json .  Les modifications sont impl\u00e9ment\u00e9es \u00e0 partir de la classe  Kernel  de la librjmcmc4j qui d\u00e9finit comment modifier un objet de la classe param\u00e9trique utilis\u00e9e \u00e0 partir d'un tirage al\u00e9atoire.",
            "title": "D\u00e9finition des modifications"
        },
        {
            "location": "/generator/custom-generator/#creation-de-lechantillonneur-de-green",
            "text": "Les derni\u00e8res \u00e9tapes visent \u00e0 d\u00e9finir l'objet qui va effectuer les tirages al\u00e9atoires des bo\u00eetes qui seront cr\u00e9\u00e9es (classe  DirectSampler  de librjmcmc4j) et l'\u00e9chantillonneur de Green qui va d\u00e9finir les modifications \u00e0 appliquer pendant la simulation et notamment la probabilit\u00e9 d'acception durant le process.",
            "title": "Cr\u00e9ation de l'\u00e9chantillonneur de Green"
        },
        {
            "location": "/generator/custom-generator/#implementation",
            "text": "Le code ci-dessous reprend l'impl\u00e9mentation de la cr\u00e9ation d'un \u00e9chantilloneur.  \n    /**\n     * Creation of the sampler\n     * @param rng  a random generator\n     * @param p    the parameters loaded from the json file\n     * @param bpU  the basic property unit on which the simulation will be proceeded\n     * @param pred a predicate that will check the respect of the rules\n     * @param geom a geometry that will contains all the cuboid\n     * @return a sampler that will be used during the simulation process\n     */\n    public Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> create_sampler(RandomGenerator rng,\n            SimpluParameters p, BasicPropertyUnit bpU,\n            ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred,\n            IGeometry geom) {\n\n\n        //Step 1 : Creation of the object that will control the birth and death of cuboid\n\n        //Getting minimal and maximal dimension from the parameter file\n        double minlen = Double.isNaN(this.minLengthBox) ? p.getDouble(\"minlen\") : this.minLengthBox;\n        double maxlen = Double.isNaN(this.maxLengthBox) ? p.getDouble(\"maxlen\") : this.maxLengthBox;\n\n        double minwid = Double.isNaN(this.minWidthBox) ? p.getDouble(\"minwid\") : this.minWidthBox;\n        double maxwid = Double.isNaN(this.maxWidthBox) ? p.getDouble(\"maxwid\") : this.maxWidthBox;\n\n        double minheight = p.getDouble(\"minheight\");\n        double maxheight = p.getDouble(\"maxheight\");\n\n\n        //Builder class of the object\n        ObjectBuilder<Cuboid> builder = new CuboidBuilder();\n\n        //The geometry in which the sampler will be instanciated\n        if (geom != null) {\n            samplingSurface = geom;\n        }\n\n        if (samplingSurface == null) {\n            samplingSurface = bpU.getGeom();\n        }\n        IEnvelope env = samplingSurface.getEnvelope();\n\n        //Instanciation of the object dedicated for the creation of new cuboid during the process\n        //Passing the building, the class (TransformToSurface) that will make\n        // the transformation between random numbers and coordinates inside the samplingSurface\n        UniformBirth<Cuboid> birth = new UniformBirth<Cuboid>(rng,\n                new Cuboid(env.minX(), env.minY(), minlen, minwid, minheight, 0),\n                new Cuboid(env.maxX(), env.maxY(), maxlen, maxwid, maxheight, Math.PI), builder,\n                TransformToSurface.class, samplingSurface);\n\n\n\n        //Step 2  : Listing the modification kernel\n\n        //List of kernel for modification during the process\n        List<Kernel<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> kernels = new ArrayList<>();\n\n        //A factory to create proper kernels\n        KernelFactory<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> factory = new KernelFactory<>();\n\n        //Adding the birth/death kernel\n        kernels.add(\n                factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\"));\n        //Adding the other modification kernel\n        double amplitudeMove = p.getDouble(\"amplitudeMove\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveCuboid(amplitudeMove), 0.2, \"Move\"));\n        double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180;\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new RotateCuboid(amplitudeRotate), 0.2,\n                \"Rotate\"));\n        double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeWidth(amplitudeMaxDim), 0.2,\n                \"ChgWidth\"));\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeLength(amplitudeMaxDim), 0.2,\n                \"ChgLength\"));\n        double amplitudeHeight = p.getDouble(\"amplitudeHeight\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeHeight(amplitudeHeight), 0.2,\n                \"ChgHeight\"));\n\n        //Step 3  : Creation of the sampler for the brith/death of cuboid\n\n        // This distribution create a biais to make the system tends around a certain number of boxes\n        PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\"));\n        //Creation of the sampler with the modification in itself\n        DirectSampler<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> ds = new DirectRejectionSampler<>(\n                distribution, birth, pred);\n\n        //Step 4  : Creation of the GreenSampler that will be used during the optimization process\n        //It notably control the acception ratio and that the created objects and that the proposed configurations area generated\n        //According to the uniformbirth\n        Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> s = new GreenSamplerBlockTemperature<>(rng,\n                ds, new MetropolisAcceptance<SimpleTemperature>(), kernels);\n        return s;\n    }",
            "title": "Impl\u00e9mentation"
        },
        {
            "location": "/generator/custom-optimisation/",
            "text": "Param\u00e9trer la fonction d'optimisation\n\uf0c1\n\n\nDans cette partie, nous pr\u00e9sentons comment est configur\u00e9 l'algorithme d'optimisation \u00e0 travers les conditions initiales et d'arr\u00eat, ainsi que la d\u00e9finition de la fonction d'optimisation.\n\n\nLes parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans \nla derni\u00e8re partie de la page sur l'impl\u00e9mentation\n (\u00e9tape 2) , c'est \u00e0 dire le code suivant :\n\n\n//Step 2 : Preparation of the optimizer\n//\u00c9tape 2 : Pr\u00e9paration de l'optimiseur\n\n//Initializing the configuration (optimisation function + set of cuboid)\n//Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante\nGraphConfiguration<Cuboid> conf = null;\ntry {\n  conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu);\n} catch (Exception e) {\n  e.printStackTrace();\n}\n\n// Temperature initialization\n//Initialization de la fonction de la temp\u00e9rature\nSchedule<SimpleTemperature> sch = create_schedule(p);\n\n\n//The end test condition\nend = create_end_test(p);\n\n\n\n\nD\u00e9finition de la fonction d'optimisation\n\uf0c1\n\n\nPrincipe g\u00e9n\u00e9ral\n\uf0c1\n\n\nLa fonction \u00e0 optimiser est contenue dans un objet de la classe g\u00e9n\u00e9rique \nGraphConfiguration<?>\n \u00e0 typer en fonction de la classe param\u00e9trique utilis\u00e9e. La fonction d'optimisation est compos\u00e9e de 3 \u00e9nergies :\n\n\n\n\nune \u00e9nergie unaire\n (interface \nUnaryEnergy<?>\n), qui \u00e9value ind\u00e9pendant une \u00e9nergie pour chacun des objets  ;\n\n\nune \u00e9nergie binaire\n (interface \nBinaryEnergy<?>\n), qui \u00e9value une \u00e9nergie pour chaque couple d'objet ;\n\n\nune \u00e9nergie de collection\n facultative  (interface \nCollectionEnergy<?>\n), qui \u00e9value la somme pour l'ensemble de la collection.\n\n\n\n\nLes interfaces des classes ne d\u00e9finissent qu'une m\u00e9thode \ndouble getValue()\n qui renvoie la valeur num\u00e9rique associ\u00e9e\n\n\nLa valeur de la fonction d'optimisation est la somme des contributions de ces trois types d'\u00e9nergie. Pour produire ces contributions, il est possible, pour chaque type d'\u00e9nergie, de combiner diff\u00e9rents op\u00e9rateurs (addition, soustraction, multiplication, etc.) pour produire des \u00e9nergies composites. La d\u00e9finition de ces op\u00e9rateurs se trouve dans le package \nfr.ign.rjmcmc.energy\n de la librjmcmc4j.\n\n\n\n\n \nAttention\n: la librjmcmc4j est une biblioth\u00e8que minimisant par convention la fonction \u00e9nerg\u00e9tique, il est n\u00e9cessaire d'adapter l'instanciation de la fonction d'\u00e9nergie en accord avec ce principe. Dans l'exemple au d\u00e9but, il s'agit de minimiser - volume(configuration)).\n\n\n\n\nIllustration avec l'exemple\n\uf0c1\n\n\nLa formule de l'\u00e9nergie dans l'exemple est la suivante :\n\n\n\nL'\u00e9nergie unaire contient diff\u00e9rents termes :\n- \nEcreation\n a pour objectif de p\u00e9naliser les bo\u00eetes ne contribuant pas suffisamment \u00e0 la configuration. La d\u00e9finition de ce param\u00e8tre est indispensable : en effet, rien n\u2019emp\u00eache l\u2019intersection de bo\u00eetes. Sans ce param\u00e8tre, que nous nommons \u00e9nergie de cr\u00e9ation, le syst\u00e8me pourrait tr\u00e8s bien proposer des configurations contenant de tr\u00e8s nombreuses bo\u00eetes qui ne contribueraient pas \u00e0 augmenter le volume global de la configuration ;\n- \nvolume(b)\n qui d\u00e9finit le volume de chaque bo\u00eete ind\u00e9pendamment ;\n- \nvolumeDifference(bPU,b)\n qui d\u00e9finit une \u00e9nergie en fonction du d\u00e9passement en termes de volume de l'unit\u00e9 fonci\u00e8re simul\u00e9e (bPU). Cette contrainte est ajout\u00e9e comme les r\u00e8gles n'imposent pas dans l'exemple que les bo\u00eetes se trouvent strictement \u00e0 l'int\u00e9rieur de l'unit\u00e9 fonci\u00e8re. L'objectif de ce terme est d'autoriser le d\u00e9passement que si celui-ci contribue significativement \u00e0 l'am\u00e9lioration du volume.\nLes deux derniers termes sont pond\u00e9r\u00e9s par les \nponderationVolume\n et \nponderationDifference\n.\n\n\nL'\u00e9nergie binaire est compos\u00e9 de l'op\u00e9rateur \nvolumeintersection(b1, b2)\n qui \u00e9value la diff\u00e9rence des volumes entre chaque couple de bo\u00eete qui est pond\u00e9r\u00e9 par \nponderation_volume_inter\n.\n\n\nLes diff\u00e9rentes pond\u00e9rations et la valeur \nEcreation\n sont param\u00e9trables, dans l'exemple, dans le fichier \nparams.json\n.\n\n\n\n\nLa figure ci-dessus repr\u00e9sente le graphe d'\u00e9nergie tel que mod\u00e9lis\u00e9 en accord avec le formalisme de la librjmcmc4j. Les \u00e9nergies dynamiques sont \u00e9valu\u00e9es \u00e0 chaque it\u00e9ration et impl\u00e9mentent  \nUnaryEnergy<?>\n et  \nBinaryEnergy<?>\n en fonction de l'\u00e9nergie mod\u00e9lis\u00e9e.\n\n\nIl s'agit d'une repr\u00e9sentation du code qui se situe ci-dessous et qui est utilis\u00e9 dans le premier exemple de simulation.\n\n\n/**\n * Creation of a cuboid configuration\n * @param p    parameters from the json file\n * @param bpu  the basic property unit on which the optimization will be\n *             proceeded\n * @param geom the geometry that contains the cuboids\n * @return a new configuration that embeds the calculation of the optimization\n *         function\n */\n\npublic GraphConfiguration<Cuboid> create_configuration(SimpluParameters p, Geometry geom, BasicPropertyUnit bpu) {\n  // \u00c9nergie constante : \u00e0 la cr\u00e9ation d'un nouvel objet\n  ConstantEnergy<Cuboid, Cuboid> energyCreation = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"energy\"));\n  // \u00c9nergie constante : pond\u00e9ration de l'intersection\n  ConstantEnergy<Cuboid, Cuboid> ponderationVolume = new ConstantEnergy<Cuboid, Cuboid>(\n      p.getDouble(\"ponderation_volume\"));\n  // \u00c9nergie unaire : aire dans la parcelle\n  UnaryEnergy<Cuboid> energyVolume = new VolumeUnaryEnergy<Cuboid>();\n  // Multiplication de l'\u00e9nergie d'intersection et de l'aire\n  UnaryEnergy<Cuboid> energyVolumePondere = new MultipliesUnaryEnergy<Cuboid>(ponderationVolume, energyVolume);\n\n  // On retire de l'\u00e9nergie de cr\u00e9ation, l'\u00e9nergie de l'aire\n  UnaryEnergy<Cuboid> u3 = new MinusUnaryEnergy<Cuboid>(energyCreation, energyVolumePondere);\n\n  double ponderationExt = p.getDouble(\"ponderation_difference_ext\");\n\n  UnaryEnergy<Cuboid> unaryEnergy;\n\n  if (ponderationExt != 0) {\n    // \u00c9nergie constante : pond\u00e9ration de la diff\u00e9rence\n    ConstantEnergy<Cuboid, Cuboid> ponderationDifference = new ConstantEnergy<Cuboid, Cuboid>(\n        p.getDouble(\"ponderation_difference_ext\"));\n    // On ajoute l'\u00e9nergie de diff\u00e9rence : la zone en dehors de la parcelle\n    UnaryEnergy<Cuboid> u4 = new DifferenceVolumeUnaryEnergy<Cuboid>(geom);\n    UnaryEnergy<Cuboid> u5 = new MultipliesUnaryEnergy<Cuboid>(ponderationDifference, u4);\n    unaryEnergy = new PlusUnaryEnergy<Cuboid>(u3, u5);\n  } else {\n    unaryEnergy = u3;\n  }\n\n  // \u00c9nergie binaire : intersection entre deux rectangles\n  ConstantEnergy<Cuboid, Cuboid> c3 = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"ponderation_volume_inter\"));\n  BinaryEnergy<Cuboid, Cuboid> b1 = new IntersectionVolumeBinaryEnergy<Cuboid>();\n  BinaryEnergy<Cuboid, Cuboid> binaryEnergy = new MultipliesBinaryEnergy<Cuboid, Cuboid>(c3, b1);\n  // empty initial configuration*/\n  GraphConfiguration<Cuboid> conf = new GraphConfiguration<>(unaryEnergy, binaryEnergy);\n  return conf;\n}\n\n\n\n\nConditions initiales et condition d'arr\u00eat\n\uf0c1\n\n\nLa fonction de temp\u00e9rature est fix\u00e9e dans la m\u00e9thode \ncreate_schedule\n et vise \u00e0 moduler la probabilit\u00e9 d'acceptation durant la simulation. Les diff\u00e9rents types possibles de temp\u00e9rature sont ceux de la librjmcmc4j (package \nfr.ign.simulatedannealing.schedule\n). Dans le cadre de SimPLU3D, nous avons opt\u00e9 pour la temp\u00e9rature de M\u00e9tropolis. Il s'agit d'une fonction g\u00e9om\u00e9trique d\u00e9croissante qui n\u00e9cessite deux param\u00e8tres : une temp\u00e9rature initiale (valeur \ntemp\n du fichier de configuration) et un coefficient de d\u00e9croissance (valeur \ndeccoef\n). D'apr\u00e8s les articles sur le recuit simul\u00e9, il est conseill\u00e9 de fixer cette valeur comme \u00e9tant la plus grande variation possible de la fonction d'optimisation entre deux \u00e9tats (par exemple, dans le cadre du volume, il s'agit de l'\u00e9cart entre une parcelle vide et une parcelle compl\u00e8tement b\u00e2tie par le b\u00e2timent le plus haut possible). Le coefficient doit \u00eatre fix\u00e9 tr\u00e8s proche de 1 (comme dans les fichiers exemples). Si vous souhaitez en savoir plus, vous pouvez consulter l'article suivant :\n\n\n\n\nBr\u00e9dif, M., Tournaire, O.\n, Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. (\nhttps://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf\n)\n\n\n\n\nTrois types de condition d'arr\u00eat sont utilisables \u00e0 travers la m\u00e9thode \ncreate_end_test\n et leurs param\u00e8tres sont d\u00e9finis dans le fichier de configuration :\n- \nabsolute\n : le simulateur s'arr\u00eate au bout de \nabsolute_nb_iter\n) it\u00e9rations, ce nombre est fix\u00e9 dans le fichier de configuration ;\n- \nrelative\n : le simulateur si la fonction \u00e9nerg\u00e9tique ne s'am\u00e9liore pas de la valeur \ndelta\n pendant \nrelative_nb_iter\n it\u00e9rations ;\n- \ncomposite\n : le simulation s'arr\u00eate lorsque la premi\u00e8re condition d'arr\u00eat (entre absolute et relative) est atteinte.\nOn peut choisir avec le fichier de configuration entre ces trois types gr\u00e2ce au param\u00e8tre \nend_test_type\n qui peut prendre comme valeur \nabsolute\n, \nrelative\n ou \ncomposite\n.",
            "title": "Custom optimisation"
        },
        {
            "location": "/generator/custom-optimisation/#parametrer-la-fonction-doptimisation",
            "text": "Dans cette partie, nous pr\u00e9sentons comment est configur\u00e9 l'algorithme d'optimisation \u00e0 travers les conditions initiales et d'arr\u00eat, ainsi que la d\u00e9finition de la fonction d'optimisation.  Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans  la derni\u00e8re partie de la page sur l'impl\u00e9mentation  (\u00e9tape 2) , c'est \u00e0 dire le code suivant :  //Step 2 : Preparation of the optimizer\n//\u00c9tape 2 : Pr\u00e9paration de l'optimiseur\n\n//Initializing the configuration (optimisation function + set of cuboid)\n//Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante\nGraphConfiguration<Cuboid> conf = null;\ntry {\n  conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu);\n} catch (Exception e) {\n  e.printStackTrace();\n}\n\n// Temperature initialization\n//Initialization de la fonction de la temp\u00e9rature\nSchedule<SimpleTemperature> sch = create_schedule(p);\n\n\n//The end test condition\nend = create_end_test(p);",
            "title": "Param\u00e9trer la fonction d'optimisation"
        },
        {
            "location": "/generator/custom-optimisation/#definition-de-la-fonction-doptimisation",
            "text": "",
            "title": "D\u00e9finition de la fonction d'optimisation"
        },
        {
            "location": "/generator/custom-optimisation/#principe-general",
            "text": "La fonction \u00e0 optimiser est contenue dans un objet de la classe g\u00e9n\u00e9rique  GraphConfiguration<?>  \u00e0 typer en fonction de la classe param\u00e9trique utilis\u00e9e. La fonction d'optimisation est compos\u00e9e de 3 \u00e9nergies :   une \u00e9nergie unaire  (interface  UnaryEnergy<?> ), qui \u00e9value ind\u00e9pendant une \u00e9nergie pour chacun des objets  ;  une \u00e9nergie binaire  (interface  BinaryEnergy<?> ), qui \u00e9value une \u00e9nergie pour chaque couple d'objet ;  une \u00e9nergie de collection  facultative  (interface  CollectionEnergy<?> ), qui \u00e9value la somme pour l'ensemble de la collection.   Les interfaces des classes ne d\u00e9finissent qu'une m\u00e9thode  double getValue()  qui renvoie la valeur num\u00e9rique associ\u00e9e  La valeur de la fonction d'optimisation est la somme des contributions de ces trois types d'\u00e9nergie. Pour produire ces contributions, il est possible, pour chaque type d'\u00e9nergie, de combiner diff\u00e9rents op\u00e9rateurs (addition, soustraction, multiplication, etc.) pour produire des \u00e9nergies composites. La d\u00e9finition de ces op\u00e9rateurs se trouve dans le package  fr.ign.rjmcmc.energy  de la librjmcmc4j.     Attention : la librjmcmc4j est une biblioth\u00e8que minimisant par convention la fonction \u00e9nerg\u00e9tique, il est n\u00e9cessaire d'adapter l'instanciation de la fonction d'\u00e9nergie en accord avec ce principe. Dans l'exemple au d\u00e9but, il s'agit de minimiser - volume(configuration)).",
            "title": "Principe g\u00e9n\u00e9ral"
        },
        {
            "location": "/generator/custom-optimisation/#illustration-avec-lexemple",
            "text": "La formule de l'\u00e9nergie dans l'exemple est la suivante :  L'\u00e9nergie unaire contient diff\u00e9rents termes :\n-  Ecreation  a pour objectif de p\u00e9naliser les bo\u00eetes ne contribuant pas suffisamment \u00e0 la configuration. La d\u00e9finition de ce param\u00e8tre est indispensable : en effet, rien n\u2019emp\u00eache l\u2019intersection de bo\u00eetes. Sans ce param\u00e8tre, que nous nommons \u00e9nergie de cr\u00e9ation, le syst\u00e8me pourrait tr\u00e8s bien proposer des configurations contenant de tr\u00e8s nombreuses bo\u00eetes qui ne contribueraient pas \u00e0 augmenter le volume global de la configuration ;\n-  volume(b)  qui d\u00e9finit le volume de chaque bo\u00eete ind\u00e9pendamment ;\n-  volumeDifference(bPU,b)  qui d\u00e9finit une \u00e9nergie en fonction du d\u00e9passement en termes de volume de l'unit\u00e9 fonci\u00e8re simul\u00e9e (bPU). Cette contrainte est ajout\u00e9e comme les r\u00e8gles n'imposent pas dans l'exemple que les bo\u00eetes se trouvent strictement \u00e0 l'int\u00e9rieur de l'unit\u00e9 fonci\u00e8re. L'objectif de ce terme est d'autoriser le d\u00e9passement que si celui-ci contribue significativement \u00e0 l'am\u00e9lioration du volume.\nLes deux derniers termes sont pond\u00e9r\u00e9s par les  ponderationVolume  et  ponderationDifference .  L'\u00e9nergie binaire est compos\u00e9 de l'op\u00e9rateur  volumeintersection(b1, b2)  qui \u00e9value la diff\u00e9rence des volumes entre chaque couple de bo\u00eete qui est pond\u00e9r\u00e9 par  ponderation_volume_inter .  Les diff\u00e9rentes pond\u00e9rations et la valeur  Ecreation  sont param\u00e9trables, dans l'exemple, dans le fichier  params.json .   La figure ci-dessus repr\u00e9sente le graphe d'\u00e9nergie tel que mod\u00e9lis\u00e9 en accord avec le formalisme de la librjmcmc4j. Les \u00e9nergies dynamiques sont \u00e9valu\u00e9es \u00e0 chaque it\u00e9ration et impl\u00e9mentent   UnaryEnergy<?>  et   BinaryEnergy<?>  en fonction de l'\u00e9nergie mod\u00e9lis\u00e9e.  Il s'agit d'une repr\u00e9sentation du code qui se situe ci-dessous et qui est utilis\u00e9 dans le premier exemple de simulation.  /**\n * Creation of a cuboid configuration\n * @param p    parameters from the json file\n * @param bpu  the basic property unit on which the optimization will be\n *             proceeded\n * @param geom the geometry that contains the cuboids\n * @return a new configuration that embeds the calculation of the optimization\n *         function\n */\n\npublic GraphConfiguration<Cuboid> create_configuration(SimpluParameters p, Geometry geom, BasicPropertyUnit bpu) {\n  // \u00c9nergie constante : \u00e0 la cr\u00e9ation d'un nouvel objet\n  ConstantEnergy<Cuboid, Cuboid> energyCreation = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"energy\"));\n  // \u00c9nergie constante : pond\u00e9ration de l'intersection\n  ConstantEnergy<Cuboid, Cuboid> ponderationVolume = new ConstantEnergy<Cuboid, Cuboid>(\n      p.getDouble(\"ponderation_volume\"));\n  // \u00c9nergie unaire : aire dans la parcelle\n  UnaryEnergy<Cuboid> energyVolume = new VolumeUnaryEnergy<Cuboid>();\n  // Multiplication de l'\u00e9nergie d'intersection et de l'aire\n  UnaryEnergy<Cuboid> energyVolumePondere = new MultipliesUnaryEnergy<Cuboid>(ponderationVolume, energyVolume);\n\n  // On retire de l'\u00e9nergie de cr\u00e9ation, l'\u00e9nergie de l'aire\n  UnaryEnergy<Cuboid> u3 = new MinusUnaryEnergy<Cuboid>(energyCreation, energyVolumePondere);\n\n  double ponderationExt = p.getDouble(\"ponderation_difference_ext\");\n\n  UnaryEnergy<Cuboid> unaryEnergy;\n\n  if (ponderationExt != 0) {\n    // \u00c9nergie constante : pond\u00e9ration de la diff\u00e9rence\n    ConstantEnergy<Cuboid, Cuboid> ponderationDifference = new ConstantEnergy<Cuboid, Cuboid>(\n        p.getDouble(\"ponderation_difference_ext\"));\n    // On ajoute l'\u00e9nergie de diff\u00e9rence : la zone en dehors de la parcelle\n    UnaryEnergy<Cuboid> u4 = new DifferenceVolumeUnaryEnergy<Cuboid>(geom);\n    UnaryEnergy<Cuboid> u5 = new MultipliesUnaryEnergy<Cuboid>(ponderationDifference, u4);\n    unaryEnergy = new PlusUnaryEnergy<Cuboid>(u3, u5);\n  } else {\n    unaryEnergy = u3;\n  }\n\n  // \u00c9nergie binaire : intersection entre deux rectangles\n  ConstantEnergy<Cuboid, Cuboid> c3 = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"ponderation_volume_inter\"));\n  BinaryEnergy<Cuboid, Cuboid> b1 = new IntersectionVolumeBinaryEnergy<Cuboid>();\n  BinaryEnergy<Cuboid, Cuboid> binaryEnergy = new MultipliesBinaryEnergy<Cuboid, Cuboid>(c3, b1);\n  // empty initial configuration*/\n  GraphConfiguration<Cuboid> conf = new GraphConfiguration<>(unaryEnergy, binaryEnergy);\n  return conf;\n}",
            "title": "Illustration avec l'exemple"
        },
        {
            "location": "/generator/custom-optimisation/#conditions-initiales-et-condition-darret",
            "text": "La fonction de temp\u00e9rature est fix\u00e9e dans la m\u00e9thode  create_schedule  et vise \u00e0 moduler la probabilit\u00e9 d'acceptation durant la simulation. Les diff\u00e9rents types possibles de temp\u00e9rature sont ceux de la librjmcmc4j (package  fr.ign.simulatedannealing.schedule ). Dans le cadre de SimPLU3D, nous avons opt\u00e9 pour la temp\u00e9rature de M\u00e9tropolis. Il s'agit d'une fonction g\u00e9om\u00e9trique d\u00e9croissante qui n\u00e9cessite deux param\u00e8tres : une temp\u00e9rature initiale (valeur  temp  du fichier de configuration) et un coefficient de d\u00e9croissance (valeur  deccoef ). D'apr\u00e8s les articles sur le recuit simul\u00e9, il est conseill\u00e9 de fixer cette valeur comme \u00e9tant la plus grande variation possible de la fonction d'optimisation entre deux \u00e9tats (par exemple, dans le cadre du volume, il s'agit de l'\u00e9cart entre une parcelle vide et une parcelle compl\u00e8tement b\u00e2tie par le b\u00e2timent le plus haut possible). Le coefficient doit \u00eatre fix\u00e9 tr\u00e8s proche de 1 (comme dans les fichiers exemples). Si vous souhaitez en savoir plus, vous pouvez consulter l'article suivant :   Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf )   Trois types de condition d'arr\u00eat sont utilisables \u00e0 travers la m\u00e9thode  create_end_test  et leurs param\u00e8tres sont d\u00e9finis dans le fichier de configuration :\n-  absolute  : le simulateur s'arr\u00eate au bout de  absolute_nb_iter ) it\u00e9rations, ce nombre est fix\u00e9 dans le fichier de configuration ;\n-  relative  : le simulateur si la fonction \u00e9nerg\u00e9tique ne s'am\u00e9liore pas de la valeur  delta  pendant  relative_nb_iter  it\u00e9rations ;\n-  composite  : le simulation s'arr\u00eate lorsque la premi\u00e8re condition d'arr\u00eat (entre absolute et relative) est atteinte.\nOn peut choisir avec le fichier de configuration entre ces trois types gr\u00e2ce au param\u00e8tre  end_test_type  qui peut prendre comme valeur  absolute ,  relative  ou  composite .",
            "title": "Conditions initiales et condition d'arr\u00eat"
        },
        {
            "location": "/generator/custom-shape/",
            "text": "G\u00e9n\u00e9ration de b\u00e2timents en L\n\uf0c1\n\n\nL'objectif de cette partie est de pr\u00e9senter un code permettant de g\u00e9n\u00e9rer des b\u00e2timents en forme de L avec un toit typifi\u00e9 et de d\u00e9crire les \u00e9tapes \u00e0 suivre pour g\u00e9n\u00e9rer des configurations avec d'autres types de forme \u00e0 partir du simulateur basique pr\u00e9sent\u00e9 dans la \npremi\u00e8re exp\u00e9rimentation\n.\n\n\nCode exemple\n\uf0c1\n\n\nL'ex\u00e9cution du code pr\u00e9sent\u00e9 ici se trouve dans la classe  \nfr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection\n du projet SimPLU3D-tutorial.\n\n\n\n\nLa classe de g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e (pr\u00e9sent\u00e9e dans le sch\u00e9ma pr\u00e9c\u00e9dent) comporte 10 dimensions :\n\n\n\n\nx\n : coordonn\u00e9e x du centre de la forme ;\n\n\ny\n : coordonn\u00e9e y du centre de la forme ;\n\n\nl1\n : longueur de la forme hors barre du L ;\n\n\nl2\n : longueur de la barre du L ;\n\n\nh1\n : hauteur totale de la forme hors barre du L;\n\n\nh2\n : hauteur totale de la barre du L;\n\n\nheight\n : hauteur maximale de la forme ;\n\n\norientation\n : orientation (azimut) du L ;\n\n\nhgutter\n : hauteur \u00e0 la goutti\u00e8re.\n\n\nshift\n : pente du toit aux extr\u00e9mit\u00e9s du L (entre 0 pas de pente et 1 pente jusqu'au milieu de la forme).\n\n\n\n\nD\u00e9finition de la classe repr\u00e9sentant la forme\n\uf0c1\n\n\nLa classe d\u00e9finissant la g\u00e9om\u00e9trie simul\u00e9e est la classe \nfr.ign.cogit.simplu3d.rjmcmc.paramshp.geometry.impl.LBuildingWithRoof\n du projet SimPLU3D. Cette classe impl\u00e9mente la classe \nAbstractSimpleBuilding\n (comme nous simulons un objet de type b\u00e2timent, comme c'est le cas pour la classe \nCubboid\n). Cela implique l'instanciation de 3 niveaux de classes abstraites et d'interfaces :\n-  la classe \nfr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.impl.AbstractSimpleBuilding\n de \nSimPLU3D-rules\n: qui contient les informations n\u00e9cessaires pour mod\u00e9liser un objet de type b\u00e2timent de SimPLU3D ;\n- l'interface \nfr.ign.cogit.simplu3d.rjmcmc.generic.objectISimPLU3DPrimitive\n : qui contient les m\u00e9thodes propres \u00e0 SimPLU3D concernant l'optimisation de forme ;\n- l'interface  de la librjmcmc4j \nfr.ign.geometry.Primitive\n : qui contient les informations n\u00e9cessaires pour simuler des objets g\u00e9ographiques avec la librjmcmc4j.\nSeule l'impl\u00e9mentation de la derni\u00e8re interface est n\u00e9cessaire pour g\u00e9n\u00e9rer des formes, les deux autres niveaux enrichissent les m\u00e9thodes accessibles pour la v\u00e9rification des r\u00e8gles et la d\u00e9finition de la fonction d'optimisation. Elles facilitent \u00e9galement la r\u00e9-utilisation du code de la premi\u00e8re simulation.\n\n\nL'impl\u00e9mentation de l'interface \nPrimitive\n  n\u00e9cessite la d\u00e9finition des m\u00e9thodes suivantes :\n\n\n\n\nint size();\n : renvoie la taille de la dimension de la forme (ici 10 pour le b\u00e2timent en L) ;\n\n\ndouble[] toArray()\n :  traduit les attributs de la classe en un tableau de double (il s'agit ici d'un tableau de dimension 10 contenant les valeurs des diff\u00e9rentes dimensions de la forme) ;\n\n\nObject[] getArray();\n : m\u00eame m\u00e9thode que pr\u00e9c\u00e9demment, mais avec des valeurs sous forme d'objets ;\n\n\nvoid set(List\n list);\n : affecte aux attributs de la classe les valeurs provenant d'un tableau de double (ici une liste de 10 chiffres qui correspondent aux 10 dimensions de la classe) ;\n\n\ndouble intersectionArea(Primitive p);\n : \u00e9value la surface de l'intersection 2D avec une autre primitive (ici avec d'autres b\u00e2timents en L) ;\n\n\nGeometry toGeometry();\n : convertit la forme en g\u00e9om\u00e9trie 2D JTS (ici l'emprise 2D du b\u00e2timent, la conversion JTS permet d'optimiser les temps de calcul par rapport \u00e0 l'utilisation de g\u00e9om\u00e9tries GeOxygene) ;\n\n\ndouble getArea();\n : l'aire 2D de l'emprise de la forme.\n\n\n\n\nLa classe \nLBuildingWithRoof\n impl\u00e9mente cette interface \u00e0 travers la classe \nAbstractSimpleBuilding\n. Elle impl\u00e9mente \u00e9galement l'interface  \nfr.ign.cogit.simplu3d.rjmcmc.generic.object.ISimPLU3DPrimitive\n qui est n\u00e9cessaire pour pouvoir appliquer le v\u00e9rificateur de forme. Cela n\u00e9cessite l'impl\u00e9mentation de trois m\u00e9thodes :\n\n\n\n\ndouble getHeight();\n : la hauteur maximale de la forme ;\n\n\ndouble getVolume();\n : le volume de la forme ;\n\n\nIGeometry generated3DGeom();\n renvoie une g\u00e9om\u00e9trie GeOXygene3D de la forme, utile pour la v\u00e9rification de r\u00e8gles ou pour l'export des donn\u00e9es.\n\n\n\n\nD\u00e9finition d'une classe de constructeur\n\uf0c1\n\n\nIl s'agit de la classe \nfr.ign.cogit.simplu3d.rjmcmc.paramshp.builder.LBuildingWithRoofBuilder\n qui \u00e9tend la classe de la librjmcmc4j \nfr.ign.mpp.kernelObjectBuilder\n cela implique l'impl\u00e9mentation de 3 m\u00e9thodes :\n\n\n\n\nT build(double[] val);\n : instance un objet de la classe param\u00e9tr\u00e9e (ici LBuildingWithRoof) \u00e0 partir d'un tableau de valeurs de double ;\n\n\nvoid setCoordinates(T t, double[] val);\n : affecte les coordonn\u00e9es d'un tableau de doubles \u00e0 un objet de la classe param\u00e9tr\u00e9e ;\n\n\nint size();\n : la dimension de la taille des objets construits par le constructeur (ici 10).\n\n\n\n\nD\u00e9finition de l'optimiseur\n\uf0c1\n\n\nL'optimiseur est d\u00e9fini dans la classe \nfr.ign.cogit.simplu3d.rjmcmc.paramshp.optimizer. OptimisedLShapeDirectRejection\n dans le projet SimPLU3D. L'\u00e9tape peut sembler complexe car le code de la classe est tr\u00e8s long, n\u00e9anmoins, comme presque toutes les m\u00e9thodes \u00e0 d\u00e9finir sont les m\u00eames que celles  utilis\u00e9e pour simuler des formes compos\u00e9es de bo\u00eetes (\nfr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.cuboid.OptimisedBuildingsCuboidFinalDirectRejection\n) mais param\u00e9tr\u00e9es avec la classe \nLBuildingWithRoof\n.\n\n\nLa seule m\u00e9thode significativement diff\u00e9rente est \ncreate_sampler\n qui cr\u00e9\u00e9 l'\u00e9chantillonneur de b\u00e2timents en L. L'impl\u00e9mentation de cette m\u00e9thode est similaire \u00e0 celle des bo\u00eetes avec la d\u00e9finition des intervalles de tirage, du constructeur d'objets et des noyaux de modification. Le code de cette m\u00e9thode est repris et comment\u00e9 ci-dessous :\n\n\n\n    /**\n     *\n     * @param rng     a random generator\n     * @param p       a json parameter files\n     * @param bpU     a basic property unit\n     * @param pred    a predicate to check the rules\n     * @param polygon a polygon that contains al the cuboid\n     * @return a sampler for the optimization process\n     */\n    public Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> create_sampler(\n            RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU,\n            ConfigurationModificationPredicate<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred,\n            IGeometry polygon) {\n\n        // On cr\u00e9\u00e9 les bornes min et max pour le sampler (10 param\u00e8tres dans le\n        // cas du LBuildingWithRoof)\n        IEnvelope env = polygon.envelope();\n\n        double xmin = env.getLowerCorner().getX();\n        double xmax = env.getUpperCorner().getX();\n\n        double ymin = env.getLowerCorner().getY();\n        double ymax = env.getUpperCorner().getY();\n\n        double l1min = p.getDouble(\"l1min\");\n        double l1max = p.getDouble(\"l1max\");\n\n        double l2min = p.getDouble(\"l2min\");\n        double l2max = p.getDouble(\"l2max\");\n\n        double h1min = p.getDouble(\"h1min\");\n        double h1max = p.getDouble(\"h1max\");\n\n        double h2min = p.getDouble(\"h2min\");\n        double h2max = p.getDouble(\"h2max\");\n\n        double heightToTopMin = p.getDouble(\"heightToTopMin\");\n        double heightToTopgMax = p.getDouble(\"heightToTopgMax\");\n\n        double orientationMin = 0;\n        double orientationMax =  Math.PI;\n\n        double heightgutterMin = p.getDouble(\"heightgutterMin\");\n        ;\n        double heightguterrMax = p.getDouble(\"heightgutterMax\");\n        ;\n\n        double shiftMin = 0;\n        double shiftMax = 1;\n\n        // A priori on red\u00e9fini le constructeur de l'objet\n        // A priori on red\u00e9fini le constructeur de l'objet\n        LBuildingWithRoofBuilder builder = new LBuildingWithRoofBuilder();\n\n        // On initialise la surface sur laquelle on fait la simulation\n        if (samplingSurface == null) {\n            samplingSurface = bpU.getPol2D();\n        }\n\n        // On initialise l'espace sur lequel on va calculer les objets\n        // (normalement tu as juste \u00e0 changer le nom des classes)\n        UniformBirth<LBuildingWithRoof> birth = new UniformBirth<LBuildingWithRoof>(rng,\n                new LBuildingWithRoof(xmin, ymin, l1min, l2min, h1min, h2min, heightToTopMin, orientationMin,\n                        heightgutterMin, shiftMin),\n                new LBuildingWithRoof(xmax, ymax, l1max, l2max, h1max, h2max, heightToTopgMax, orientationMax,\n                        heightguterrMax, shiftMax),\n                builder, TransformToSurface.class, (IGeometry) polygon);\n\n        // La distribution de poisson qui drive le nombre total d'objets\n        PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\"));\n\n        // Le sampler qui d\u00e9termine comment on tire al\u00e9atoirement un objet dans\n        // l'espace d\u00e9fini\n        DirectSampler<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> ds = new DirectRejectionSampler<>(\n                distribution, birth, pred);\n\n        // Probabilit\u00e9 de naissance-morts modifications\n        List<Kernel<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>>> kernels = new ArrayList<>(\n                3);\n        KernelFactory<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> factory = new KernelFactory<>();\n\n        // On liste les kernels, pour le premier, tu devrais probablement le\n        // d\u00e9finir toi ....\n        kernels.add(\n                factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\"));\n        double amplitudeMove = p.getDouble(\"amplitudeMove\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveLShapeBuilding(amplitudeMove), 0.2,\n                \"Move\"));\n\n        // Pour les autres, le ChangeValue peut \u00eatre utiliser (attention, le\n        // deuxi\u00e8me arguement est la taille de ton builder +1)\n        // car il utilise un tableau pour stocker les param\u00e8tres et le +1 est\n        // pour stocker de mani\u00e8re temporaire le tirage al\u00e9atoire\n        double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 2), 0.2, \"h1Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 3), 0.2, \"h2Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 4), 0.2, \"l1Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 5), 0.2, \"l2Change\"));\n\n        double amplitudeHeight = p.getDouble(\"amplitudeHeight\");\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeHeight, builder.size() + 1, 6), 0.2, \"heightChange\"));\n\n        double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180;\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeRotate, builder.size() + 1, 7), 0.2, \"Rotate\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeHeight, builder.size() + 1, 8), 0.2, \"changeHeightGutter\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(0.1, builder.size() + 1, 9),\n                0.2, \"changeShift\"));\n\n        // On instancie le sampler avec tous les objets.\n        Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> s = new GreenSamplerBlockTemperature<>(\n                rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels);\n        return s;\n    }\n\n\n\n\nImpl\u00e9mentation de l'ex\u00e9cution\n\uf0c1\n\n\nLe code ex\u00e9cut\u00e9 se trouve dans la classe \nfr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection\n du projet SimPLU3D-tutoriel. Les diff\u00e9rences par rapport \u00e0 la simulation basique de formes compos\u00e9es de bo\u00eetes sont :\n- l'utilisation du nouvel optimiseur ;\n- la prise en compte d'un autre fichier de configurations, le b\u00e2timent en L ayant besoin de la d\u00e9finition de plus d'intervalles de valeurs ;\n- un code sp\u00e9cifique pour \u00e9crire les sorties des formes.\n\n\nOn peut noter que le v\u00e9rificateur de r\u00e8gles utilis\u00e9 est le m\u00eame que pour la simulation de formes compos\u00e9es de bo\u00eetes et qu'il n'est pas n\u00e9cessaire de le d\u00e9finir gr\u00e2ce aux interfaces impl\u00e9ment\u00e9es.\n\n\n    // Step 0 ; Defining an output existing folder\n        String outputFolder = \"/tmp/\";\n\n        // Step 1 : Creating the geographic environment using the repository that\n        // contains the data\n\n        // Load default environment (data are in resource directory)\n        Environnement env = LoaderSHP.loadNoDTM(new File(\n                BasicParametricShapeSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath()));\n\n        // Select a parcel on which generation is proceeded\n        BasicPropertyUnit bPU = env.getBpU().get(2);\n\n        // Step 2 : Defining the regulation that will be applied during the simulation\n\n        // Rules parameters.8\n        // Distance to road\n        double distReculVoirie = 0;\n        // Distance to bottom of the parcel\n        double distReculFond = 0;\n        // Distance to lateral parcel limits\n        double distReculLat = 0;\n        // Distance between two buildings of a parcel\n        double distanceInterBati = 3;\n        // Maximal ratio built area\n        double maximalCES = 1;\n\n        // Instanciation of a predicate class\n        // Same as in the first sample fr.ign.simplu3d.firstSimulation.BasicSimulator\n        // As LBuildingWithRoof and Cuboid extends ISimPLU3DPrimitive\n        SamplePredicate<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred = new SamplePredicate<>(\n                bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES);\n\n        // Step 3 : Defining the sampler that will be applied during the simulation\n        // Instantiation of the sampler\n        OptimisedLShapeDirectRejection optimisedLShapedSampler = new OptimisedLShapeDirectRejection();\n\n        // Loading the parameters for the building shape generation\n        String folderName = BasicParametricShapeSimulator.class.getClassLoader()\n                .getResource(\"firstSimulation/scenario/\").getPath();\n        // We use a specific scenario dedicated to LShape\n        String fileName = \"paramsLShape.json\";\n        SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName));\n\n        // Run of the optimisation on a parcel with the predicate\n        GraphConfiguration<? extends ISimPLU3DPrimitive> cc = optimisedLShapedSampler.process(bPU, p, env, bPU.getId(),\n                pred, bPU.getGeom());\n\n        // 4 - Writing the output\n        IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>();\n        for (GraphVertex<? extends ISimPLU3DPrimitive> v : cc.getGraph().vertexSet()) {\n\n            IFeature feat = new DefaultFeature(v.getValue().generated3DGeom());\n            // On ajoute des attributs aux entit\u00e9s (dimension des objets)\n            AttributeManager.addAttribute(feat, \"Info\", v.getValue().toString(), \"Double\");\n\n            iFeatC.add(feat);\n\n        }\n\n        // Writng the shapefile from the collection\n    ShapefileWriter.write(iFeatC, outputFolder + \"out.shp\");",
            "title": "Custom shape"
        },
        {
            "location": "/generator/custom-shape/#generation-de-batiments-en-l",
            "text": "L'objectif de cette partie est de pr\u00e9senter un code permettant de g\u00e9n\u00e9rer des b\u00e2timents en forme de L avec un toit typifi\u00e9 et de d\u00e9crire les \u00e9tapes \u00e0 suivre pour g\u00e9n\u00e9rer des configurations avec d'autres types de forme \u00e0 partir du simulateur basique pr\u00e9sent\u00e9 dans la  premi\u00e8re exp\u00e9rimentation .",
            "title": "G\u00e9n\u00e9ration de b\u00e2timents en L"
        },
        {
            "location": "/generator/custom-shape/#code-exemple",
            "text": "L'ex\u00e9cution du code pr\u00e9sent\u00e9 ici se trouve dans la classe   fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection  du projet SimPLU3D-tutorial.   La classe de g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e (pr\u00e9sent\u00e9e dans le sch\u00e9ma pr\u00e9c\u00e9dent) comporte 10 dimensions :   x  : coordonn\u00e9e x du centre de la forme ;  y  : coordonn\u00e9e y du centre de la forme ;  l1  : longueur de la forme hors barre du L ;  l2  : longueur de la barre du L ;  h1  : hauteur totale de la forme hors barre du L;  h2  : hauteur totale de la barre du L;  height  : hauteur maximale de la forme ;  orientation  : orientation (azimut) du L ;  hgutter  : hauteur \u00e0 la goutti\u00e8re.  shift  : pente du toit aux extr\u00e9mit\u00e9s du L (entre 0 pas de pente et 1 pente jusqu'au milieu de la forme).",
            "title": "Code exemple"
        },
        {
            "location": "/generator/custom-shape/#definition-de-la-classe-representant-la-forme",
            "text": "La classe d\u00e9finissant la g\u00e9om\u00e9trie simul\u00e9e est la classe  fr.ign.cogit.simplu3d.rjmcmc.paramshp.geometry.impl.LBuildingWithRoof  du projet SimPLU3D. Cette classe impl\u00e9mente la classe  AbstractSimpleBuilding  (comme nous simulons un objet de type b\u00e2timent, comme c'est le cas pour la classe  Cubboid ). Cela implique l'instanciation de 3 niveaux de classes abstraites et d'interfaces :\n-  la classe  fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.impl.AbstractSimpleBuilding  de  SimPLU3D-rules : qui contient les informations n\u00e9cessaires pour mod\u00e9liser un objet de type b\u00e2timent de SimPLU3D ;\n- l'interface  fr.ign.cogit.simplu3d.rjmcmc.generic.objectISimPLU3DPrimitive  : qui contient les m\u00e9thodes propres \u00e0 SimPLU3D concernant l'optimisation de forme ;\n- l'interface  de la librjmcmc4j  fr.ign.geometry.Primitive  : qui contient les informations n\u00e9cessaires pour simuler des objets g\u00e9ographiques avec la librjmcmc4j.\nSeule l'impl\u00e9mentation de la derni\u00e8re interface est n\u00e9cessaire pour g\u00e9n\u00e9rer des formes, les deux autres niveaux enrichissent les m\u00e9thodes accessibles pour la v\u00e9rification des r\u00e8gles et la d\u00e9finition de la fonction d'optimisation. Elles facilitent \u00e9galement la r\u00e9-utilisation du code de la premi\u00e8re simulation.  L'impl\u00e9mentation de l'interface  Primitive   n\u00e9cessite la d\u00e9finition des m\u00e9thodes suivantes :   int size();  : renvoie la taille de la dimension de la forme (ici 10 pour le b\u00e2timent en L) ;  double[] toArray()  :  traduit les attributs de la classe en un tableau de double (il s'agit ici d'un tableau de dimension 10 contenant les valeurs des diff\u00e9rentes dimensions de la forme) ;  Object[] getArray();  : m\u00eame m\u00e9thode que pr\u00e9c\u00e9demment, mais avec des valeurs sous forme d'objets ;  void set(List  list);  : affecte aux attributs de la classe les valeurs provenant d'un tableau de double (ici une liste de 10 chiffres qui correspondent aux 10 dimensions de la classe) ;  double intersectionArea(Primitive p);  : \u00e9value la surface de l'intersection 2D avec une autre primitive (ici avec d'autres b\u00e2timents en L) ;  Geometry toGeometry();  : convertit la forme en g\u00e9om\u00e9trie 2D JTS (ici l'emprise 2D du b\u00e2timent, la conversion JTS permet d'optimiser les temps de calcul par rapport \u00e0 l'utilisation de g\u00e9om\u00e9tries GeOxygene) ;  double getArea();  : l'aire 2D de l'emprise de la forme.   La classe  LBuildingWithRoof  impl\u00e9mente cette interface \u00e0 travers la classe  AbstractSimpleBuilding . Elle impl\u00e9mente \u00e9galement l'interface   fr.ign.cogit.simplu3d.rjmcmc.generic.object.ISimPLU3DPrimitive  qui est n\u00e9cessaire pour pouvoir appliquer le v\u00e9rificateur de forme. Cela n\u00e9cessite l'impl\u00e9mentation de trois m\u00e9thodes :   double getHeight();  : la hauteur maximale de la forme ;  double getVolume();  : le volume de la forme ;  IGeometry generated3DGeom();  renvoie une g\u00e9om\u00e9trie GeOXygene3D de la forme, utile pour la v\u00e9rification de r\u00e8gles ou pour l'export des donn\u00e9es.",
            "title": "D\u00e9finition de la classe repr\u00e9sentant la forme"
        },
        {
            "location": "/generator/custom-shape/#definition-dune-classe-de-constructeur",
            "text": "Il s'agit de la classe  fr.ign.cogit.simplu3d.rjmcmc.paramshp.builder.LBuildingWithRoofBuilder  qui \u00e9tend la classe de la librjmcmc4j  fr.ign.mpp.kernelObjectBuilder  cela implique l'impl\u00e9mentation de 3 m\u00e9thodes :   T build(double[] val);  : instance un objet de la classe param\u00e9tr\u00e9e (ici LBuildingWithRoof) \u00e0 partir d'un tableau de valeurs de double ;  void setCoordinates(T t, double[] val);  : affecte les coordonn\u00e9es d'un tableau de doubles \u00e0 un objet de la classe param\u00e9tr\u00e9e ;  int size();  : la dimension de la taille des objets construits par le constructeur (ici 10).",
            "title": "D\u00e9finition d'une classe de constructeur"
        },
        {
            "location": "/generator/custom-shape/#definition-de-loptimiseur",
            "text": "L'optimiseur est d\u00e9fini dans la classe  fr.ign.cogit.simplu3d.rjmcmc.paramshp.optimizer. OptimisedLShapeDirectRejection  dans le projet SimPLU3D. L'\u00e9tape peut sembler complexe car le code de la classe est tr\u00e8s long, n\u00e9anmoins, comme presque toutes les m\u00e9thodes \u00e0 d\u00e9finir sont les m\u00eames que celles  utilis\u00e9e pour simuler des formes compos\u00e9es de bo\u00eetes ( fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.cuboid.OptimisedBuildingsCuboidFinalDirectRejection ) mais param\u00e9tr\u00e9es avec la classe  LBuildingWithRoof .  La seule m\u00e9thode significativement diff\u00e9rente est  create_sampler  qui cr\u00e9\u00e9 l'\u00e9chantillonneur de b\u00e2timents en L. L'impl\u00e9mentation de cette m\u00e9thode est similaire \u00e0 celle des bo\u00eetes avec la d\u00e9finition des intervalles de tirage, du constructeur d'objets et des noyaux de modification. Le code de cette m\u00e9thode est repris et comment\u00e9 ci-dessous :  \n    /**\n     *\n     * @param rng     a random generator\n     * @param p       a json parameter files\n     * @param bpU     a basic property unit\n     * @param pred    a predicate to check the rules\n     * @param polygon a polygon that contains al the cuboid\n     * @return a sampler for the optimization process\n     */\n    public Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> create_sampler(\n            RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU,\n            ConfigurationModificationPredicate<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred,\n            IGeometry polygon) {\n\n        // On cr\u00e9\u00e9 les bornes min et max pour le sampler (10 param\u00e8tres dans le\n        // cas du LBuildingWithRoof)\n        IEnvelope env = polygon.envelope();\n\n        double xmin = env.getLowerCorner().getX();\n        double xmax = env.getUpperCorner().getX();\n\n        double ymin = env.getLowerCorner().getY();\n        double ymax = env.getUpperCorner().getY();\n\n        double l1min = p.getDouble(\"l1min\");\n        double l1max = p.getDouble(\"l1max\");\n\n        double l2min = p.getDouble(\"l2min\");\n        double l2max = p.getDouble(\"l2max\");\n\n        double h1min = p.getDouble(\"h1min\");\n        double h1max = p.getDouble(\"h1max\");\n\n        double h2min = p.getDouble(\"h2min\");\n        double h2max = p.getDouble(\"h2max\");\n\n        double heightToTopMin = p.getDouble(\"heightToTopMin\");\n        double heightToTopgMax = p.getDouble(\"heightToTopgMax\");\n\n        double orientationMin = 0;\n        double orientationMax =  Math.PI;\n\n        double heightgutterMin = p.getDouble(\"heightgutterMin\");\n        ;\n        double heightguterrMax = p.getDouble(\"heightgutterMax\");\n        ;\n\n        double shiftMin = 0;\n        double shiftMax = 1;\n\n        // A priori on red\u00e9fini le constructeur de l'objet\n        // A priori on red\u00e9fini le constructeur de l'objet\n        LBuildingWithRoofBuilder builder = new LBuildingWithRoofBuilder();\n\n        // On initialise la surface sur laquelle on fait la simulation\n        if (samplingSurface == null) {\n            samplingSurface = bpU.getPol2D();\n        }\n\n        // On initialise l'espace sur lequel on va calculer les objets\n        // (normalement tu as juste \u00e0 changer le nom des classes)\n        UniformBirth<LBuildingWithRoof> birth = new UniformBirth<LBuildingWithRoof>(rng,\n                new LBuildingWithRoof(xmin, ymin, l1min, l2min, h1min, h2min, heightToTopMin, orientationMin,\n                        heightgutterMin, shiftMin),\n                new LBuildingWithRoof(xmax, ymax, l1max, l2max, h1max, h2max, heightToTopgMax, orientationMax,\n                        heightguterrMax, shiftMax),\n                builder, TransformToSurface.class, (IGeometry) polygon);\n\n        // La distribution de poisson qui drive le nombre total d'objets\n        PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\"));\n\n        // Le sampler qui d\u00e9termine comment on tire al\u00e9atoirement un objet dans\n        // l'espace d\u00e9fini\n        DirectSampler<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> ds = new DirectRejectionSampler<>(\n                distribution, birth, pred);\n\n        // Probabilit\u00e9 de naissance-morts modifications\n        List<Kernel<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>>> kernels = new ArrayList<>(\n                3);\n        KernelFactory<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> factory = new KernelFactory<>();\n\n        // On liste les kernels, pour le premier, tu devrais probablement le\n        // d\u00e9finir toi ....\n        kernels.add(\n                factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\"));\n        double amplitudeMove = p.getDouble(\"amplitudeMove\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveLShapeBuilding(amplitudeMove), 0.2,\n                \"Move\"));\n\n        // Pour les autres, le ChangeValue peut \u00eatre utiliser (attention, le\n        // deuxi\u00e8me arguement est la taille de ton builder +1)\n        // car il utilise un tableau pour stocker les param\u00e8tres et le +1 est\n        // pour stocker de mani\u00e8re temporaire le tirage al\u00e9atoire\n        double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\");\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 2), 0.2, \"h1Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 3), 0.2, \"h2Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 4), 0.2, \"l1Change\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 5), 0.2, \"l2Change\"));\n\n        double amplitudeHeight = p.getDouble(\"amplitudeHeight\");\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeHeight, builder.size() + 1, 6), 0.2, \"heightChange\"));\n\n        double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180;\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeRotate, builder.size() + 1, 7), 0.2, \"Rotate\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder,\n                new ChangeValue(amplitudeHeight, builder.size() + 1, 8), 0.2, \"changeHeightGutter\"));\n\n        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(0.1, builder.size() + 1, 9),\n                0.2, \"changeShift\"));\n\n        // On instancie le sampler avec tous les objets.\n        Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> s = new GreenSamplerBlockTemperature<>(\n                rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels);\n        return s;\n    }",
            "title": "D\u00e9finition de l'optimiseur"
        },
        {
            "location": "/generator/custom-shape/#implementation-de-lexecution",
            "text": "Le code ex\u00e9cut\u00e9 se trouve dans la classe  fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection  du projet SimPLU3D-tutoriel. Les diff\u00e9rences par rapport \u00e0 la simulation basique de formes compos\u00e9es de bo\u00eetes sont :\n- l'utilisation du nouvel optimiseur ;\n- la prise en compte d'un autre fichier de configurations, le b\u00e2timent en L ayant besoin de la d\u00e9finition de plus d'intervalles de valeurs ;\n- un code sp\u00e9cifique pour \u00e9crire les sorties des formes.  On peut noter que le v\u00e9rificateur de r\u00e8gles utilis\u00e9 est le m\u00eame que pour la simulation de formes compos\u00e9es de bo\u00eetes et qu'il n'est pas n\u00e9cessaire de le d\u00e9finir gr\u00e2ce aux interfaces impl\u00e9ment\u00e9es.      // Step 0 ; Defining an output existing folder\n        String outputFolder = \"/tmp/\";\n\n        // Step 1 : Creating the geographic environment using the repository that\n        // contains the data\n\n        // Load default environment (data are in resource directory)\n        Environnement env = LoaderSHP.loadNoDTM(new File(\n                BasicParametricShapeSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath()));\n\n        // Select a parcel on which generation is proceeded\n        BasicPropertyUnit bPU = env.getBpU().get(2);\n\n        // Step 2 : Defining the regulation that will be applied during the simulation\n\n        // Rules parameters.8\n        // Distance to road\n        double distReculVoirie = 0;\n        // Distance to bottom of the parcel\n        double distReculFond = 0;\n        // Distance to lateral parcel limits\n        double distReculLat = 0;\n        // Distance between two buildings of a parcel\n        double distanceInterBati = 3;\n        // Maximal ratio built area\n        double maximalCES = 1;\n\n        // Instanciation of a predicate class\n        // Same as in the first sample fr.ign.simplu3d.firstSimulation.BasicSimulator\n        // As LBuildingWithRoof and Cuboid extends ISimPLU3DPrimitive\n        SamplePredicate<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred = new SamplePredicate<>(\n                bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES);\n\n        // Step 3 : Defining the sampler that will be applied during the simulation\n        // Instantiation of the sampler\n        OptimisedLShapeDirectRejection optimisedLShapedSampler = new OptimisedLShapeDirectRejection();\n\n        // Loading the parameters for the building shape generation\n        String folderName = BasicParametricShapeSimulator.class.getClassLoader()\n                .getResource(\"firstSimulation/scenario/\").getPath();\n        // We use a specific scenario dedicated to LShape\n        String fileName = \"paramsLShape.json\";\n        SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName));\n\n        // Run of the optimisation on a parcel with the predicate\n        GraphConfiguration<? extends ISimPLU3DPrimitive> cc = optimisedLShapedSampler.process(bPU, p, env, bPU.getId(),\n                pred, bPU.getGeom());\n\n        // 4 - Writing the output\n        IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>();\n        for (GraphVertex<? extends ISimPLU3DPrimitive> v : cc.getGraph().vertexSet()) {\n\n            IFeature feat = new DefaultFeature(v.getValue().generated3DGeom());\n            // On ajoute des attributs aux entit\u00e9s (dimension des objets)\n            AttributeManager.addAttribute(feat, \"Info\", v.getValue().toString(), \"Double\");\n\n            iFeatC.add(feat);\n\n        }\n\n        // Writng the shapefile from the collection\n    ShapefileWriter.write(iFeatC, outputFolder + \"out.shp\");",
            "title": "Impl\u00e9mentation de l'ex\u00e9cution"
        },
        {
            "location": "/generator/intro/",
            "text": "Introduction au g\u00e9n\u00e9rateur de formes\n\uf0c1\n\n\nL'objectif de cette section est de d\u00e9crire le code de g\u00e9n\u00e9ration de formes b\u00e2ties. La g\u00e9n\u00e9ration de formes b\u00e2ties se base sur une m\u00e9thode d'optimisation du recuit-simul\u00e9 transdimensionnel (en utilisant la biblioth\u00e8que \nlibrjmcmc4j\n).\n\n\nLes codes qui permettent la g\u00e9n\u00e9ration de formes se trouvent dans le projet \nSimPLU3D\n et la javadoc est d\u00e9ploy\u00e9e \u00e0 l'adresse suivante :  \nhttps://SimPLU3D.github.io/simplu3D/\n. Le package principal (\nfr.ign.cogit.simplu3d.rjmcmc\n) de SimPLU3D est compos\u00e9 de sous-packages en fonction des types de formes utilis\u00e9es (\ngeneric\n pour toutes les formes, \ncuboid\n pour les bo\u00eetes, \nparamShp\n pour des formes param\u00e9triques et \ntrapezoid\n pour les trapezes).\n\n\nDans cette section, nous pr\u00e9senterons tout d'abord la m\u00e9thode de \ng\u00e9n\u00e9ration des formes b\u00e2ties\n, puis comment il est possible de :\n\n\n\n\nParam\u00e9trer l'algorithme\n pour la g\u00e9n\u00e9ration de formes compos\u00e9es de bo\u00eetes ;\n\n\nModifier la fonction d'optimisation\n ;\n\n\nG\u00e9n\u00e9rer des formes b\u00e2ties compos\u00e9es de g\u00e9om\u00e9tries autres que des cubo\u00efdes\n.",
            "title": "Intro"
        },
        {
            "location": "/generator/intro/#introduction-au-generateur-de-formes",
            "text": "L'objectif de cette section est de d\u00e9crire le code de g\u00e9n\u00e9ration de formes b\u00e2ties. La g\u00e9n\u00e9ration de formes b\u00e2ties se base sur une m\u00e9thode d'optimisation du recuit-simul\u00e9 transdimensionnel (en utilisant la biblioth\u00e8que  librjmcmc4j ).  Les codes qui permettent la g\u00e9n\u00e9ration de formes se trouvent dans le projet  SimPLU3D  et la javadoc est d\u00e9ploy\u00e9e \u00e0 l'adresse suivante :   https://SimPLU3D.github.io/simplu3D/ . Le package principal ( fr.ign.cogit.simplu3d.rjmcmc ) de SimPLU3D est compos\u00e9 de sous-packages en fonction des types de formes utilis\u00e9es ( generic  pour toutes les formes,  cuboid  pour les bo\u00eetes,  paramShp  pour des formes param\u00e9triques et  trapezoid  pour les trapezes).  Dans cette section, nous pr\u00e9senterons tout d'abord la m\u00e9thode de  g\u00e9n\u00e9ration des formes b\u00e2ties , puis comment il est possible de :   Param\u00e9trer l'algorithme  pour la g\u00e9n\u00e9ration de formes compos\u00e9es de bo\u00eetes ;  Modifier la fonction d'optimisation  ;  G\u00e9n\u00e9rer des formes b\u00e2ties compos\u00e9es de g\u00e9om\u00e9tries autres que des cubo\u00efdes .",
            "title": "Introduction au g\u00e9n\u00e9rateur de formes"
        },
        {
            "location": "/generator/principe/",
            "text": "Principe du fonctionnement du g\u00e9n\u00e9rateur de formes\n\uf0c1\n\n\nDans cette partie nous introduirons les diff\u00e9rents aspects concernant la g\u00e9n\u00e9ration de formes dans SimPLU3D et la mani\u00e8re avec laquelle l'algorithme du recuit-simul\u00e9 est utilis\u00e9.\n\n\nConfiguration b\u00e2tie\n\uf0c1\n\n\nDans SimPLU3D, une configuration b\u00e2tie est compos\u00e9e d'un ensemble de g\u00e9om\u00e9tries param\u00e9triques. Une g\u00e9om\u00e9trie est dite param\u00e9trique quand on peut la d\u00e9crire \u00e0 travers un vecteur de dimension constante. Dans la plupart des exp\u00e9rimentations de SimPLU3D, comme dans l'exemple de la premi\u00e8re simulation, les g\u00e9om\u00e9tries param\u00e9triques manipul\u00e9es sont des bo\u00eetes. Dans ce cas, s'agit d'une g\u00e9om\u00e9trie de 6 dimensions d\u00e9crite par le vecteur \nb\n = (\nx\n, \ny\n, \nl\n, \nw\n, \nh\n, \n\u03b8\n). N\u00e9anmoins, il est tout \u00e0 fait possible d'utiliser d'autres types de g\u00e9om\u00e9tries param\u00e9triques comme nous le verrons dans la section sur la \npersonnalisation des formes g\u00e9n\u00e9r\u00e9es\n.\n\n\n\n\nG\u00e9n\u00e9ration de configurations b\u00e2ties\n\uf0c1\n\n\nLa g\u00e9n\u00e9ration de formes b\u00e2ties avec SimPLU3D se base sur la technique du recuit-simul\u00e9 transdimensionnel. Le recuit simul\u00e9 est une technique d'optimisation et le fait que l'approche soit transdimensionnel indique que c'est le syst\u00e8me qui d\u00e9termine le nombre d'objets n\u00e9cessaires pour atteindre l'objectif.\n\n\nAinsi, si on consid\u00e8re une fonction d'optimisation \nf\n, comme le volume, le recuit simul\u00e9 d\u00e9termine les \nn\n bo\u00eetes et leurs param\u00e8tres qui permettent de produire la configuration b\u00e2tie la plus volumineuse possible.\n\n\n\n\nD\u00e9roulement de l'algorithme\n\uf0c1\n\n\n\n\nL'algorithme est un algorithme it\u00e9ratif. \u00c0 chaque it\u00e9ration, on consid\u00e8re une configuration b\u00e2tie courante. Le syst\u00e8me choisit une modification parmi les noyaux de proposition de modification disponibles (dans l'exemple, le noyau d'ajout est s\u00e9lectionn\u00e9 pour ajouter une nouvelle bo\u00eete). Ensuite, une probabilit\u00e9 d'acception est d\u00e9termin\u00e9e suivant la th\u00e9orie du recuit simul\u00e9e. Elle prend en compte les scores des configurations avant et apr\u00e8s modification et la temp\u00e9rature courante (il s'agit d'une valeur qui d\u00e9cro\u00eet au fur et \u00e0 mesure des it\u00e9rations). Ainsi, il existe une certaine probabilit\u00e9 pour que cette modification soit rejet\u00e9e (1 - \u03b1(t,s,s\u2019)) et une certaine probabilit\u00e9 pour que la modification soit accept\u00e9e (\u03b1(t,s,s\u2019)). Si la configuration est accept\u00e9e, on s'assure qu'elle respecte les r\u00e8gles morphologiques, si c'est le cas elle remplace la configuration courante sinon la modification est rejet\u00e9e.\n\n\nImpl\u00e9mentation de l'algorithme\n\uf0c1\n\n\nL'impl\u00e9mentation de l'algorithme est effectu\u00e9e gr\u00e2ce \u00e0 la biblioth\u00e8que g\u00e9n\u00e9rique et OpenSource \nlibrjmcmc4j\n. Pour en savoir plus, vous pouvez consulter l'article :\n\n\n\n\nBr\u00e9dif, M., Tournaire, O.\n, Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. (\nhttps://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf\n)\n\n\n\n\nDans l'exemple de la \npremi\u00e8re simulation\n, les \u00e9tapes de l'algorithme, pr\u00e9sent\u00e9s dans le sch\u00e9ma pr\u00e9c\u00e9dent, s'effectue dans la m\u00e9thode \nprocess()\n de la classe \nOptimisedBuildingsCuboidFinalDirectRejection\n. L'algorithme peut se d\u00e9composer en 3 phases :\n\n\n\n\n\u00c9tape 1\n : \nla d\u00e9finition des configurations b\u00e2ties et des modifications appliqu\u00e9es\n, ce qui correspond aux bo\u00eetes \"Classe de g\u00e9om\u00e9trie param\u00e9trique\" et \"Noyaux de propositions\" du sch\u00e9ma ;\n\n\n\u00c9tape 2\n : \nla d\u00e9finition des param\u00e8tres de l'algorithme en lui-m\u00eame\n, c'est \u00e0-dire la fonction d'optimisation et les conditions initiales et d'arr\u00eat ;\n\n\n\u00c9tape 3\n : \nla mise en place de visiteurs\n, c'est \u00e0 dire d'objets qui produiront des sorties au fur et \u00e0 mesure de la simulation. Ils sont pr\u00e9sent\u00e9s dans une autre section mais n'influent pas sur le processus d'optimisation) ;\n\n\n\u00c9tape 4\n : l'ex\u00e9cution de la simulation.\n\n\n\n\n/**\n * Process the generation of the optimization\n * @param bpu                    Basic property unit\n * @param geom                   The geometry in which the centroid of the\n *                               cuboids will be generated\n * @param p                      the parameters\n * @param env                    the environement\n * @param id                     the id of the experiments\n * @param pred                   the rules to check\n * @return a set of cuboid as a graph\n */\npublic GraphConfiguration<Cuboid> process(BasicPropertyUnit bpu, IGeometry geom, SimpluParameters p,\n    Environnement env, int id,\n    ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred,\n    List<Visitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> lSupplementaryVisitors) {\n\n    //Step 1 :\n\n    // Sampler creation (definition of the class and of the kernel modifications)\n    // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications)\n    Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p,\n    bpu, pred, geom);\n\n    //Step 2 : Preparation of the optimizer\n    //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur\n\n    //Initializing the configuration (optimisation function + set of cuboid)\n    //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante\n    GraphConfiguration<Cuboid> conf = null;\n    try {\n      conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // Temperature initialization\n    //Initialization de la fonction de la temp\u00e9rature\n    Schedule<SimpleTemperature> sch = create_schedule(p);\n\n\n    //The end test condition\n    end = create_end_test(p);\n\n    //Step 3 : Visitor instanciation\n    //\u00c9tape 3 : Pr\u00e9paration des visiteurs\n\n    //The visitors initialisation\n    PrepareVisitors<Cuboid> pv = new PrepareVisitors<>(env, lSupplementaryVisitors);\n    CompositeVisitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> mVisitor = pv.prepare(p, id);\n\n    //Step 4 : Running the optimization process\n    //\u00c9tape 4 : Ex\u00e9cution de l'optimization\n    SimulatedAnnealing.optimize(Random.random(), conf, samp, sch, end, mVisitor);\n    return conf;\n}",
            "title": "Principe"
        },
        {
            "location": "/generator/principe/#principe-du-fonctionnement-du-generateur-de-formes",
            "text": "Dans cette partie nous introduirons les diff\u00e9rents aspects concernant la g\u00e9n\u00e9ration de formes dans SimPLU3D et la mani\u00e8re avec laquelle l'algorithme du recuit-simul\u00e9 est utilis\u00e9.",
            "title": "Principe du fonctionnement du g\u00e9n\u00e9rateur de formes"
        },
        {
            "location": "/generator/principe/#configuration-batie",
            "text": "Dans SimPLU3D, une configuration b\u00e2tie est compos\u00e9e d'un ensemble de g\u00e9om\u00e9tries param\u00e9triques. Une g\u00e9om\u00e9trie est dite param\u00e9trique quand on peut la d\u00e9crire \u00e0 travers un vecteur de dimension constante. Dans la plupart des exp\u00e9rimentations de SimPLU3D, comme dans l'exemple de la premi\u00e8re simulation, les g\u00e9om\u00e9tries param\u00e9triques manipul\u00e9es sont des bo\u00eetes. Dans ce cas, s'agit d'une g\u00e9om\u00e9trie de 6 dimensions d\u00e9crite par le vecteur  b  = ( x ,  y ,  l ,  w ,  h ,  \u03b8 ). N\u00e9anmoins, il est tout \u00e0 fait possible d'utiliser d'autres types de g\u00e9om\u00e9tries param\u00e9triques comme nous le verrons dans la section sur la  personnalisation des formes g\u00e9n\u00e9r\u00e9es .",
            "title": "Configuration b\u00e2tie"
        },
        {
            "location": "/generator/principe/#generation-de-configurations-baties",
            "text": "La g\u00e9n\u00e9ration de formes b\u00e2ties avec SimPLU3D se base sur la technique du recuit-simul\u00e9 transdimensionnel. Le recuit simul\u00e9 est une technique d'optimisation et le fait que l'approche soit transdimensionnel indique que c'est le syst\u00e8me qui d\u00e9termine le nombre d'objets n\u00e9cessaires pour atteindre l'objectif.  Ainsi, si on consid\u00e8re une fonction d'optimisation  f , comme le volume, le recuit simul\u00e9 d\u00e9termine les  n  bo\u00eetes et leurs param\u00e8tres qui permettent de produire la configuration b\u00e2tie la plus volumineuse possible.",
            "title": "G\u00e9n\u00e9ration de configurations b\u00e2ties"
        },
        {
            "location": "/generator/principe/#deroulement-de-lalgorithme",
            "text": "L'algorithme est un algorithme it\u00e9ratif. \u00c0 chaque it\u00e9ration, on consid\u00e8re une configuration b\u00e2tie courante. Le syst\u00e8me choisit une modification parmi les noyaux de proposition de modification disponibles (dans l'exemple, le noyau d'ajout est s\u00e9lectionn\u00e9 pour ajouter une nouvelle bo\u00eete). Ensuite, une probabilit\u00e9 d'acception est d\u00e9termin\u00e9e suivant la th\u00e9orie du recuit simul\u00e9e. Elle prend en compte les scores des configurations avant et apr\u00e8s modification et la temp\u00e9rature courante (il s'agit d'une valeur qui d\u00e9cro\u00eet au fur et \u00e0 mesure des it\u00e9rations). Ainsi, il existe une certaine probabilit\u00e9 pour que cette modification soit rejet\u00e9e (1 - \u03b1(t,s,s\u2019)) et une certaine probabilit\u00e9 pour que la modification soit accept\u00e9e (\u03b1(t,s,s\u2019)). Si la configuration est accept\u00e9e, on s'assure qu'elle respecte les r\u00e8gles morphologiques, si c'est le cas elle remplace la configuration courante sinon la modification est rejet\u00e9e.",
            "title": "D\u00e9roulement de l'algorithme"
        },
        {
            "location": "/generator/principe/#implementation-de-lalgorithme",
            "text": "L'impl\u00e9mentation de l'algorithme est effectu\u00e9e gr\u00e2ce \u00e0 la biblioth\u00e8que g\u00e9n\u00e9rique et OpenSource  librjmcmc4j . Pour en savoir plus, vous pouvez consulter l'article :   Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf )   Dans l'exemple de la  premi\u00e8re simulation , les \u00e9tapes de l'algorithme, pr\u00e9sent\u00e9s dans le sch\u00e9ma pr\u00e9c\u00e9dent, s'effectue dans la m\u00e9thode  process()  de la classe  OptimisedBuildingsCuboidFinalDirectRejection . L'algorithme peut se d\u00e9composer en 3 phases :   \u00c9tape 1  :  la d\u00e9finition des configurations b\u00e2ties et des modifications appliqu\u00e9es , ce qui correspond aux bo\u00eetes \"Classe de g\u00e9om\u00e9trie param\u00e9trique\" et \"Noyaux de propositions\" du sch\u00e9ma ;  \u00c9tape 2  :  la d\u00e9finition des param\u00e8tres de l'algorithme en lui-m\u00eame , c'est \u00e0-dire la fonction d'optimisation et les conditions initiales et d'arr\u00eat ;  \u00c9tape 3  :  la mise en place de visiteurs , c'est \u00e0 dire d'objets qui produiront des sorties au fur et \u00e0 mesure de la simulation. Ils sont pr\u00e9sent\u00e9s dans une autre section mais n'influent pas sur le processus d'optimisation) ;  \u00c9tape 4  : l'ex\u00e9cution de la simulation.   /**\n * Process the generation of the optimization\n * @param bpu                    Basic property unit\n * @param geom                   The geometry in which the centroid of the\n *                               cuboids will be generated\n * @param p                      the parameters\n * @param env                    the environement\n * @param id                     the id of the experiments\n * @param pred                   the rules to check\n * @return a set of cuboid as a graph\n */\npublic GraphConfiguration<Cuboid> process(BasicPropertyUnit bpu, IGeometry geom, SimpluParameters p,\n    Environnement env, int id,\n    ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred,\n    List<Visitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> lSupplementaryVisitors) {\n\n    //Step 1 :\n\n    // Sampler creation (definition of the class and of the kernel modifications)\n    // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications)\n    Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p,\n    bpu, pred, geom);\n\n    //Step 2 : Preparation of the optimizer\n    //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur\n\n    //Initializing the configuration (optimisation function + set of cuboid)\n    //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante\n    GraphConfiguration<Cuboid> conf = null;\n    try {\n      conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // Temperature initialization\n    //Initialization de la fonction de la temp\u00e9rature\n    Schedule<SimpleTemperature> sch = create_schedule(p);\n\n\n    //The end test condition\n    end = create_end_test(p);\n\n    //Step 3 : Visitor instanciation\n    //\u00c9tape 3 : Pr\u00e9paration des visiteurs\n\n    //The visitors initialisation\n    PrepareVisitors<Cuboid> pv = new PrepareVisitors<>(env, lSupplementaryVisitors);\n    CompositeVisitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> mVisitor = pv.prepare(p, id);\n\n    //Step 4 : Running the optimization process\n    //\u00c9tape 4 : Ex\u00e9cution de l'optimization\n    SimulatedAnnealing.optimize(Random.random(), conf, samp, sch, end, mVisitor);\n    return conf;\n}",
            "title": "Impl\u00e9mentation de l'algorithme"
        },
        {
            "location": "/openmole/intro/",
            "text": "Introduction au couplage SimPLU3D - OpenMOLE\n\uf0c1\n\n\nOpenMOLE \n(https://openmole.org/)\n est une plate-forme d\u00e9di\u00e9e \u00e0 l'exploration de mod\u00e8les de simulation. Cette plate-forme permet \u00e0 travers la distribution de calculs de calibrer ou d'explorer de mani\u00e8re efficace l'espace de param\u00e8tres de mod\u00e8les.\n\n\nCe couplage a \u00e9t\u00e9 utilis\u00e9 pour deux exp\u00e9rimentations : la production des simulations sur de grandes zones et pour la simulation de l'influence de param\u00e8tres de r\u00e8gles sur des formes b\u00e2ties. Ces aspects sont pr\u00e9sent\u00e9s dans l'article suivant :\n\n\n\n\nBrasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017)\n\n\n\n\nCr\u00e9ation d'un plug-in OpenMOLE.\n\uf0c1\n\n\nPour utiliser conjointement les deux projets, il est conseill\u00e9 de cr\u00e9er un \nplug-in OpenMOLE\n. Les diff\u00e9rents couplages  d\u00e9j\u00e0 effectu\u00e9s se trouvent dans le projet \nSimPLU3D-OpenMole\n.\n\n\nDans la suite, nous d\u00e9crivons les \u00e9tapes n\u00e9cessaires \u00e0 la production d'un tel plug-in.\n\n\n1 Cr\u00e9ation du projet Scala\n\uf0c1\n\n\nLe plus simple pour cr\u00e9er le projet Scala est de re-partir d'un exemple existant, en t\u00e9l\u00e9chargeant par exemple, le projet \nSimPLU3D-OpenMole\n.\n\n\nL'organisation du projet est classique, il y a un fichier build.sbt qui d\u00e9crit la mani\u00e8re avec laquelle le projet est construit. Dans celui-l\u00e0, il est d\u00e9j\u00e0 sp\u00e9cifi\u00e9 que l'on cherche \u00e0 compiler un projet OSGI (mani\u00e8re de compiler un plugin OpenMOLE).\n\n\nPour pouvoir utiliser SimPLU3D depuis ce projet, il faut le sp\u00e9cifier dans les d\u00e9pendances, cela se fait en d\u00e9finissant les resolvers (c'est \u00e0 dire le d\u00e9p\u00f4t dans lequel on peut trouver le .jar contenant le code)   :\n\n\nresolvers += Resolver.mavenLocal\n\nresolvers += \"IGN snapshots\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/\"\n\nresolvers += \"IGN releases\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/releases/\"\n\n\n\n\net en sp\u00e9cifiant les d\u00e9pendances \u00e0 utiliser :\n\n\nlibraryDependencies += \"fr.ign.cogit\" %% \"simplu3d\" % \"1.2-SNAPSHOT\"\n\n\n\n\n2 Cr\u00e9ation du code Scala \u00e0 ex\u00e9cuter\n\uf0c1\n\n\nIl est tout d'abord n\u00e9cessaire de pr\u00e9parer la t\u00e2che \u00e0 ex\u00e9cuter en Java ou en Scala. Afin de pouvoir faciliter la distribution en ce qui concerne la gestion des fichiers envoy\u00e9s et re\u00e7us pendant la distribution, nous conseillons au possible que le code ait la m\u00eame signature que dans la m\u00e9thode suivante (+ d'autres arguments)\n\n\npackage simplu3dopenmoleplugin\n\nimport java.io.File\nimport fr.ign.cogit.simplu3d.experiments.openmole._\n\nobject DistribTask {\n  def apply(folderIn: File, folderOut: File, paramFile: File, seed: Long): (Boolean, File) = {\n    val res = IAUIDFTask.run(folderIn, folderOut, paramFile, seed);\n    (res, folderOut)\n  }\n\n}\n\n\n\n\nCe qui est utile pour la suite est :\n\n 1/ de bien se rappeler du package Scala (mot clef \npackage\n) et de l'objet (mot clef \nobject\n) ;\n\n 2/ qu'il faut d\u00e9finir une m\u00e9thode apply qui prend en entr\u00e9e les param\u00e8tres n\u00e9cessaires au fonctionnement de la t\u00e2che et qui indique les sorties (il est possible d'avoir plusieurs objets en sortie avec Scala, il suffit de d\u00e9finir les types en les s\u00e9parant par des , comme ici  \n(Boolean, File)\n et la sortie est indiqu\u00e9e \u00e0 la fin  (\nres, folderOut)\n'.\n\n\n3 Production du bundle OSGI\n\uf0c1\n\n\nA la racine, du projet, l\u00e0 o\u00f9 se trouve le \nbuild.sbt\n, il suffit d'ex\u00e9cuter :\n\n\n sbt osgiBundle -U\n\n\n\n\nUn fichier .jar est alors produit dans \"''target/scala''\"\n\n\n4 D\u00e9finition du plan d'exp\u00e9rimentation et ex\u00e9cution dans OpenMole\n\uf0c1\n\n\nPour faire cela, je vous invite \u00e0 regarder les tutoriels d'OpenMole pour apprendre \u00e0 bien d\u00e9finir un script.\n\n\nUne fois le plugin charg\u00e9, il est possible de l'utiliser dans la d\u00e9finition du workflow comme cela est expliqu\u00e9 en bas de \ncette page\n.",
            "title": "Intro"
        },
        {
            "location": "/openmole/intro/#introduction-au-couplage-simplu3d-openmole",
            "text": "OpenMOLE  (https://openmole.org/)  est une plate-forme d\u00e9di\u00e9e \u00e0 l'exploration de mod\u00e8les de simulation. Cette plate-forme permet \u00e0 travers la distribution de calculs de calibrer ou d'explorer de mani\u00e8re efficace l'espace de param\u00e8tres de mod\u00e8les.  Ce couplage a \u00e9t\u00e9 utilis\u00e9 pour deux exp\u00e9rimentations : la production des simulations sur de grandes zones et pour la simulation de l'influence de param\u00e8tres de r\u00e8gles sur des formes b\u00e2ties. Ces aspects sont pr\u00e9sent\u00e9s dans l'article suivant :   Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017)",
            "title": "Introduction au couplage SimPLU3D - OpenMOLE"
        },
        {
            "location": "/openmole/intro/#creation-dun-plug-in-openmole",
            "text": "Pour utiliser conjointement les deux projets, il est conseill\u00e9 de cr\u00e9er un  plug-in OpenMOLE . Les diff\u00e9rents couplages  d\u00e9j\u00e0 effectu\u00e9s se trouvent dans le projet  SimPLU3D-OpenMole .  Dans la suite, nous d\u00e9crivons les \u00e9tapes n\u00e9cessaires \u00e0 la production d'un tel plug-in.",
            "title": "Cr\u00e9ation d'un plug-in OpenMOLE."
        },
        {
            "location": "/openmole/intro/#1-creation-du-projet-scala",
            "text": "Le plus simple pour cr\u00e9er le projet Scala est de re-partir d'un exemple existant, en t\u00e9l\u00e9chargeant par exemple, le projet  SimPLU3D-OpenMole .  L'organisation du projet est classique, il y a un fichier build.sbt qui d\u00e9crit la mani\u00e8re avec laquelle le projet est construit. Dans celui-l\u00e0, il est d\u00e9j\u00e0 sp\u00e9cifi\u00e9 que l'on cherche \u00e0 compiler un projet OSGI (mani\u00e8re de compiler un plugin OpenMOLE).  Pour pouvoir utiliser SimPLU3D depuis ce projet, il faut le sp\u00e9cifier dans les d\u00e9pendances, cela se fait en d\u00e9finissant les resolvers (c'est \u00e0 dire le d\u00e9p\u00f4t dans lequel on peut trouver le .jar contenant le code)   :  resolvers += Resolver.mavenLocal\n\nresolvers += \"IGN snapshots\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/\"\n\nresolvers += \"IGN releases\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/releases/\"  et en sp\u00e9cifiant les d\u00e9pendances \u00e0 utiliser :  libraryDependencies += \"fr.ign.cogit\" %% \"simplu3d\" % \"1.2-SNAPSHOT\"",
            "title": "1 Cr\u00e9ation du projet Scala"
        },
        {
            "location": "/openmole/intro/#2-creation-du-code-scala-a-executer",
            "text": "Il est tout d'abord n\u00e9cessaire de pr\u00e9parer la t\u00e2che \u00e0 ex\u00e9cuter en Java ou en Scala. Afin de pouvoir faciliter la distribution en ce qui concerne la gestion des fichiers envoy\u00e9s et re\u00e7us pendant la distribution, nous conseillons au possible que le code ait la m\u00eame signature que dans la m\u00e9thode suivante (+ d'autres arguments)  package simplu3dopenmoleplugin\n\nimport java.io.File\nimport fr.ign.cogit.simplu3d.experiments.openmole._\n\nobject DistribTask {\n  def apply(folderIn: File, folderOut: File, paramFile: File, seed: Long): (Boolean, File) = {\n    val res = IAUIDFTask.run(folderIn, folderOut, paramFile, seed);\n    (res, folderOut)\n  }\n\n}  Ce qui est utile pour la suite est :  1/ de bien se rappeler du package Scala (mot clef  package ) et de l'objet (mot clef  object ) ;  2/ qu'il faut d\u00e9finir une m\u00e9thode apply qui prend en entr\u00e9e les param\u00e8tres n\u00e9cessaires au fonctionnement de la t\u00e2che et qui indique les sorties (il est possible d'avoir plusieurs objets en sortie avec Scala, il suffit de d\u00e9finir les types en les s\u00e9parant par des , comme ici   (Boolean, File)  et la sortie est indiqu\u00e9e \u00e0 la fin  ( res, folderOut) '.",
            "title": "2 Cr\u00e9ation du code Scala \u00e0 ex\u00e9cuter"
        },
        {
            "location": "/openmole/intro/#3-production-du-bundle-osgi",
            "text": "A la racine, du projet, l\u00e0 o\u00f9 se trouve le  build.sbt , il suffit d'ex\u00e9cuter :   sbt osgiBundle -U  Un fichier .jar est alors produit dans \"''target/scala''\"",
            "title": "3 Production du bundle OSGI"
        },
        {
            "location": "/openmole/intro/#4-definition-du-plan-dexperimentation-et-execution-dans-openmole",
            "text": "Pour faire cela, je vous invite \u00e0 regarder les tutoriels d'OpenMole pour apprendre \u00e0 bien d\u00e9finir un script.  Une fois le plugin charg\u00e9, il est possible de l'utiliser dans la d\u00e9finition du workflow comme cela est expliqu\u00e9 en bas de  cette page .",
            "title": "4 D\u00e9finition du plan d'exp\u00e9rimentation et ex\u00e9cution dans OpenMole"
        },
        {
            "location": "/principe/intro/",
            "text": "Principe du fonctionnement de SimPLU3D\n\uf0c1\n\n\nLe simulateur de base fait ressortir trois composants principaux de SimPLU3D :\n\n\n\n\nl'environnement g\u00e9ographique \nenvironnement g\u00e9ographique\n qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ;\n\n\nla d\u00e9finition d'un \ng\u00e9n\u00e9rateur de formes\n, qui d\u00e9termine \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9e par le simulateur et la forme des g\u00e9om\u00e9tries composant des configurations simul\u00e9es ;\n\n\nla d\u00e9finition de \ncontraintes morphologiques\n, qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique et contraignent la g\u00e9n\u00e9ration des formes b\u00e2ties.\n\n\n\n\nPr\u00e9sentation simple de l'approche\n\uf0c1\n\n\nPendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation et la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le \nrecuit simul\u00e9\n).\n\n\nDans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.",
            "title": "Intro"
        },
        {
            "location": "/principe/intro/#principe-du-fonctionnement-de-simplu3d",
            "text": "Le simulateur de base fait ressortir trois composants principaux de SimPLU3D :   l'environnement g\u00e9ographique  environnement g\u00e9ographique  qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ;  la d\u00e9finition d'un  g\u00e9n\u00e9rateur de formes , qui d\u00e9termine \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9e par le simulateur et la forme des g\u00e9om\u00e9tries composant des configurations simul\u00e9es ;  la d\u00e9finition de  contraintes morphologiques , qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique et contraignent la g\u00e9n\u00e9ration des formes b\u00e2ties.",
            "title": "Principe du fonctionnement de SimPLU3D"
        },
        {
            "location": "/principe/intro/#presentation-simple-de-lapproche",
            "text": "Pendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation et la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le  recuit simul\u00e9 ).  Dans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.",
            "title": "Pr\u00e9sentation simple de l'approche"
        },
        {
            "location": "/rules/formats/",
            "text": "Formats de stockage des r\u00e8gles\n\uf0c1\n\n\nSimPLU3D ne poss\u00e8de pas un format pour stocker les r\u00e8gles morphologiques. En effet, les diff\u00e9rentes exp\u00e9riences ont montr\u00e9 que suivant les besoins, l'\u00e9chelle d'\u00e9tude et les r\u00e9glementations locales, les r\u00e8gles n\u00e9cessaires \u00e0 mod\u00e9liser pouvaient beaucoup varier. Ainsi, pour rester g\u00e9n\u00e9rique, c'est \u00e0 l'utilisateur de d\u00e9finir comment stocker ces r\u00e8gles et impl\u00e9menter l'interface \nPredicate\n en fonction de ces r\u00e8gles.\n\n\nCependant, dans cette partie nous pr\u00e9senterons d'abord un exemple de code avec une d\u00e9marche conseill\u00e9e pour int\u00e9grer des r\u00e8gles \u00e0 partir d'un tableau. Puis, nous pointerons vers diff\u00e9rentes exp\u00e9rimentations utilisant diff\u00e9rents formats de r\u00e8gles.\n\n\nInt\u00e9gration de r\u00e8gles sous forme d'un tableau\n\uf0c1\n\n\nIci, nous pr\u00e9senterons un exemple pour charger des r\u00e8gles stock\u00e9es dans un fichier .csv et pour appliquer ces r\u00e8gles aux diff\u00e9rentes zones d'un plan de zonage via le \nSamplerPredicate\n . Le code est disponible dans la classe \nfr.ign.simplu3d.simulRules.SimulWithRules\n du projet SimPLU3D-tutorial. Les donn\u00e9es utilis\u00e9es sont stock\u00e9es dans le dossier \nresources/simulationWithRules\n qui contient notamment un fichier \nrules.csv\n en plus (mis en tableau ci dessous). La jointure entre les zones urbaines et les valeurs de ce tableau s'effectue via le champ \nlibelle\n.\n\n\n\n\n\n\n\n\nlibelle\n\n\ndistReculVoirie\n\n\ndistReculFond\n\n\ndistReculLat\n\n\ndistanceInterBati\n\n\nmaximalCES\n\n\n\n\n\n\n\n\n\n\nub1\n\n\n2\n\n\n3\n\n\n4\n\n\n8\n\n\n0.5\n\n\n\n\n\n\nub2\n\n\n4\n\n\n5\n\n\n4\n\n\n8\n\n\n1\n\n\n\n\n\n\n\n\nLe r\u00e9sultat de la simulation est visible ci dessous, seules 2 parcelles sont simul\u00e9es (celles avec 1 comme valeur pour l'attribut SIMUL)\n\n\n\n\nCode de r\u00e9glementation\n\uf0c1\n\n\nAu pr\u00e9alable, une classe de r\u00e9glementation a \u00e9t\u00e9 cr\u00e9\u00e9e (\nfr.ign.simplu3d.simulRules.RegulationTuto\n). Cette classe impl\u00e9mente l'interface \nIZoneRegulation\n qui permet de rattacher une r\u00e9glementation \u00e0 une zone (classe \nUrbaZone\n). Cette interface a d\u00e9j\u00e0 \u00e9t\u00e9 vue dans la section pr\u00e9sentant le \nmod\u00e8le g\u00e9ographique\n.\n\n\nIl s'agit d'une simple classe ayant des accesseurs aux diff\u00e9rents param\u00e8tres du r\u00e8glement ainsi qu'\u00e0 son libell\u00e9.\n\n\nCode de simulation\n\uf0c1\n\n\nLe code de simulation ressemble \u00e0 celui pr\u00e9sent\u00e9 dans la simulation de base avec quelques modifications. La plus importante diff\u00e9rence concerne la m\u00e9thode \nreadAndAssociateRules\n qui parse le fichier rules.csv contenant les r\u00e8gles et cr\u00e9\u00e9 le lien entre les diff\u00e9rentes zones urbaines et les instances des diff\u00e9rents r\u00e8glements.\n\n\npublic static void readAndAssociateRules(String ruleFile, Environnement env) throws Exception {\n  // Creation of a map to create a link between id regulation and regulation\n  Map<String, RegulationTuto> mapLibelleRegulation = new HashMap<>();\n\n  ////////////////////\n  //// READING THE CSV FILE to complete the map\n  ////////////////////\n\n  BufferedReader in = new BufferedReader(new FileReader(new File(ruleFile)));\n\n  // The first line is the head\n  in.readLine();\n  String line = \"\";\n  // For each line\n  while ((line = in.readLine()) != null) {\n\n    // We create a new regulation\n    RegulationTuto r = new RegulationTuto(line);\n    // We add it to the map with it is name\n    if (r != null) {\n      mapLibelleRegulation.put(r.getLibelle(), r);\n    }\n\n  }\n\n  in.close();\n\n  ////////////////////\n  //// ASSOCIATING UrbaZone and regulation\n  ////////////////////\n\n  for (UrbaZone zone : env.getUrbaZones()) {\n    // We use the libelle to make a join between regulation and zone\n    RegulationTuto regulation = mapLibelleRegulation.get(zone.getLibelle());\n\n    // We create the link in the two directions for convenience\n    zone.setZoneRegulation(regulation);\n    if (regulation != null) {\n      regulation.setUrbaZone(zone);\n\n    }\n\n  }\n\n}\n\n\n\n\nOn peut \u00e9galement noter par ailleurs l'utilisation de la m\u00e9thode \nhasToBeSimulated\n pour ne simuler que les parcelles ayant 1 comme valeur dans le champs \nsimul\n du fichier contenant les parcelles.\n\n\nif (!currentCadastralParcel.hasToBeSimulated()) {\n continue;\n}\n\n\n\n\nDans cet exemple, il n'y a qu'une seule sous-parcelle par parcelle (c'est-\u00e0-dire que chaque parcelle est compl\u00e8tement incluse dans une seule zone urbaine). N\u00e9anmoins, il est possible de consid\u00e9rer plusieurs r\u00e8glements au sein d'une parcelle et d'acc\u00e9der \u00e0 ces r\u00e8glements via les sous-parcelles. Cela n\u00e9cessite dans le pr\u00e9dicat de v\u00e9rifier pour chacun des objets \u00e0 quelle(s) sous-parcelle(s) il appartient et \u00e0 appliquer les v\u00e9rifications en fonction de ces r\u00e8glements. Une seconde complexit\u00e9 est de proposer une m\u00e9thode pour r\u00e9concilier ces diff\u00e9rents r\u00e8glements (Par exemple, comme mesure-t-on une contrainte de distance entre 2 objets qui se trouvent dans 2 zones diff\u00e9rentes ?). Cet aspect est compliqu\u00e9 \u00e0 formaliser, mais un exemple est d\u00e9fini dans la classe \nMultiplePredicateArtiScales du projet ArtiScales\n.\n\n\nAutres exemples d'utilisation de fichier de r\u00e8gles\n\uf0c1\n\n\nDeux types de formats de r\u00e8gles ont \u00e9t\u00e9 utilis\u00e9s :\n\n\n\n\n\n\nFormat OCL\n(Object Constraint Language) : le format OCL permet de mod\u00e9liser des contraintes \u00e0 partir d'instances d'un mod\u00e8le. Ainsi, l'utilisation de r\u00e8gles au format OCL permet une grande expressivit\u00e9 comme il peut utiliser et combiner tous les concepts du mod\u00e8le g\u00e9ographique de SimPLU3D. Cependant, cette expressivit\u00e9 a un co\u00fbt car le temps d'\u00e9valuation d'une contrainte formul\u00e9e en OCL est beaucoup plus longue que son \u00e9quivalent programm\u00e9e en Java. Pour en savoir plus, vous pouvez consulter la page Github de \nSimPLU3D-OCL\n ;\n\n\n\n\n\n\nFormat CartoPLU+\n : le format CartoPLU+ stocke les r\u00e8gles sous format d'un tableau CSV \u00e0 partir d'une s\u00e9lection de contraintes effectu\u00e9e par l'\nIAUIDF\n et la \nDRIEA\n. Pour en savoir plus, vous pouvez consulter la page Github du projet \nSimPLU3D-IAUIDF\n.",
            "title": "Formats"
        },
        {
            "location": "/rules/formats/#formats-de-stockage-des-regles",
            "text": "SimPLU3D ne poss\u00e8de pas un format pour stocker les r\u00e8gles morphologiques. En effet, les diff\u00e9rentes exp\u00e9riences ont montr\u00e9 que suivant les besoins, l'\u00e9chelle d'\u00e9tude et les r\u00e9glementations locales, les r\u00e8gles n\u00e9cessaires \u00e0 mod\u00e9liser pouvaient beaucoup varier. Ainsi, pour rester g\u00e9n\u00e9rique, c'est \u00e0 l'utilisateur de d\u00e9finir comment stocker ces r\u00e8gles et impl\u00e9menter l'interface  Predicate  en fonction de ces r\u00e8gles.  Cependant, dans cette partie nous pr\u00e9senterons d'abord un exemple de code avec une d\u00e9marche conseill\u00e9e pour int\u00e9grer des r\u00e8gles \u00e0 partir d'un tableau. Puis, nous pointerons vers diff\u00e9rentes exp\u00e9rimentations utilisant diff\u00e9rents formats de r\u00e8gles.",
            "title": "Formats de stockage des r\u00e8gles"
        },
        {
            "location": "/rules/formats/#integration-de-regles-sous-forme-dun-tableau",
            "text": "Ici, nous pr\u00e9senterons un exemple pour charger des r\u00e8gles stock\u00e9es dans un fichier .csv et pour appliquer ces r\u00e8gles aux diff\u00e9rentes zones d'un plan de zonage via le  SamplerPredicate  . Le code est disponible dans la classe  fr.ign.simplu3d.simulRules.SimulWithRules  du projet SimPLU3D-tutorial. Les donn\u00e9es utilis\u00e9es sont stock\u00e9es dans le dossier  resources/simulationWithRules  qui contient notamment un fichier  rules.csv  en plus (mis en tableau ci dessous). La jointure entre les zones urbaines et les valeurs de ce tableau s'effectue via le champ  libelle .     libelle  distReculVoirie  distReculFond  distReculLat  distanceInterBati  maximalCES      ub1  2  3  4  8  0.5    ub2  4  5  4  8  1     Le r\u00e9sultat de la simulation est visible ci dessous, seules 2 parcelles sont simul\u00e9es (celles avec 1 comme valeur pour l'attribut SIMUL)",
            "title": "Int\u00e9gration de r\u00e8gles sous forme d'un tableau"
        },
        {
            "location": "/rules/formats/#code-de-reglementation",
            "text": "Au pr\u00e9alable, une classe de r\u00e9glementation a \u00e9t\u00e9 cr\u00e9\u00e9e ( fr.ign.simplu3d.simulRules.RegulationTuto ). Cette classe impl\u00e9mente l'interface  IZoneRegulation  qui permet de rattacher une r\u00e9glementation \u00e0 une zone (classe  UrbaZone ). Cette interface a d\u00e9j\u00e0 \u00e9t\u00e9 vue dans la section pr\u00e9sentant le  mod\u00e8le g\u00e9ographique .  Il s'agit d'une simple classe ayant des accesseurs aux diff\u00e9rents param\u00e8tres du r\u00e8glement ainsi qu'\u00e0 son libell\u00e9.",
            "title": "Code de r\u00e9glementation"
        },
        {
            "location": "/rules/formats/#code-de-simulation",
            "text": "Le code de simulation ressemble \u00e0 celui pr\u00e9sent\u00e9 dans la simulation de base avec quelques modifications. La plus importante diff\u00e9rence concerne la m\u00e9thode  readAndAssociateRules  qui parse le fichier rules.csv contenant les r\u00e8gles et cr\u00e9\u00e9 le lien entre les diff\u00e9rentes zones urbaines et les instances des diff\u00e9rents r\u00e8glements.  public static void readAndAssociateRules(String ruleFile, Environnement env) throws Exception {\n  // Creation of a map to create a link between id regulation and regulation\n  Map<String, RegulationTuto> mapLibelleRegulation = new HashMap<>();\n\n  ////////////////////\n  //// READING THE CSV FILE to complete the map\n  ////////////////////\n\n  BufferedReader in = new BufferedReader(new FileReader(new File(ruleFile)));\n\n  // The first line is the head\n  in.readLine();\n  String line = \"\";\n  // For each line\n  while ((line = in.readLine()) != null) {\n\n    // We create a new regulation\n    RegulationTuto r = new RegulationTuto(line);\n    // We add it to the map with it is name\n    if (r != null) {\n      mapLibelleRegulation.put(r.getLibelle(), r);\n    }\n\n  }\n\n  in.close();\n\n  ////////////////////\n  //// ASSOCIATING UrbaZone and regulation\n  ////////////////////\n\n  for (UrbaZone zone : env.getUrbaZones()) {\n    // We use the libelle to make a join between regulation and zone\n    RegulationTuto regulation = mapLibelleRegulation.get(zone.getLibelle());\n\n    // We create the link in the two directions for convenience\n    zone.setZoneRegulation(regulation);\n    if (regulation != null) {\n      regulation.setUrbaZone(zone);\n\n    }\n\n  }\n\n}  On peut \u00e9galement noter par ailleurs l'utilisation de la m\u00e9thode  hasToBeSimulated  pour ne simuler que les parcelles ayant 1 comme valeur dans le champs  simul  du fichier contenant les parcelles.  if (!currentCadastralParcel.hasToBeSimulated()) {\n continue;\n}  Dans cet exemple, il n'y a qu'une seule sous-parcelle par parcelle (c'est-\u00e0-dire que chaque parcelle est compl\u00e8tement incluse dans une seule zone urbaine). N\u00e9anmoins, il est possible de consid\u00e9rer plusieurs r\u00e8glements au sein d'une parcelle et d'acc\u00e9der \u00e0 ces r\u00e8glements via les sous-parcelles. Cela n\u00e9cessite dans le pr\u00e9dicat de v\u00e9rifier pour chacun des objets \u00e0 quelle(s) sous-parcelle(s) il appartient et \u00e0 appliquer les v\u00e9rifications en fonction de ces r\u00e8glements. Une seconde complexit\u00e9 est de proposer une m\u00e9thode pour r\u00e9concilier ces diff\u00e9rents r\u00e8glements (Par exemple, comme mesure-t-on une contrainte de distance entre 2 objets qui se trouvent dans 2 zones diff\u00e9rentes ?). Cet aspect est compliqu\u00e9 \u00e0 formaliser, mais un exemple est d\u00e9fini dans la classe  MultiplePredicateArtiScales du projet ArtiScales .",
            "title": "Code de simulation"
        },
        {
            "location": "/rules/formats/#autres-exemples-dutilisation-de-fichier-de-regles",
            "text": "Deux types de formats de r\u00e8gles ont \u00e9t\u00e9 utilis\u00e9s :    Format OCL (Object Constraint Language) : le format OCL permet de mod\u00e9liser des contraintes \u00e0 partir d'instances d'un mod\u00e8le. Ainsi, l'utilisation de r\u00e8gles au format OCL permet une grande expressivit\u00e9 comme il peut utiliser et combiner tous les concepts du mod\u00e8le g\u00e9ographique de SimPLU3D. Cependant, cette expressivit\u00e9 a un co\u00fbt car le temps d'\u00e9valuation d'une contrainte formul\u00e9e en OCL est beaucoup plus longue que son \u00e9quivalent programm\u00e9e en Java. Pour en savoir plus, vous pouvez consulter la page Github de  SimPLU3D-OCL  ;    Format CartoPLU+  : le format CartoPLU+ stocke les r\u00e8gles sous format d'un tableau CSV \u00e0 partir d'une s\u00e9lection de contraintes effectu\u00e9e par l' IAUIDF  et la  DRIEA . Pour en savoir plus, vous pouvez consulter la page Github du projet  SimPLU3D-IAUIDF .",
            "title": "Autres exemples d'utilisation de fichier de r\u00e8gles"
        },
        {
            "location": "/rules/intro/",
            "text": "Introduction \u00e0 la v\u00e9rification de r\u00e8gles\n\uf0c1\n\n\n\n\nDans le cadre du processus de simulation, l'\u00e9tape de v\u00e9rification des r\u00e8gles vise \u00e0 indiquer si le r\u00e9sultat de l'application d'une modification sur une configuration respecte les r\u00e8gles morphologiques d\u00e9finies ou non. Dans une premi\u00e8re partie, nous pr\u00e9sentons comment impl\u00e9menter un \nv\u00e9rificateur de r\u00e8gles\n dans SimPLU3D. Comme SimPLU3D effectue de base un tirage al\u00e9atoire dans un espace continu, il peut \u00eatre difficile de faire que certaines r\u00e8gles topologiques (Par exemple, \u00eatre coll\u00e9 contre un b\u00e2timent existant ou une limite s\u00e9parative) soient respect\u00e9es. Une section sera d\u00e9di\u00e9e \u00e0 la d\u00e9finition de \ntelles r\u00e8gles topologiques\n. Il n'y a actuellement pas de format de r\u00e8gle propre \u00e0 SimPLU3D, comme le simulateur est tr\u00e8s g\u00e9n\u00e9rique et amen\u00e9 \u00e0 traiter des contextes diff\u00e9rents. N\u00e9anmoins, une section est d\u00e9di\u00e9e \u00e0 la \npr\u00e9sentation rapide de quelques formats utilis\u00e9s et de pistes pour utiliser d'autres formats de r\u00e8gles\n.",
            "title": "Intro"
        },
        {
            "location": "/rules/intro/#introduction-a-la-verification-de-regles",
            "text": "Dans le cadre du processus de simulation, l'\u00e9tape de v\u00e9rification des r\u00e8gles vise \u00e0 indiquer si le r\u00e9sultat de l'application d'une modification sur une configuration respecte les r\u00e8gles morphologiques d\u00e9finies ou non. Dans une premi\u00e8re partie, nous pr\u00e9sentons comment impl\u00e9menter un  v\u00e9rificateur de r\u00e8gles  dans SimPLU3D. Comme SimPLU3D effectue de base un tirage al\u00e9atoire dans un espace continu, il peut \u00eatre difficile de faire que certaines r\u00e8gles topologiques (Par exemple, \u00eatre coll\u00e9 contre un b\u00e2timent existant ou une limite s\u00e9parative) soient respect\u00e9es. Une section sera d\u00e9di\u00e9e \u00e0 la d\u00e9finition de  telles r\u00e8gles topologiques . Il n'y a actuellement pas de format de r\u00e8gle propre \u00e0 SimPLU3D, comme le simulateur est tr\u00e8s g\u00e9n\u00e9rique et amen\u00e9 \u00e0 traiter des contextes diff\u00e9rents. N\u00e9anmoins, une section est d\u00e9di\u00e9e \u00e0 la  pr\u00e9sentation rapide de quelques formats utilis\u00e9s et de pistes pour utiliser d'autres formats de r\u00e8gles .",
            "title": "Introduction \u00e0 la v\u00e9rification de r\u00e8gles"
        },
        {
            "location": "/rules/predicate/",
            "text": "Impl\u00e9mentation de la v\u00e9rification de r\u00e8gles dans SimPLU3D\n\uf0c1\n\n\nPour v\u00e9rifier les r\u00e8gles morphologiques, SimPLU3D utilise le concept de pr\u00e9dicat. Il s'agit d'un objet qui indique si une configuration respecte ou non respecte une r\u00e8gle.\n\n\nInterface de predicat\n\uf0c1\n\n\nL'interface de la librjmcmc4j \nfr.ign.rjmcmc.configuration. ConfigurationModificationPredicate\n, M extends Modification\n>\n impl\u00e9mente cette notion de pr\u00e9dicat et permet la d\u00e9finition \u00e0 elle seule du respect des r\u00e8gles.\n\n\nCette interface ne d\u00e9finit que la m\u00e9thode \nboolean check(C c, M m);\n. Avec :\n\n\n\n\nc\n, une instance de configuration, qui contient la liste des objets de la configuration courante  (c'est \u00e0 dire avant application de la modification) ;\n\n\nm\n, la modification qui serait appliqu\u00e9e \u00e0 la configuration \nc\n ;\n\n\nla m\u00e9thode renvoie un \nboolean\n qui indique si les r\u00e8gles sont respect\u00e9es suite \u00e0 l'application de la modification \nm\n sur la m\u00e9thode \nc\n.\n\n\n\n\nImpl\u00e9mentation \u00e0 partir de l'interface de pr\u00e9dicat\n\uf0c1\n\n\nDans SimPLU3D, nous conseillons l'impl\u00e9mentation de cette interface \u00e0 travers la d\u00e9finition suivante (et de regarder la-dite classe qui donne une id\u00e9e de comment impl\u00e9menter la m\u00e9thode) :\n\n\n SamplePredicate<O extends ISimPLU3DPrimitive, C extends AbstractGraphConfiguration<O, C, M>, M extends AbstractBirthDeathModification<O, C, M>>\n        implements ConfigurationModificationPredicate<C, M>\n\n\n\n\nAinsi, \u00e0 travers la classe abstraite \nAbstractGraphConfiguration\n, il est possible d'acc\u00e9der \u00e0 la liste des objets de la configuration courante \u00e0 travers un it\u00e9rateur (m\u00e9thode \niterator\n) et \u00e0 travers la classe \nAbstractBirthDeathModification\n d'acc\u00e9der aux modifications \u00e0 travers la cr\u00e9ation \nm.getBirth()\n et la destruction d'objets \nm.getDeath()\n de la classe utilis\u00e9e pendant la g\u00e9n\u00e9ration.\nUne modification est vue comme l'ajout et la suppression d'objet. Dans les modifications usuellement utilis\u00e9es dans SimPLU3D, ces listes contiennent soit 0 soit 1 objet.\n\n\nIl suffit ensuite de coder la v\u00e9rification des r\u00e8gles pour les diff\u00e9rents objets de la configuration apr\u00e8s modification en utilisant les informations disponibles dans l'\nenvironnement g\u00e9ographique\n). Ainsi, pour avoir la liste des objets de la classe O apr\u00e8s modification, on peut utiliser le code suivant :\n\n\nList<O> listOfObjects = new ArrayList<>();\n  Iterator<O> iTBat = c.iterator();\n\n  while ( iTBat.hasNext()) {\n    listOfObjects.add(iTBat.next());\n  }\n\n  //La m\u00e9thode equals() doit \u00eatre d\u00e9finie pour la classe O\n  listOfObjects.removeAll(m.getDeath());\n  listOfObjects.addAll(m.getBirth());\n\n\n\n\n\n\n \nAttention\n: comme l'\u00e9valuation de la m\u00e9thode \ncheck()\n s'effectue \u00e0 chaque it\u00e9ration et qu'une simulation peut compter des millions de simulation, optimiser le temps d'ex\u00e9cution de cette m\u00e9thode permet de diminuer de beaucoup le temps de calcul, d'autant plus que cette m\u00e9thode fait g\u00e9n\u00e9ralement \u00e0 des op\u00e9rateurs g\u00e9om\u00e9triques qui peuvent \u00eatre co\u00fbteux en termes de temps. Voici quelques astuces pour diminuer ce temps de calcul :\n\n\n1/ Essayer de renvoyer false chaque fois d\u00e8s qu'une r\u00e8gle n'est pas respect\u00e9e ;\n\n\n2/ Privil\u00e9gier les g\u00e9om\u00e9tries JTS aux g\u00e9om\u00e9tries GeOxygene (les op\u00e9rateurs g\u00e9om\u00e9triques appliqu\u00e9es aux g\u00e9om\u00e9tries GeOxygene n\u00e9cessitent une conversion JTS qui augmente le temps de calcul) ;\n\n\n3/ Conserver des objets en cache lorsqu'ils sont fixes pour \u00e9viter de les re-g\u00e9n\u00e9rer \u00e0 chaque \u00e9tape ;\n\n\n4/ Ne v\u00e9rifier les r\u00e8gles que pour les objets n\u00e9cessaires. En effet, les g\u00e9om\u00e9tries dans la configuration avant modification v\u00e9rifient d\u00e9j\u00e0 un certain nombre de r\u00e8gles, il n'est ainsi pas n\u00e9cessaire de devoir les r\u00e9\u00e9valuer pour ceux-ci. Cela est par exemple vrai pour les r\u00e8gles de hauteur ou de distance 2D avec les limites s\u00e9paratives.\n\n\n\n\nImpl\u00e9mentation \u00e0 partir de la classe abstraite DefaultAbstractPredicate\n\uf0c1\n\n\nLa classe \nfr.ign.cogit.simplu3d.util.regulation.DefaultAbstractPredicate\n contient un certain nombre de fonctions de base qui sont issues de r\u00e8gles souvent utilis\u00e9es dans SimPLU3D. Les m\u00e9thodes de cette classe suivent les principes \u00e9voqu\u00e9s pr\u00e9c\u00e9demment et permettent de diminuer le temps de calcul. En \u00e9tendant cette classe abstraite et en utilisant son constructeur, il est possible de d\u00e9finir plus facilement la m\u00e9thode \ncheck()\n d'un pr\u00e9dicat en utilisant les fonctions pr\u00e9d\u00e9finies.\n\n\nOn retrouve trois types de fonctions :\n\n\n\n\ndes accesseurs\n, pour acc\u00e9der directement aux g\u00e9om\u00e9tries JTS d'un certain nombre d'objets issus du mod\u00e8le ;\n\n\ndes \nv\u00e9rificateurs portant sur l'ensemble des objets\n de la configuration courante ;\n\n\ndes \nv\u00e9rificateurs qui peuvent ne porter que sur les nouveaux objets\n propos\u00e9s par la modification (cf principe 4 \u00e9voqu\u00e9 pr\u00e9c\u00e9demment).\n\n\n\n\nAccesseurs\n\uf0c1\n\n\nCes m\u00e9thodes permettent d'acc\u00e9der directement \u00e0 certaines g\u00e9om\u00e9triques JTS sans  avoir \u00e0 parcourir l'ensemble du mod\u00e8le\n\n\n\n\n\n\n\n\nNom de la m\u00e9thode\n\n\nCommentaire\n\n\n\n\n\n\n\n\n\n\ngetJtsCurveLimiteFondParcel\n\n\nG\u00e9om\u00e9trie des limites de fond de parcelle\n\n\n\n\n\n\ngetJtsCurveLimiteFrontParcel\n\n\nG\u00e9om\u00e9trie des limites donnant sur la voirie\n\n\n\n\n\n\ngetJtsCurveLimiteLatParcel\n\n\nG\u00e9om\u00e9trie des limites lat\u00e9rales\n\n\n\n\n\n\ngetJtsCurveLimiteLatParcelLeft\n\n\nG\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 gauche\n\n\n\n\n\n\ngetJtsCurveLimiteLatParcelRight\n\n\nG\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 droit\n\n\n\n\n\n\ngetJtsCurveOppositeLimit\n\n\nG\u00e9om\u00e9trie des limites du c\u00f4t\u00e9 oppos\u00e9 \u00e0 la parcelle\n\n\n\n\n\n\ngetbPUGeom\n\n\nG\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re\n\n\n\n\n\n\n\n\nSi une g\u00e9om\u00e9trie n'existe pas du fait de la configuration spatiale, elle aura null comme valeur.\n\n\nV\u00e9rificateur portant sur l'ensemble des objects\n\uf0c1\n\n\nIl s'agit de m\u00e9thodes qui v\u00e9rifient certaines r\u00e8gles portant sur l'ensemble des objets apr\u00e8s modification. La m\u00e9thode \ngetAllObjectsAfterModifcation(C c, M m)\n permet d'obtenir cette liste et de faire porter le test sur celle-ci. Par exemple, dans la m\u00e9thode \ncheck\n cela revient \u00e0 ajouter, par exemple, le code suivant  :\n\n\n//On r\u00e9cup\u00e8re la liste des objets apr\u00e8s modification\nList<O> objects = this.getAllObjectsAfterModifcation(C c, M m);\n//Si le test qui v\u00e9rifie le nombre d'objets est faux, on consid\u00e8re que les r\u00e8gles ne sont pas respect\u00e9es, on renvoie faux au niveau de la m\u00e9thode check().\nif(! checkNumberOfBuildings(objects, 8)){\n  return false;\n}\n\n\n\n\nOn retrouve les m\u00e9thodes suivantes :\n\n\n\n\n\n\n\n\nNom de la m\u00e9thode\n\n\nCommentaire\n\n\n\n\n\n\n\n\n\n\ncheckNumberOfBuildings(allObjects, numberMaxOfObject)\n\n\nV\u00e9rifie que le nombre d'objets de la configuration est inf\u00e9rieure \u00e0 numberMaxOfObject\n\n\n\n\n\n\ncheckBuiltRatio(allObjects,  maxValue)\n\n\nV\u00e9rifie que le ratio de surface couverte de l'unit\u00e9 fonci\u00e8re est inf\u00e9rieure \u00e0 maxValue\n\n\n\n\n\n\ncheckDistanceBetweenObjectandBuildings(allObjects, distMinInterBati)\n\n\nV\u00e9rifie que la distance entre chaque objet simul\u00e9 et les b\u00e2timents existants est sup\u00e9rieure \u00e0    distMinInterBati\n\n\n\n\n\n\ncheckDistanceBetweenObjects(allObjects, distMinInterBati)\n\n\nV\u00e9rifie que la distance entre chaque paire d' objets simul\u00e9s est sup\u00e9rieure \u00e0    distMinInterBati\n\n\n\n\n\n\n\n\nV\u00e9rificateurs portant sur l'ensemble des nouveaux objets\n\uf0c1\n\n\nIl s'agit de m\u00e9thodes qui peuvent \u00eatre v\u00e9rifi\u00e9s que sur les nouveaux objets cr\u00e9\u00e9s par la modification appliqu\u00e9e (dans le sens o\u00f9 l'ajout de nouveaux objets ne change pas le respect de la r\u00e8gles pour les objets d\u00e9j\u00e0 existants de la configuration). La liste des objets cr\u00e9\u00e9s par la modification peut \u00eatre obtenue avec la m\u00e9thode \nm.getBirth()\n. Ainsi, utiliser ces m\u00e9thodes dans la m\u00e9thode \ncheck\n revient par exemple \u00e0 ajouter le code suivant :\n\n\n//On r\u00e9cup\u00e8re la liste des objets ajout\u00e9s par la modification\nList<O> objects = m.getBirth();\n//Si le test qui v\u00e9rifie si les nouveaux objets sont \u00e0 l'int\u00e9rieur de la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re est faux\n//On renvoie faux\nif(! checkIfInsideBPU(objects)){\n  return false;\n}\n\n\n\n\nOn retrouve les m\u00e9thodes suivantes :\n\n\n\n\n\n\n\n\nNom de la m\u00e9thode\n\n\nCommentaire\n\n\n\n\n\n\n\n\n\n\ncheckDistanceToGeometry(objects, geom,  distMin)\n\n\nV\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure \u00e0 distMin\n\n\n\n\n\n\ncheckDistanceToGeometry(objects, geom,  dist,  supOrInf)\n\n\nV\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure ou inf\u00e9rieure \u00e0 distMin\n\n\n\n\n\n\ncheckDistanceToLimitBySide(objects,  distanceMin,lBoundaryType)\n\n\nV\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des types fournis est sup\u00e9rieure \u00e0 distMin\n\n\n\n\n\n\ncheckDistanceToLimitByType(objects,  distanceMin, lBoundaryType)\n\n\nV\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des c\u00f4t\u00e9s fournis est sup\u00e9rieure \u00e0 distMin\n\n\n\n\n\n\ncheckDistanceToOppositeLimit(objects,  distanceMin)\n\n\nV\u00e9rifie que la distance entre les objets les limites s\u00e9paratives des parcelles oppos\u00e9es est sup\u00e9rieure \u00e0 distMin\n\n\n\n\n\n\ncheckIfContainedInGeometry(objects,geometry)\n\n\nV\u00e9rifie que la distance entre les objets sont contenues dans une g\u00e9om\u00e9trie\n\n\n\n\n\n\ncheckIfInsideBPU(objects)\n\n\nV\u00e9rifie que la distance entre les objets sont inclus dans la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re\n\n\n\n\n\n\ncheckIfIntersectsGeometry(objects, geometry)\n\n\nV\u00e9rifie que la distance entre les objets intersectent dans une g\u00e9om\u00e9trie\n\n\n\n\n\n\n\n\nLes m\u00e9thodes peuvent aussi \u00eatre utilis\u00e9es si on ne souhaite pas qu'une condition soit v\u00e9rifi\u00e9e. Par exemple, si on ne souhaite pas que les objets intersectent une g\u00e9om\u00e9trie, on peut utiliser la m\u00e9thode \ncheckIfIntersectsGeometry\n et renvoyer faux si la condition est v\u00e9rifi\u00e9e.",
            "title": "Predicate"
        },
        {
            "location": "/rules/predicate/#implementation-de-la-verification-de-regles-dans-simplu3d",
            "text": "Pour v\u00e9rifier les r\u00e8gles morphologiques, SimPLU3D utilise le concept de pr\u00e9dicat. Il s'agit d'un objet qui indique si une configuration respecte ou non respecte une r\u00e8gle.",
            "title": "Impl\u00e9mentation de la v\u00e9rification de r\u00e8gles dans SimPLU3D"
        },
        {
            "location": "/rules/predicate/#interface-de-predicat",
            "text": "L'interface de la librjmcmc4j  fr.ign.rjmcmc.configuration. ConfigurationModificationPredicate , M extends Modification >  impl\u00e9mente cette notion de pr\u00e9dicat et permet la d\u00e9finition \u00e0 elle seule du respect des r\u00e8gles.  Cette interface ne d\u00e9finit que la m\u00e9thode  boolean check(C c, M m); . Avec :   c , une instance de configuration, qui contient la liste des objets de la configuration courante  (c'est \u00e0 dire avant application de la modification) ;  m , la modification qui serait appliqu\u00e9e \u00e0 la configuration  c  ;  la m\u00e9thode renvoie un  boolean  qui indique si les r\u00e8gles sont respect\u00e9es suite \u00e0 l'application de la modification  m  sur la m\u00e9thode  c .",
            "title": "Interface de predicat"
        },
        {
            "location": "/rules/predicate/#implementation-a-partir-de-linterface-de-predicat",
            "text": "Dans SimPLU3D, nous conseillons l'impl\u00e9mentation de cette interface \u00e0 travers la d\u00e9finition suivante (et de regarder la-dite classe qui donne une id\u00e9e de comment impl\u00e9menter la m\u00e9thode) :   SamplePredicate<O extends ISimPLU3DPrimitive, C extends AbstractGraphConfiguration<O, C, M>, M extends AbstractBirthDeathModification<O, C, M>>\n        implements ConfigurationModificationPredicate<C, M>  Ainsi, \u00e0 travers la classe abstraite  AbstractGraphConfiguration , il est possible d'acc\u00e9der \u00e0 la liste des objets de la configuration courante \u00e0 travers un it\u00e9rateur (m\u00e9thode  iterator ) et \u00e0 travers la classe  AbstractBirthDeathModification  d'acc\u00e9der aux modifications \u00e0 travers la cr\u00e9ation  m.getBirth()  et la destruction d'objets  m.getDeath()  de la classe utilis\u00e9e pendant la g\u00e9n\u00e9ration.\nUne modification est vue comme l'ajout et la suppression d'objet. Dans les modifications usuellement utilis\u00e9es dans SimPLU3D, ces listes contiennent soit 0 soit 1 objet.  Il suffit ensuite de coder la v\u00e9rification des r\u00e8gles pour les diff\u00e9rents objets de la configuration apr\u00e8s modification en utilisant les informations disponibles dans l' environnement g\u00e9ographique ). Ainsi, pour avoir la liste des objets de la classe O apr\u00e8s modification, on peut utiliser le code suivant :  List<O> listOfObjects = new ArrayList<>();\n  Iterator<O> iTBat = c.iterator();\n\n  while ( iTBat.hasNext()) {\n    listOfObjects.add(iTBat.next());\n  }\n\n  //La m\u00e9thode equals() doit \u00eatre d\u00e9finie pour la classe O\n  listOfObjects.removeAll(m.getDeath());\n  listOfObjects.addAll(m.getBirth());     Attention : comme l'\u00e9valuation de la m\u00e9thode  check()  s'effectue \u00e0 chaque it\u00e9ration et qu'une simulation peut compter des millions de simulation, optimiser le temps d'ex\u00e9cution de cette m\u00e9thode permet de diminuer de beaucoup le temps de calcul, d'autant plus que cette m\u00e9thode fait g\u00e9n\u00e9ralement \u00e0 des op\u00e9rateurs g\u00e9om\u00e9triques qui peuvent \u00eatre co\u00fbteux en termes de temps. Voici quelques astuces pour diminuer ce temps de calcul :  1/ Essayer de renvoyer false chaque fois d\u00e8s qu'une r\u00e8gle n'est pas respect\u00e9e ;  2/ Privil\u00e9gier les g\u00e9om\u00e9tries JTS aux g\u00e9om\u00e9tries GeOxygene (les op\u00e9rateurs g\u00e9om\u00e9triques appliqu\u00e9es aux g\u00e9om\u00e9tries GeOxygene n\u00e9cessitent une conversion JTS qui augmente le temps de calcul) ;  3/ Conserver des objets en cache lorsqu'ils sont fixes pour \u00e9viter de les re-g\u00e9n\u00e9rer \u00e0 chaque \u00e9tape ;  4/ Ne v\u00e9rifier les r\u00e8gles que pour les objets n\u00e9cessaires. En effet, les g\u00e9om\u00e9tries dans la configuration avant modification v\u00e9rifient d\u00e9j\u00e0 un certain nombre de r\u00e8gles, il n'est ainsi pas n\u00e9cessaire de devoir les r\u00e9\u00e9valuer pour ceux-ci. Cela est par exemple vrai pour les r\u00e8gles de hauteur ou de distance 2D avec les limites s\u00e9paratives.",
            "title": "Impl\u00e9mentation \u00e0 partir de l'interface de pr\u00e9dicat"
        },
        {
            "location": "/rules/predicate/#implementation-a-partir-de-la-classe-abstraite-defaultabstractpredicate",
            "text": "La classe  fr.ign.cogit.simplu3d.util.regulation.DefaultAbstractPredicate  contient un certain nombre de fonctions de base qui sont issues de r\u00e8gles souvent utilis\u00e9es dans SimPLU3D. Les m\u00e9thodes de cette classe suivent les principes \u00e9voqu\u00e9s pr\u00e9c\u00e9demment et permettent de diminuer le temps de calcul. En \u00e9tendant cette classe abstraite et en utilisant son constructeur, il est possible de d\u00e9finir plus facilement la m\u00e9thode  check()  d'un pr\u00e9dicat en utilisant les fonctions pr\u00e9d\u00e9finies.  On retrouve trois types de fonctions :   des accesseurs , pour acc\u00e9der directement aux g\u00e9om\u00e9tries JTS d'un certain nombre d'objets issus du mod\u00e8le ;  des  v\u00e9rificateurs portant sur l'ensemble des objets  de la configuration courante ;  des  v\u00e9rificateurs qui peuvent ne porter que sur les nouveaux objets  propos\u00e9s par la modification (cf principe 4 \u00e9voqu\u00e9 pr\u00e9c\u00e9demment).",
            "title": "Impl\u00e9mentation \u00e0 partir de la classe abstraite DefaultAbstractPredicate"
        },
        {
            "location": "/rules/predicate/#accesseurs",
            "text": "Ces m\u00e9thodes permettent d'acc\u00e9der directement \u00e0 certaines g\u00e9om\u00e9triques JTS sans  avoir \u00e0 parcourir l'ensemble du mod\u00e8le     Nom de la m\u00e9thode  Commentaire      getJtsCurveLimiteFondParcel  G\u00e9om\u00e9trie des limites de fond de parcelle    getJtsCurveLimiteFrontParcel  G\u00e9om\u00e9trie des limites donnant sur la voirie    getJtsCurveLimiteLatParcel  G\u00e9om\u00e9trie des limites lat\u00e9rales    getJtsCurveLimiteLatParcelLeft  G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 gauche    getJtsCurveLimiteLatParcelRight  G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 droit    getJtsCurveOppositeLimit  G\u00e9om\u00e9trie des limites du c\u00f4t\u00e9 oppos\u00e9 \u00e0 la parcelle    getbPUGeom  G\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re     Si une g\u00e9om\u00e9trie n'existe pas du fait de la configuration spatiale, elle aura null comme valeur.",
            "title": "Accesseurs"
        },
        {
            "location": "/rules/predicate/#verificateur-portant-sur-lensemble-des-objects",
            "text": "Il s'agit de m\u00e9thodes qui v\u00e9rifient certaines r\u00e8gles portant sur l'ensemble des objets apr\u00e8s modification. La m\u00e9thode  getAllObjectsAfterModifcation(C c, M m)  permet d'obtenir cette liste et de faire porter le test sur celle-ci. Par exemple, dans la m\u00e9thode  check  cela revient \u00e0 ajouter, par exemple, le code suivant  :  //On r\u00e9cup\u00e8re la liste des objets apr\u00e8s modification\nList<O> objects = this.getAllObjectsAfterModifcation(C c, M m);\n//Si le test qui v\u00e9rifie le nombre d'objets est faux, on consid\u00e8re que les r\u00e8gles ne sont pas respect\u00e9es, on renvoie faux au niveau de la m\u00e9thode check().\nif(! checkNumberOfBuildings(objects, 8)){\n  return false;\n}  On retrouve les m\u00e9thodes suivantes :     Nom de la m\u00e9thode  Commentaire      checkNumberOfBuildings(allObjects, numberMaxOfObject)  V\u00e9rifie que le nombre d'objets de la configuration est inf\u00e9rieure \u00e0 numberMaxOfObject    checkBuiltRatio(allObjects,  maxValue)  V\u00e9rifie que le ratio de surface couverte de l'unit\u00e9 fonci\u00e8re est inf\u00e9rieure \u00e0 maxValue    checkDistanceBetweenObjectandBuildings(allObjects, distMinInterBati)  V\u00e9rifie que la distance entre chaque objet simul\u00e9 et les b\u00e2timents existants est sup\u00e9rieure \u00e0    distMinInterBati    checkDistanceBetweenObjects(allObjects, distMinInterBati)  V\u00e9rifie que la distance entre chaque paire d' objets simul\u00e9s est sup\u00e9rieure \u00e0    distMinInterBati",
            "title": "V\u00e9rificateur portant sur l'ensemble des objects"
        },
        {
            "location": "/rules/predicate/#verificateurs-portant-sur-lensemble-des-nouveaux-objets",
            "text": "Il s'agit de m\u00e9thodes qui peuvent \u00eatre v\u00e9rifi\u00e9s que sur les nouveaux objets cr\u00e9\u00e9s par la modification appliqu\u00e9e (dans le sens o\u00f9 l'ajout de nouveaux objets ne change pas le respect de la r\u00e8gles pour les objets d\u00e9j\u00e0 existants de la configuration). La liste des objets cr\u00e9\u00e9s par la modification peut \u00eatre obtenue avec la m\u00e9thode  m.getBirth() . Ainsi, utiliser ces m\u00e9thodes dans la m\u00e9thode  check  revient par exemple \u00e0 ajouter le code suivant :  //On r\u00e9cup\u00e8re la liste des objets ajout\u00e9s par la modification\nList<O> objects = m.getBirth();\n//Si le test qui v\u00e9rifie si les nouveaux objets sont \u00e0 l'int\u00e9rieur de la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re est faux\n//On renvoie faux\nif(! checkIfInsideBPU(objects)){\n  return false;\n}  On retrouve les m\u00e9thodes suivantes :     Nom de la m\u00e9thode  Commentaire      checkDistanceToGeometry(objects, geom,  distMin)  V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure \u00e0 distMin    checkDistanceToGeometry(objects, geom,  dist,  supOrInf)  V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure ou inf\u00e9rieure \u00e0 distMin    checkDistanceToLimitBySide(objects,  distanceMin,lBoundaryType)  V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des types fournis est sup\u00e9rieure \u00e0 distMin    checkDistanceToLimitByType(objects,  distanceMin, lBoundaryType)  V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des c\u00f4t\u00e9s fournis est sup\u00e9rieure \u00e0 distMin    checkDistanceToOppositeLimit(objects,  distanceMin)  V\u00e9rifie que la distance entre les objets les limites s\u00e9paratives des parcelles oppos\u00e9es est sup\u00e9rieure \u00e0 distMin    checkIfContainedInGeometry(objects,geometry)  V\u00e9rifie que la distance entre les objets sont contenues dans une g\u00e9om\u00e9trie    checkIfInsideBPU(objects)  V\u00e9rifie que la distance entre les objets sont inclus dans la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re    checkIfIntersectsGeometry(objects, geometry)  V\u00e9rifie que la distance entre les objets intersectent dans une g\u00e9om\u00e9trie     Les m\u00e9thodes peuvent aussi \u00eatre utilis\u00e9es si on ne souhaite pas qu'une condition soit v\u00e9rifi\u00e9e. Par exemple, si on ne souhaite pas que les objets intersectent une g\u00e9om\u00e9trie, on peut utiliser la m\u00e9thode  checkIfIntersectsGeometry  et renvoyer faux si la condition est v\u00e9rifi\u00e9e.",
            "title": "V\u00e9rificateurs portant sur l'ensemble des nouveaux objets"
        },
        {
            "location": "/rules/topologique/",
            "text": "Prise en compte de r\u00e8gles topologiques\n\uf0c1\n\n\nLe fonctionnement de base de SimPLU3D qui consiste \u00e0 tirer des valeurs al\u00e9atoires dans un espace continu rend difficile l'application de contraintes topologiques. Si on prend l'exemple de l'alignement aux limites s\u00e9paratives donnant sur une route (cf image ci-dessous), il est totalement improbable que SimPLU3D effectue le tirage d'une bo\u00eete respectant cet alignement (cela revient \u00e0 tirer exactement le bonne valeur de x,y,w et \u03b8). Deux strat\u00e9gies sont possibles pour utiliser de telles r\u00e8gles.\n\n\n\n\nStrat\u00e9gie 1 : transformation en contrainte g\u00e9om\u00e9trique\n\uf0c1\n\n\nLa strat\u00e9gie na\u00efve consisterait \u00e0 transformer la contrainte topologique en contrainte g\u00e9om\u00e9trique. Par exemple, de v\u00e9rifier si l'un des c\u00f4t\u00e9s de la bo\u00eete est inclus dans un buffer de petite taille autour de la limite donnant sur la voirie.\n\n\nCela rend probable la proposition de bo\u00eetes par le syst\u00e8me respectant cette r\u00e8gle, mais comme cette probabilit\u00e9 reste relativement faible, il peut \u00eatre n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations afin d'atteindre un r\u00e9sultat optimis\u00e9.\n\n\nStrat\u00e9gie 2 :  g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es\n\uf0c1\n\n\nLa seconde strat\u00e9gie consiste \u00e0 non plus g\u00e9n\u00e9rer des bo\u00eetes libres, mais des bo\u00eetes directement align\u00e9es sur la limite consid\u00e9r\u00e9e. Il s'agit ainsi de d\u00e9finir un nouveau g\u00e9n\u00e9rateur de forme (comme d\u00e9crit dans la section \nG\u00e9n\u00e9rateur de formes - G\u00e9n\u00e9rer d'autres types de formes\n).\n\n\nDans ce cas, la g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e est non plus une bo\u00eete \u00e0 6 dimensions ( \nb\n = (\nx\n, \ny\n, \nl\n, \nw\n, \nh\n, \n\u03b8\n)), mais un bo\u00eete parall\u00e8le \u00e0 4 dimensions ( \nbp\n = (\nx\n, \ny\n, \nl\n, \nh\n), en consid\u00e9rant que l'orientation et la largeur sont impos\u00e9es par les coordonn\u00e9es du centre de l'objet.\n\n\nEx\u00e9cutable pour la g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es\n\uf0c1\n\n\nDans le projet SimPLU3D-tutorial, une classe a \u00e9t\u00e9 ajout\u00e9e sur la base de l'exemple de base pour effectuer des simulation avec des bo\u00eetes qui seraient align\u00e9es \u00e0 la limite donnant sur la voirie. Il s'agit de la classe : \nfr.ign.simplu3d.topologicRule.ParallelSimulator\n\n\n  // NEW HERE THE PARALELLE OPTIMOIZER IS USED\n  ParallelCuboidOptimizer oCB = new ParallelCuboidOptimizer();\n\n  // IT REQUIRES AS INPUT THE GEOMETRY WHERE THE CUBOIDS HAVE TO BE ALIGNED\n  IGeometry[] limits = createRoadLimits(bPU);\n\n  // Run of the optimisation on a parcel with the predicate\n  GraphConfiguration<Cuboid> cc = oCB.process(Random.random(), bPU, p, env, 0, pred, limits, bPU.getGeom());\n\n\n\n\n\nLa diff\u00e9rence avec le code d'exemple de base tient en deux lignes :\n\n\n\n\nla r\u00e9cup\u00e9ration des limites le long desquelles les bo\u00eetes seront align\u00e9es ;\n\n\nl'utilisation du simulateur sp\u00e9cifique aux bo\u00eetes align\u00e9es (classe \nfr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.paralellcuboid.ParallelCuboidOptimizer\n)\n\n\n\n\nLe r\u00e9sultat est celui de la figure suivante. On visualise bien que la bo\u00eetes est align\u00e9e avec la limite s\u00e9parative ce qui fait que le r\u00e9sultat optimis\u00e9 n'occupe pas l'int\u00e9rieur du L.\n\n\n\n\nD\u00e9finition de l'optimiseur\n\uf0c1\n\n\nL'optimiseur est d\u00e9fini comme g\u00e9n\u00e9rant des objets de la classe  \nfr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.simple.ParallelCuboid\n du projet SimPLU3D compos\u00e9 de 4 dimensions. N\u00e9anmoins, cette classe poss\u00e8de les attributs orientation et width pour permettre de g\u00e9n\u00e9rer la forme de la bo\u00eete.\n\n\nLa diff\u00e9rence principale avec la simulation du b\u00e2timent en L se situe au niveau du builder (classe \nfr.ign.cogit.simplu3d.rjmcmc.cuboid.builder.ParallelCuboidBuilder\n du projet SimPLU3D). Le builder est d\u00e9fini comme ayant 4 dimensions mais il va bien renseigner les 6 dimensions de l'objet  \nParallelCuboid\n.\n\n\nPour d\u00e9terminer la largeur et l'orientation, une projection est effectu\u00e9e depuis le point tir\u00e9 al\u00e9atoirement vers la limite sur laquelle la forme est align\u00e9e. La longueur de la projection d\u00e9termine la moiti\u00e9 de la largeur de la bo\u00eete et son azimut l'orientation de la bo\u00eete (cf code ci-dessous).\n\n\n@Override\npublic Cuboid build(double[] coordinates) {\n  Coordinate p = new Coordinate(coordinates[0], coordinates[1]);\n  DistanceOp op = new DistanceOp(this.limits, factory.createPoint(p));\n  Coordinate projected = op.nearestPoints()[0];\n  double distance = op.distance();\n  double orientation = Angle.angle(p, projected);\n  AbstractParallelCuboid result;\n  if (bandType == 1) {\n\n    result = new ParallelCuboid(coordinates[0], coordinates[1], coordinates[2], distance * 2,\n        coordinates[3], orientation + Math.PI / 2);\n\n  } else {\n    result = new ParallelCuboid2(coordinates[0], coordinates[1], coordinates[2], distance * 2,\n        coordinates[3], orientation + Math.PI / 2);\n  }\n  return result;\n}\n\n\n\n\nTous les autres aspects (impl\u00e9mentation des noyaux de proposition et du sampler) sont d\u00e9finis de la m\u00eame mani\u00e8re que vu pr\u00e9c\u00e9demment mais adapt\u00e9s pour ces objets \u00e0 4 dimensions.",
            "title": "Topologique"
        },
        {
            "location": "/rules/topologique/#prise-en-compte-de-regles-topologiques",
            "text": "Le fonctionnement de base de SimPLU3D qui consiste \u00e0 tirer des valeurs al\u00e9atoires dans un espace continu rend difficile l'application de contraintes topologiques. Si on prend l'exemple de l'alignement aux limites s\u00e9paratives donnant sur une route (cf image ci-dessous), il est totalement improbable que SimPLU3D effectue le tirage d'une bo\u00eete respectant cet alignement (cela revient \u00e0 tirer exactement le bonne valeur de x,y,w et \u03b8). Deux strat\u00e9gies sont possibles pour utiliser de telles r\u00e8gles.",
            "title": "Prise en compte de r\u00e8gles topologiques"
        },
        {
            "location": "/rules/topologique/#strategie-1-transformation-en-contrainte-geometrique",
            "text": "La strat\u00e9gie na\u00efve consisterait \u00e0 transformer la contrainte topologique en contrainte g\u00e9om\u00e9trique. Par exemple, de v\u00e9rifier si l'un des c\u00f4t\u00e9s de la bo\u00eete est inclus dans un buffer de petite taille autour de la limite donnant sur la voirie.  Cela rend probable la proposition de bo\u00eetes par le syst\u00e8me respectant cette r\u00e8gle, mais comme cette probabilit\u00e9 reste relativement faible, il peut \u00eatre n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations afin d'atteindre un r\u00e9sultat optimis\u00e9.",
            "title": "Strat\u00e9gie 1 : transformation en contrainte g\u00e9om\u00e9trique"
        },
        {
            "location": "/rules/topologique/#strategie-2-generation-de-boites-alignees",
            "text": "La seconde strat\u00e9gie consiste \u00e0 non plus g\u00e9n\u00e9rer des bo\u00eetes libres, mais des bo\u00eetes directement align\u00e9es sur la limite consid\u00e9r\u00e9e. Il s'agit ainsi de d\u00e9finir un nouveau g\u00e9n\u00e9rateur de forme (comme d\u00e9crit dans la section  G\u00e9n\u00e9rateur de formes - G\u00e9n\u00e9rer d'autres types de formes ).  Dans ce cas, la g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e est non plus une bo\u00eete \u00e0 6 dimensions (  b  = ( x ,  y ,  l ,  w ,  h ,  \u03b8 )), mais un bo\u00eete parall\u00e8le \u00e0 4 dimensions (  bp  = ( x ,  y ,  l ,  h ), en consid\u00e9rant que l'orientation et la largeur sont impos\u00e9es par les coordonn\u00e9es du centre de l'objet.",
            "title": "Strat\u00e9gie 2 :  g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es"
        },
        {
            "location": "/rules/topologique/#executable-pour-la-generation-de-boites-alignees",
            "text": "Dans le projet SimPLU3D-tutorial, une classe a \u00e9t\u00e9 ajout\u00e9e sur la base de l'exemple de base pour effectuer des simulation avec des bo\u00eetes qui seraient align\u00e9es \u00e0 la limite donnant sur la voirie. Il s'agit de la classe :  fr.ign.simplu3d.topologicRule.ParallelSimulator    // NEW HERE THE PARALELLE OPTIMOIZER IS USED\n  ParallelCuboidOptimizer oCB = new ParallelCuboidOptimizer();\n\n  // IT REQUIRES AS INPUT THE GEOMETRY WHERE THE CUBOIDS HAVE TO BE ALIGNED\n  IGeometry[] limits = createRoadLimits(bPU);\n\n  // Run of the optimisation on a parcel with the predicate\n  GraphConfiguration<Cuboid> cc = oCB.process(Random.random(), bPU, p, env, 0, pred, limits, bPU.getGeom());  La diff\u00e9rence avec le code d'exemple de base tient en deux lignes :   la r\u00e9cup\u00e9ration des limites le long desquelles les bo\u00eetes seront align\u00e9es ;  l'utilisation du simulateur sp\u00e9cifique aux bo\u00eetes align\u00e9es (classe  fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.paralellcuboid.ParallelCuboidOptimizer )   Le r\u00e9sultat est celui de la figure suivante. On visualise bien que la bo\u00eetes est align\u00e9e avec la limite s\u00e9parative ce qui fait que le r\u00e9sultat optimis\u00e9 n'occupe pas l'int\u00e9rieur du L.",
            "title": "Ex\u00e9cutable pour la g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es"
        },
        {
            "location": "/rules/topologique/#definition-de-loptimiseur",
            "text": "L'optimiseur est d\u00e9fini comme g\u00e9n\u00e9rant des objets de la classe   fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.simple.ParallelCuboid  du projet SimPLU3D compos\u00e9 de 4 dimensions. N\u00e9anmoins, cette classe poss\u00e8de les attributs orientation et width pour permettre de g\u00e9n\u00e9rer la forme de la bo\u00eete.  La diff\u00e9rence principale avec la simulation du b\u00e2timent en L se situe au niveau du builder (classe  fr.ign.cogit.simplu3d.rjmcmc.cuboid.builder.ParallelCuboidBuilder  du projet SimPLU3D). Le builder est d\u00e9fini comme ayant 4 dimensions mais il va bien renseigner les 6 dimensions de l'objet   ParallelCuboid .  Pour d\u00e9terminer la largeur et l'orientation, une projection est effectu\u00e9e depuis le point tir\u00e9 al\u00e9atoirement vers la limite sur laquelle la forme est align\u00e9e. La longueur de la projection d\u00e9termine la moiti\u00e9 de la largeur de la bo\u00eete et son azimut l'orientation de la bo\u00eete (cf code ci-dessous).  @Override\npublic Cuboid build(double[] coordinates) {\n  Coordinate p = new Coordinate(coordinates[0], coordinates[1]);\n  DistanceOp op = new DistanceOp(this.limits, factory.createPoint(p));\n  Coordinate projected = op.nearestPoints()[0];\n  double distance = op.distance();\n  double orientation = Angle.angle(p, projected);\n  AbstractParallelCuboid result;\n  if (bandType == 1) {\n\n    result = new ParallelCuboid(coordinates[0], coordinates[1], coordinates[2], distance * 2,\n        coordinates[3], orientation + Math.PI / 2);\n\n  } else {\n    result = new ParallelCuboid2(coordinates[0], coordinates[1], coordinates[2], distance * 2,\n        coordinates[3], orientation + Math.PI / 2);\n  }\n  return result;\n}  Tous les autres aspects (impl\u00e9mentation des noyaux de proposition et du sampler) sont d\u00e9finis de la m\u00eame mani\u00e8re que vu pr\u00e9c\u00e9demment mais adapt\u00e9s pour ces objets \u00e0 4 dimensions.",
            "title": "D\u00e9finition de l'optimiseur"
        },
        {
            "location": "/visitor/intro/",
            "text": "Principe des visiteurs\n\uf0c1\n\n\nLes visiteurs sont des objets qui permettent de suivre l'\u00e9volution d'une simulation en produisant r\u00e9guli\u00e8rement des sorties. Les visiteurs impl\u00e9mentent l'interface de la libjrmcmc4j \nVisitor\n, M extends Modification\n>\n. Pour un visiteur, il est possible de d\u00e9finir deux types de sorties :\n\n\n\n\nles dumps\n, qui sont des sorties rapides en termes d'ex\u00e9cution qui sont effectu\u00e9es fr\u00e9quemment ;\n\n\nles saves\n, qui sont des sorties plus lentes en termes d'ex\u00e9cution et qui sont effectu\u00e9es moins fr\u00e9quemment.\n\n\n\n\nL'interface impose l'impl\u00e9mentation de 4 m\u00e9thodes :\n\n\n\n\ninit(int dump, int save)\n :  initialisation du visiteur avant la simulation (notamment avec l'affectation des valeurs dump et save qui correspondent \u00e0 la fr\u00e9quence de production ds sorties dump et save);\n\n\nbegin(C config, Sampler\n sampler, Temperature t);\n : cette m\u00e9thode qui est ex\u00e9cut\u00e9e au d\u00e9but de la simulation ;\n\n\nvisit(C config, Sampler\n sampler, Temperature t);\n : cette m\u00e9thode est ex\u00e9cut\u00e9e \u00e0 chaque it\u00e9ration, c'est ici que l'on distinguera les op\u00e9rations de save et de dump avec par exemple un test de ce type :  \nif ((save > 0) && (iter % save == 0)) {\n;\n\n\nend(C config, Sampler\n sampler, Temperature t);\n : cette m\u00e9thode est appliqu\u00e9e lors de la toute derni\u00e8re it\u00e9ration de la simulation.\n\n\n\n\nDans le cadre de l'utilisation de SimPLU3D, plusieurs visiteurs ont \u00e9t\u00e9 impl\u00e9ment\u00e9s et sont activables et param\u00e9trables via le fichier \nparams.json\n. Les valeurs \nsave\n et \ndump\n peuvent notamment y \u00eatre d\u00e9finis pour tous les visiteurs. Vous pouvez tester ces visiteurs avec la simulation de base et pour toutes les autres. Les param\u00e8tres ont \u00e9t\u00e9 correctement fix\u00e9s, il suffit seulement de les activer et de mettre \u00e0 jour le param\u00e8tre \nsave\n et \nbackground_img\n.\n\n\nVisiteurs de SimPLU3D\n\uf0c1\n\n\nSortie console : OutPutStreamVisitor\n\uf0c1\n\n\nL'\nOutPutStreamVisitor\n est le visiteur qui affiche dans la console l'\u00e9tat d'avancement des simulations. Il est activable par la valeur \noutputstreamvisitor\n.\n\n\n\n\n\n\n\n\nNom de la colonne\n\n\nDecription\n\n\n\n\n\n\n\n\n\n\nIteration\n\n\nNum\u00e9ro de l'it\u00e9ration courante\n\n\n\n\n\n\nObjects\n\n\nNombre d'objets dans la configuration courante\n\n\n\n\n\n\nA - Nom de noyau\n\n\nProbabilit\u00e9 moyenne (sur les \ndump\n derni\u00e8re it\u00e9rations) que le noyau concern\u00e9 soit choisi\n\n\n\n\n\n\nP - Nom du noyau\n\n\nProbabilit\u00e9 moyenne (sur les \ndump\n derni\u00e8re it\u00e9rations) que l'application de la modification du noyau soit accept\u00e9e\n\n\n\n\n\n\nTemp\n\n\nValeur de la temp\u00e9rature\n\n\n\n\n\n\nAccept\n\n\nProbabilit\u00e9 moyenne (sur les \ndump\n derni\u00e8re it\u00e9rations) qu'une modification soit accept\u00e9e\n\n\n\n\n\n\nTime (ms)\n\n\nTemps d'ex\u00e9cution\n\n\n\n\n\n\nu_1\n\n\nValeur de l'\u00e9nergie unaire\n\n\n\n\n\n\nu_2\n\n\nValeur de l'\u00e9nergie binaire\n\n\n\n\n\n\nu\n\n\nValeur de l'\u00e9nergie combin\u00e9e\n\n\n\n\n\n\n\n\nSortie shapefile : ShapefileVisitor\n\uf0c1\n\n\nLe \nShapefileVisitor\n  est le visiteur qui permet de sauvegarder des shapefiles toutes les \nsave\n it\u00e9ration. Il est activables par la valeur \nshapefilewriter\n.\n\n\nIl est n\u00e9cessaire \u00e9galement de param\u00e9trer la valeur \nresult\n qui indique le dossier dans lequel les ShapeFiles seront export\u00e9s. Ils portent comme nom le num\u00e9ro de l'it\u00e9ration et les objets sauvegard\u00e9s auront comme attributs la valeur d'\u00e9nergie et de la m\u00e9thode \ntoString()\n.\n\n\nSortie sous forme de graphique : StatsVisitor\n\uf0c1\n\n\nLe \nStatsVisitor\n permet la repr\u00e9sentation de l'\u00e9volution de l'\u00e9nergie au cours de la simulation sous forme d'un graphique. Il est activable par la valeur \nstatsvisitor\n.\n\n\nPlusieurs informations sont repr\u00e9sent\u00e9es comme l'\u00e9nergie unaire, l'\u00e9nergie binaire, l'\u00e9nergie de la meilleure configuration rencontr\u00e9 et l'\u00e9nergie de la configuration actuel. L'image ci-dessous pr\u00e9sente le graphique qui peut \u00eatre visualis\u00e9.\n\n\n\n\nPetite astuce\n : comme le r\u00e9sultat d'une simulation est la derni\u00e8re configuration rencontr\u00e9e, ce graphique est utile pour visualiser si le meilleur candidat rencontr\u00e9 est bien cette derni\u00e8re configuration. Normalement, si le processus d'optimisation s'est bien d\u00e9roul\u00e9, les courbes \"Meilleur candidat\" et \"\u00c9nergie de la configuration actuelle\" doivent \u00eatre confondus en fin de simulation. Sinon, il peut s'av\u00e9rer n\u00e9cessaire  d'augmenter le nombre d'it\u00e9rations, la temp\u00e9rature et le coefficient de d\u00e9croissance.\n\n\nSortie CSV : CSVvisitor et CSVendStats\n\uf0c1\n\n\nDeux visiteurs permettent l'export de sorties sous forme de CSV : \nCSVvisitor\n et \nCSVendStats\n activables respectivement avec les valeurs \ncsvvisitor\n et \ncsvvisitorend\n.\n\n\nDans les deux cas, la valeur de \nresult\n d\u00e9termine le dossier de stockage des fichiers qui s'appelleront \ncsvfilename\n et \ncsvfilenamend\n.\n\n\nLe premier CSV contient une ligne par it\u00e9ration et stock des informations sur la configuration courante : num\u00e9ro de l'it\u00e9ration, taille de la configuration, \u00e9nergie de la configuration courante et \u00e9nergie moyenne sur les \ndump\n derni\u00e8res it\u00e9rations.\n\n\nLe second CSV contient les information de fin de simulation par parcelle (pratique lorsque l'on effectue des simulations sur de nombreuses parcelles) et notamment, le nombre d'it\u00e9rations, le temps d'ex\u00e9cution, la taille de la configuration et l'\u00e9nergie finale.\n\n\nVisualisation 3D \u00e0 la vol\u00e9e des r\u00e9sultats : ViewerVisitor\n\uf0c1\n\n\nLe \nViewerVisitor\n permet de visualiser en 3D les \u00e9volutions de la simulation en cours. Il est activable par la valeur \nvisitorviewer\n et permet de repr\u00e9senter les donn\u00e9es charg\u00e9es et la simulation avec une mise \u00e0 jour toutes les \ndump\n it\u00e9rations.\n\n\nQuelques options d'affichage sont disponibles, comme le fait d'activer un plan contenant une image fixe avec l'option \nshowbackground\n. Il est n\u00e9cessaire de fixer le chemin absolu vers l'image utilis\u00e9e \nbackground_img\n (\u00e0 mettre \u00e0 jour comme le chemin est absolu) et l'altitude de ce plan (valeur \nz\n.). Les coordonn\u00e9es de ce plan sont fix\u00e9es par les valeurs \nxminbg\n, \nyminbg\n, \nxmaxbg\n et \nymaxbg\n. Il est \u00e9galement possible de choisir la couleur du fond de sc\u00e8ne avec les options \nfilmvisitorr\n, \nfilmvisitorg\n et \nfilmvisitorb\":\"180\n.\n\n\nLors de l'utilisation de ce visiteur, la cam\u00e9ra se positionnera au centre de la sc\u00e8ne.\n\n\n\n\n \nAttention\n: : pour ce visiteur, la visualisation 3D n\u00e9cessite l'utilisation de la biblioth\u00e8que native de Java 3D (qui se trouve dans le projet). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant :\n\n\n-Djava.library.path=./lib/native_libraries/linux-amd64\n  \n\n\nLa ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.\n\n\n\n\nExport d'image \u00e0 la vol\u00e9e : FilmVisitor\n\uf0c1\n\n\nLe \nFilmVisitor\n permet d'exporter le rendu des simulations sous forme de .jpeg toutes les \ndump\n it\u00e9rations. Si le \nStatsVisitor\n est activ\u00e9, l'image de la simulation et l'image de ce visiteur se retrouvent conjointement export\u00e9es (cf image ci-dessous).\n\n\n\n\nLes param\u00e8tres du \nFilmVisitor\n sont tout d'abord ceux du \nViewerVisitor\n. Il est \u00e9galement n\u00e9cessaire de d\u00e9finir la valeur \nsave\n pour d\u00e9signer le r\u00e9pertoire dans lequel les images seront export\u00e9es.\n\n\nIl est \u00e9galement n\u00e9cessaire de d\u00e9finir les coordonn\u00e9es de la position de la cam\u00e9ra avec les coordonn\u00e9es \nfilmvisitorx\n, \nfilmvisitory\n et \nfilmvisitorz\n  et la direction dans laquelle regarde la cam\u00e9ra avec les coordonn\u00e9es : \nfilmvisitorvecty\n, \nfilmvisitorvectx\n et \nfilmvisitorvectz\n.\n\n\nUtilisation d'autres visiteurs\n\uf0c1\n\n\nIl est totalement possible d'impl\u00e9menter d'autres visiteurs en \u00e9tendant l'interface \nVisitor\n, M extends Modification\n>\n. Pour les optimiseur d\u00e9j\u00e0 d\u00e9finis, la classe \nfr.ign.cogit.simplu3d.rjmcmc.generic.visitor.PrepareVisitors\n du projet SimPLU3D permet d'initialiser les visiteurs et d'en rajouter d'autres via la liste \nlSupplementaryVisitors\n.\n\n\nSinon, de mani\u00e8re g\u00e9n\u00e9rale les visiteurs sont pass\u00e9s en param\u00e8tre de la m\u00e9thode qui lance l'optimisation \nSimulatedAnnealing.optimize\n qui prend un objet de la classe \nCompositeVisitor\n en param\u00e8tre. L'instanciation d'un \nCompositeVisitor\n ne requiert qu'une liste de visiteur comme montr\u00e9 dans le code ci-dessous.\n\n\n  List<Visitor<GraphConfiguration<C>, BirthDeathModification<C>>> list = new ArrayList<>();\n  list.addAll(lSupplementaryVisitors);\n    CompositeVisitor<GraphConfiguration<C>, BirthDeathModification<C>> mVisitor = new CompositeVisitor<>(list);",
            "title": "Intro"
        },
        {
            "location": "/visitor/intro/#principe-des-visiteurs",
            "text": "Les visiteurs sont des objets qui permettent de suivre l'\u00e9volution d'une simulation en produisant r\u00e9guli\u00e8rement des sorties. Les visiteurs impl\u00e9mentent l'interface de la libjrmcmc4j  Visitor , M extends Modification > . Pour un visiteur, il est possible de d\u00e9finir deux types de sorties :   les dumps , qui sont des sorties rapides en termes d'ex\u00e9cution qui sont effectu\u00e9es fr\u00e9quemment ;  les saves , qui sont des sorties plus lentes en termes d'ex\u00e9cution et qui sont effectu\u00e9es moins fr\u00e9quemment.   L'interface impose l'impl\u00e9mentation de 4 m\u00e9thodes :   init(int dump, int save)  :  initialisation du visiteur avant la simulation (notamment avec l'affectation des valeurs dump et save qui correspondent \u00e0 la fr\u00e9quence de production ds sorties dump et save);  begin(C config, Sampler  sampler, Temperature t);  : cette m\u00e9thode qui est ex\u00e9cut\u00e9e au d\u00e9but de la simulation ;  visit(C config, Sampler  sampler, Temperature t);  : cette m\u00e9thode est ex\u00e9cut\u00e9e \u00e0 chaque it\u00e9ration, c'est ici que l'on distinguera les op\u00e9rations de save et de dump avec par exemple un test de ce type :   if ((save > 0) && (iter % save == 0)) { ;  end(C config, Sampler  sampler, Temperature t);  : cette m\u00e9thode est appliqu\u00e9e lors de la toute derni\u00e8re it\u00e9ration de la simulation.   Dans le cadre de l'utilisation de SimPLU3D, plusieurs visiteurs ont \u00e9t\u00e9 impl\u00e9ment\u00e9s et sont activables et param\u00e9trables via le fichier  params.json . Les valeurs  save  et  dump  peuvent notamment y \u00eatre d\u00e9finis pour tous les visiteurs. Vous pouvez tester ces visiteurs avec la simulation de base et pour toutes les autres. Les param\u00e8tres ont \u00e9t\u00e9 correctement fix\u00e9s, il suffit seulement de les activer et de mettre \u00e0 jour le param\u00e8tre  save  et  background_img .",
            "title": "Principe des visiteurs"
        },
        {
            "location": "/visitor/intro/#visiteurs-de-simplu3d",
            "text": "",
            "title": "Visiteurs de SimPLU3D"
        },
        {
            "location": "/visitor/intro/#sortie-console-outputstreamvisitor",
            "text": "L' OutPutStreamVisitor  est le visiteur qui affiche dans la console l'\u00e9tat d'avancement des simulations. Il est activable par la valeur  outputstreamvisitor .     Nom de la colonne  Decription      Iteration  Num\u00e9ro de l'it\u00e9ration courante    Objects  Nombre d'objets dans la configuration courante    A - Nom de noyau  Probabilit\u00e9 moyenne (sur les  dump  derni\u00e8re it\u00e9rations) que le noyau concern\u00e9 soit choisi    P - Nom du noyau  Probabilit\u00e9 moyenne (sur les  dump  derni\u00e8re it\u00e9rations) que l'application de la modification du noyau soit accept\u00e9e    Temp  Valeur de la temp\u00e9rature    Accept  Probabilit\u00e9 moyenne (sur les  dump  derni\u00e8re it\u00e9rations) qu'une modification soit accept\u00e9e    Time (ms)  Temps d'ex\u00e9cution    u_1  Valeur de l'\u00e9nergie unaire    u_2  Valeur de l'\u00e9nergie binaire    u  Valeur de l'\u00e9nergie combin\u00e9e",
            "title": "Sortie console : OutPutStreamVisitor"
        },
        {
            "location": "/visitor/intro/#sortie-shapefile-shapefilevisitor",
            "text": "Le  ShapefileVisitor   est le visiteur qui permet de sauvegarder des shapefiles toutes les  save  it\u00e9ration. Il est activables par la valeur  shapefilewriter .  Il est n\u00e9cessaire \u00e9galement de param\u00e9trer la valeur  result  qui indique le dossier dans lequel les ShapeFiles seront export\u00e9s. Ils portent comme nom le num\u00e9ro de l'it\u00e9ration et les objets sauvegard\u00e9s auront comme attributs la valeur d'\u00e9nergie et de la m\u00e9thode  toString() .",
            "title": "Sortie shapefile : ShapefileVisitor"
        },
        {
            "location": "/visitor/intro/#sortie-sous-forme-de-graphique-statsvisitor",
            "text": "Le  StatsVisitor  permet la repr\u00e9sentation de l'\u00e9volution de l'\u00e9nergie au cours de la simulation sous forme d'un graphique. Il est activable par la valeur  statsvisitor .  Plusieurs informations sont repr\u00e9sent\u00e9es comme l'\u00e9nergie unaire, l'\u00e9nergie binaire, l'\u00e9nergie de la meilleure configuration rencontr\u00e9 et l'\u00e9nergie de la configuration actuel. L'image ci-dessous pr\u00e9sente le graphique qui peut \u00eatre visualis\u00e9.   Petite astuce  : comme le r\u00e9sultat d'une simulation est la derni\u00e8re configuration rencontr\u00e9e, ce graphique est utile pour visualiser si le meilleur candidat rencontr\u00e9 est bien cette derni\u00e8re configuration. Normalement, si le processus d'optimisation s'est bien d\u00e9roul\u00e9, les courbes \"Meilleur candidat\" et \"\u00c9nergie de la configuration actuelle\" doivent \u00eatre confondus en fin de simulation. Sinon, il peut s'av\u00e9rer n\u00e9cessaire  d'augmenter le nombre d'it\u00e9rations, la temp\u00e9rature et le coefficient de d\u00e9croissance.",
            "title": "Sortie sous forme de graphique : StatsVisitor"
        },
        {
            "location": "/visitor/intro/#sortie-csv-csvvisitor-et-csvendstats",
            "text": "Deux visiteurs permettent l'export de sorties sous forme de CSV :  CSVvisitor  et  CSVendStats  activables respectivement avec les valeurs  csvvisitor  et  csvvisitorend .  Dans les deux cas, la valeur de  result  d\u00e9termine le dossier de stockage des fichiers qui s'appelleront  csvfilename  et  csvfilenamend .  Le premier CSV contient une ligne par it\u00e9ration et stock des informations sur la configuration courante : num\u00e9ro de l'it\u00e9ration, taille de la configuration, \u00e9nergie de la configuration courante et \u00e9nergie moyenne sur les  dump  derni\u00e8res it\u00e9rations.  Le second CSV contient les information de fin de simulation par parcelle (pratique lorsque l'on effectue des simulations sur de nombreuses parcelles) et notamment, le nombre d'it\u00e9rations, le temps d'ex\u00e9cution, la taille de la configuration et l'\u00e9nergie finale.",
            "title": "Sortie CSV : CSVvisitor et CSVendStats"
        },
        {
            "location": "/visitor/intro/#visualisation-3d-a-la-volee-des-resultats-viewervisitor",
            "text": "Le  ViewerVisitor  permet de visualiser en 3D les \u00e9volutions de la simulation en cours. Il est activable par la valeur  visitorviewer  et permet de repr\u00e9senter les donn\u00e9es charg\u00e9es et la simulation avec une mise \u00e0 jour toutes les  dump  it\u00e9rations.  Quelques options d'affichage sont disponibles, comme le fait d'activer un plan contenant une image fixe avec l'option  showbackground . Il est n\u00e9cessaire de fixer le chemin absolu vers l'image utilis\u00e9e  background_img  (\u00e0 mettre \u00e0 jour comme le chemin est absolu) et l'altitude de ce plan (valeur  z .). Les coordonn\u00e9es de ce plan sont fix\u00e9es par les valeurs  xminbg ,  yminbg ,  xmaxbg  et  ymaxbg . Il est \u00e9galement possible de choisir la couleur du fond de sc\u00e8ne avec les options  filmvisitorr ,  filmvisitorg  et  filmvisitorb\":\"180 .  Lors de l'utilisation de ce visiteur, la cam\u00e9ra se positionnera au centre de la sc\u00e8ne.     Attention : : pour ce visiteur, la visualisation 3D n\u00e9cessite l'utilisation de la biblioth\u00e8que native de Java 3D (qui se trouve dans le projet). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant :  -Djava.library.path=./lib/native_libraries/linux-amd64     La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.",
            "title": "Visualisation 3D \u00e0 la vol\u00e9e des r\u00e9sultats : ViewerVisitor"
        },
        {
            "location": "/visitor/intro/#export-dimage-a-la-volee-filmvisitor",
            "text": "Le  FilmVisitor  permet d'exporter le rendu des simulations sous forme de .jpeg toutes les  dump  it\u00e9rations. Si le  StatsVisitor  est activ\u00e9, l'image de la simulation et l'image de ce visiteur se retrouvent conjointement export\u00e9es (cf image ci-dessous).   Les param\u00e8tres du  FilmVisitor  sont tout d'abord ceux du  ViewerVisitor . Il est \u00e9galement n\u00e9cessaire de d\u00e9finir la valeur  save  pour d\u00e9signer le r\u00e9pertoire dans lequel les images seront export\u00e9es.  Il est \u00e9galement n\u00e9cessaire de d\u00e9finir les coordonn\u00e9es de la position de la cam\u00e9ra avec les coordonn\u00e9es  filmvisitorx ,  filmvisitory  et  filmvisitorz   et la direction dans laquelle regarde la cam\u00e9ra avec les coordonn\u00e9es :  filmvisitorvecty ,  filmvisitorvectx  et  filmvisitorvectz .",
            "title": "Export d'image \u00e0 la vol\u00e9e : FilmVisitor"
        },
        {
            "location": "/visitor/intro/#utilisation-dautres-visiteurs",
            "text": "Il est totalement possible d'impl\u00e9menter d'autres visiteurs en \u00e9tendant l'interface  Visitor , M extends Modification > . Pour les optimiseur d\u00e9j\u00e0 d\u00e9finis, la classe  fr.ign.cogit.simplu3d.rjmcmc.generic.visitor.PrepareVisitors  du projet SimPLU3D permet d'initialiser les visiteurs et d'en rajouter d'autres via la liste  lSupplementaryVisitors .  Sinon, de mani\u00e8re g\u00e9n\u00e9rale les visiteurs sont pass\u00e9s en param\u00e8tre de la m\u00e9thode qui lance l'optimisation  SimulatedAnnealing.optimize  qui prend un objet de la classe  CompositeVisitor  en param\u00e8tre. L'instanciation d'un  CompositeVisitor  ne requiert qu'une liste de visiteur comme montr\u00e9 dans le code ci-dessous.    List<Visitor<GraphConfiguration<C>, BirthDeathModification<C>>> list = new ArrayList<>();\n  list.addAll(lSupplementaryVisitors);\n    CompositeVisitor<GraphConfiguration<C>, BirthDeathModification<C>> mVisitor = new CompositeVisitor<>(list);",
            "title": "Utilisation d'autres visiteurs"
        }
    ]
}