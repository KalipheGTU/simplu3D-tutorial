{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation de SimPLU3D \uf0c1 SimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties 3D en optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utilis\u00e9s pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementations locales d'urbanisme) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisation ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation GitHub SimPLU3D . Principe de fonctionnement de SimPLU3D \uf0c1 Cette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de Plans Locaux d'Urbanisme (PLU) et permet de r\u00e9pondre \u00e0 ce type de questions : Quelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ? Comment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU ? Est-ce que des b\u00e2timents produisant une ombre trop importante sur les parcelles voisines risquent d'\u00eatre construits ? SimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter la liste des r\u00e9alisations et publications . SimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire LASTIG de l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . N'h\u00e9sitez pas \u00e0 nous contacter pour nous fait un retour sur SimPLU3D ou pour utiliser le code. Cette documentation a pour but de montrer comment utiliser et param\u00e9trer l'approche SimPLU3D en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation (par ici) . La conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se : Brasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014 M\u00e9moire , Pr\u00e9sentation","title":"Accueil"},{"location":"#documentation-de-simplu3d","text":"SimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties 3D en optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utilis\u00e9s pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementations locales d'urbanisme) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisation ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation GitHub SimPLU3D .","title":"Documentation de SimPLU3D"},{"location":"#principe-de-fonctionnement-de-simplu3d","text":"Cette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de Plans Locaux d'Urbanisme (PLU) et permet de r\u00e9pondre \u00e0 ce type de questions : Quelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ? Comment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU ? Est-ce que des b\u00e2timents produisant une ombre trop importante sur les parcelles voisines risquent d'\u00eatre construits ? SimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter la liste des r\u00e9alisations et publications . SimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire LASTIG de l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . N'h\u00e9sitez pas \u00e0 nous contacter pour nous fait un retour sur SimPLU3D ou pour utiliser le code. Cette documentation a pour but de montrer comment utiliser et param\u00e9trer l'approche SimPLU3D en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation (par ici) . La conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se : Brasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014 M\u00e9moire , Pr\u00e9sentation","title":"Principe de fonctionnement de SimPLU3D"},{"location":"about/","text":"En savoir plus sur le projet SimPLU3D \uf0c1 Contributeurs \uf0c1 Micka\u00ebl Brasebin : chercheur LASTIG - IGN ; Julien Perret : chercheur LASTIG - IGN ; Micka\u00ebl Borne : d\u00e9veloppeur SAI - IGN ; Paul Chapron : chercheur LASTIG - IGN ; Imran Lokhat : d\u00e9veloppeur LASTIG - IGN ; Maxime Colomb : doctorant LASTIG - IGN . Financeurs \uf0c1 SimPLU3D est un projet d\u00e9velopp\u00e9 par des chercheurs et ing\u00e9nieurs du laboratoire LASTIG et financ\u00e9 majoritairement par l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . Le projet a \u00e9galement \u00e9t\u00e9 financ\u00e9 par le fond FUI du projet TerraMagna et la r\u00e9gion Ile-de-France \u00e0 travers le projet FEDER e-PLU. Contacts \uf0c1 Vous pouvez contacter Julien Perret ou Micka\u00ebl Brasebin ({nom.pr\u00e9nom} (AT) {gmail} (POINT) {com}) pour discuter de l'utilisation de SimPLU3D. Pour signaler un bug n'h\u00e9sitez pas \u00e0 poster une issue sur le ou les projets concern\u00e9s.","title":"\u00c0 propos"},{"location":"about/#en-savoir-plus-sur-le-projet-simplu3d","text":"","title":"En savoir plus sur le projet SimPLU3D"},{"location":"about/#contributeurs","text":"Micka\u00ebl Brasebin : chercheur LASTIG - IGN ; Julien Perret : chercheur LASTIG - IGN ; Micka\u00ebl Borne : d\u00e9veloppeur SAI - IGN ; Paul Chapron : chercheur LASTIG - IGN ; Imran Lokhat : d\u00e9veloppeur LASTIG - IGN ; Maxime Colomb : doctorant LASTIG - IGN .","title":"Contributeurs"},{"location":"about/#financeurs","text":"SimPLU3D est un projet d\u00e9velopp\u00e9 par des chercheurs et ing\u00e9nieurs du laboratoire LASTIG et financ\u00e9 majoritairement par l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . Le projet a \u00e9galement \u00e9t\u00e9 financ\u00e9 par le fond FUI du projet TerraMagna et la r\u00e9gion Ile-de-France \u00e0 travers le projet FEDER e-PLU.","title":"Financeurs"},{"location":"about/#contacts","text":"Vous pouvez contacter Julien Perret ou Micka\u00ebl Brasebin ({nom.pr\u00e9nom} (AT) {gmail} (POINT) {com}) pour discuter de l'utilisation de SimPLU3D. Pour signaler un bug n'h\u00e9sitez pas \u00e0 poster une issue sur le ou les projets concern\u00e9s.","title":"Contacts"},{"location":"bibliographie/","text":"Bibliographie \uf0c1 Quelques ressources pour aller plus loin : L'ensemble de la conception de SimPLU3D est d\u00e9crit dans la th\u00e8se de Micka\u00ebl Brasebin : Brasebin, M., Apr. 2014. Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti. Ph.D. thesis, Universit\u00e9 Paris-Est. M\u00e9moire , Pr\u00e9sentation Le mod\u00e8le g\u00e9ographique et la d\u00e9finition de r\u00e8gles en OCL : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014. . La g\u00e9n\u00e9ration de formes b\u00e2ties : Brasebin M., Perret, J., Musti\u00e8re S., Weber C. (2017) 3D urban data to assess local urban regulation influence, Computers, Environment and Urban Systems, 2017, ISSN 0198-9715, https://doi.org/10.1016/j.compenvurbsys.2017.10.002 Les cas d'usage autour du couplage entre SimPLU3D et OpenMOLE : Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017). Article , Pr\u00e9sentation Le recuit simul\u00e9 et la librjmcmc (https://github.com/IGNF/librjmcmc4j) : Bre\u0301dif, M., Tournaire, O., Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. Exp\u00e9rimentations et r\u00e9alisations : \uf0c1 Simulation de la constructibilit\u00e9 en Ile-de-France (2015 - 2019) : il s'agit d'un projet en collaboration avec l' IAUIDF et la DRIEA visant \u00e0 \u00e9valuer le potentiel de l'approche SimPLU3D pour d\u00e9terminer la constructibilit\u00e9 \u00e0 l'\u00e9chelle de l'IDF. (Pour en savoir plus, (Brasebin et al, 2017), Code ) ; D\u00e9monstrateur pour l'aide \u00e0 la conception de PLU : ce projet en partenariat avec l' ISC-PIF vise \u00e0 \u00e9valuer ce qu'il est possible \u00e0 l'\u00e9chelle d'un \u00eelot en faisant varier les param\u00e8tres du PLU (Pour en savoir plus, voir (Brasebin et al, 2017), Code , D\u00e9monstrateur ) ; PLU++ : vers une concertation plus participative et plus efficace de PLU (2015 - 2017) : dans le cadre de ce projet de recherche en collaboration avec l' EIVP , une r\u00e9flexion a \u00e9t\u00e9 men\u00e9e sur la d\u00e9fintion des types de repr\u00e9sentation et des interactions \u00e0 utiliser dans ce contexte. (Pour en savoir plus, site Internet du projet ) ; D\u00e9monstrateur SimPLU3D pour l'instruction de permis de construire : site Internet de d\u00e9monstration pour montrer comment SimPLU3D peut faciliter l'instruction de permis de construire en v\u00e9rifiant automatiquement un certain nombre de r\u00e8gles d'urbanisme ( Site Internet du d\u00e9monstrateur ). ArtiScales : il s'agit d'un couplage avec le mod\u00e8le Mup-CITY pour la production de formes r\u00e9alistes de d\u00e9veloppement r\u00e9sidentiel, de l\u2019\u00e9chelle du b\u00e2timent \u00e0 celle de l\u2019ensemble d\u2019une r\u00e9gion urbaine dans le cadre du travail de th\u00e8se de Maxime Colomb . ( Organisation du projet ArtiScales ) ; DECODURBA : un outil pour aider le citoyen \u00e0 la construction d'une maison individuelle. Cette proposition a re\u00e7u un prix durant le hackhathon Hackhurba organis\u00e9 par le minist\u00e8re de la transition \u00e9cologique et sociale ( Site du hackhathon ). La vid\u00e9o ci-dessous montre en vid\u00e9o quelques r\u00e9sultats de ces r\u00e9alisations :","title":"R\u00e9alisations et bibliographie"},{"location":"bibliographie/#bibliographie","text":"Quelques ressources pour aller plus loin : L'ensemble de la conception de SimPLU3D est d\u00e9crit dans la th\u00e8se de Micka\u00ebl Brasebin : Brasebin, M., Apr. 2014. Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti. Ph.D. thesis, Universit\u00e9 Paris-Est. M\u00e9moire , Pr\u00e9sentation Le mod\u00e8le g\u00e9ographique et la d\u00e9finition de r\u00e8gles en OCL : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014. . La g\u00e9n\u00e9ration de formes b\u00e2ties : Brasebin M., Perret, J., Musti\u00e8re S., Weber C. (2017) 3D urban data to assess local urban regulation influence, Computers, Environment and Urban Systems, 2017, ISSN 0198-9715, https://doi.org/10.1016/j.compenvurbsys.2017.10.002 Les cas d'usage autour du couplage entre SimPLU3D et OpenMOLE : Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017). Article , Pr\u00e9sentation Le recuit simul\u00e9 et la librjmcmc (https://github.com/IGNF/librjmcmc4j) : Bre\u0301dif, M., Tournaire, O., Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing.","title":"Bibliographie"},{"location":"bibliographie/#experimentations-et-realisations","text":"Simulation de la constructibilit\u00e9 en Ile-de-France (2015 - 2019) : il s'agit d'un projet en collaboration avec l' IAUIDF et la DRIEA visant \u00e0 \u00e9valuer le potentiel de l'approche SimPLU3D pour d\u00e9terminer la constructibilit\u00e9 \u00e0 l'\u00e9chelle de l'IDF. (Pour en savoir plus, (Brasebin et al, 2017), Code ) ; D\u00e9monstrateur pour l'aide \u00e0 la conception de PLU : ce projet en partenariat avec l' ISC-PIF vise \u00e0 \u00e9valuer ce qu'il est possible \u00e0 l'\u00e9chelle d'un \u00eelot en faisant varier les param\u00e8tres du PLU (Pour en savoir plus, voir (Brasebin et al, 2017), Code , D\u00e9monstrateur ) ; PLU++ : vers une concertation plus participative et plus efficace de PLU (2015 - 2017) : dans le cadre de ce projet de recherche en collaboration avec l' EIVP , une r\u00e9flexion a \u00e9t\u00e9 men\u00e9e sur la d\u00e9fintion des types de repr\u00e9sentation et des interactions \u00e0 utiliser dans ce contexte. (Pour en savoir plus, site Internet du projet ) ; D\u00e9monstrateur SimPLU3D pour l'instruction de permis de construire : site Internet de d\u00e9monstration pour montrer comment SimPLU3D peut faciliter l'instruction de permis de construire en v\u00e9rifiant automatiquement un certain nombre de r\u00e8gles d'urbanisme ( Site Internet du d\u00e9monstrateur ). ArtiScales : il s'agit d'un couplage avec le mod\u00e8le Mup-CITY pour la production de formes r\u00e9alistes de d\u00e9veloppement r\u00e9sidentiel, de l\u2019\u00e9chelle du b\u00e2timent \u00e0 celle de l\u2019ensemble d\u2019une r\u00e9gion urbaine dans le cadre du travail de th\u00e8se de Maxime Colomb . ( Organisation du projet ArtiScales ) ; DECODURBA : un outil pour aider le citoyen \u00e0 la construction d'une maison individuelle. Cette proposition a re\u00e7u un prix durant le hackhathon Hackhurba organis\u00e9 par le minist\u00e8re de la transition \u00e9cologique et sociale ( Site du hackhathon ). La vid\u00e9o ci-dessous montre en vid\u00e9o quelques r\u00e9sultats de ces r\u00e9alisations :","title":"Exp\u00e9rimentations et r\u00e9alisations :"},{"location":"development/","text":"Futurs d\u00e9veloppements \uf0c1 Cette page liste les futurs d\u00e9veloppements pour les projets de SimPLU3D : Persistance de l'environnement g\u00e9ographique : pour l'instant, l'instanciation du mod\u00e8le et les \u00e9tapes d'int\u00e9gration s'effectuent lors de chaque chargement. Il pourrait \u00eatre n\u00e9cessaire de mettre en place un chargement direct des donn\u00e9es (c'est \u00e0 dire sans passer par les \u00e9tapes d'int\u00e9gration). Cela pourrait, par exemple, permettre de reprendre manuellement une \u00e9tape automatique du processus d'int\u00e9gration, comme l'affectation d'un type aux limites s\u00e9paratives de parcelles ou g\u00e9rer du versionnement. Gestion du multi-objet : SimPLU3D ne g\u00e9n\u00e8re actuellement que des objets d'une seule classe, pourtant la libjrmcmc4j permet de g\u00e9n\u00e9rer diff\u00e9rents objets de diff\u00e9rentes classes. Il pourrait \u00eatre int\u00e9ressant de mieux formaliser la gestion du multi-objet afin de g\u00e9n\u00e9rer simultan\u00e9ment diff\u00e9rents objets sur un parcelle comme par exemple, des formes b\u00e2ties, de la v\u00e9g\u00e9tation et des garages. Un premier exemple a \u00e9t\u00e9 mis en \u0153uvre dans ce code du projet SimPLU3D-IAUIDF , mais cet aspect n'est pas encore suffisamment bien formalis\u00e9 pour pouvoir \u00eatre simplement r\u00e9utilis\u00e9 dans les projets de SimPLU3D. Aspects architecturaux : les grammaires utilis\u00e9es dans SimPLU3D sont relativement simples, il s'agit d'un ensemble de formes sans lien les unes avec les autres sur lesquelles des contraintes sont ajout\u00e9es. Elles ne se basent pas sur des grammaires architecturales qui permettent de produire des b\u00e2timents r\u00e9alistes avec un haut niveau de d\u00e9tail. Il pourrait \u00eatre impl\u00e9ment\u00e9 des m\u00e9canismes plus complexes de formalisation des formes et d'optimisation comme ceux d\u00e9crits dans l'article ; Talton, J. O., Lou, Y., Lesser, S., Duke, J., M\u011bch, R., Koltun, V., Apr. 2011. Metropolis procedural modeling. ACM Trans. Graph. 30 (2). URL http://doi.acm.org/10.1145/1944846.1944851","title":"Futurs d\u00e9veloppements"},{"location":"development/#futurs-developpements","text":"Cette page liste les futurs d\u00e9veloppements pour les projets de SimPLU3D : Persistance de l'environnement g\u00e9ographique : pour l'instant, l'instanciation du mod\u00e8le et les \u00e9tapes d'int\u00e9gration s'effectuent lors de chaque chargement. Il pourrait \u00eatre n\u00e9cessaire de mettre en place un chargement direct des donn\u00e9es (c'est \u00e0 dire sans passer par les \u00e9tapes d'int\u00e9gration). Cela pourrait, par exemple, permettre de reprendre manuellement une \u00e9tape automatique du processus d'int\u00e9gration, comme l'affectation d'un type aux limites s\u00e9paratives de parcelles ou g\u00e9rer du versionnement. Gestion du multi-objet : SimPLU3D ne g\u00e9n\u00e8re actuellement que des objets d'une seule classe, pourtant la libjrmcmc4j permet de g\u00e9n\u00e9rer diff\u00e9rents objets de diff\u00e9rentes classes. Il pourrait \u00eatre int\u00e9ressant de mieux formaliser la gestion du multi-objet afin de g\u00e9n\u00e9rer simultan\u00e9ment diff\u00e9rents objets sur un parcelle comme par exemple, des formes b\u00e2ties, de la v\u00e9g\u00e9tation et des garages. Un premier exemple a \u00e9t\u00e9 mis en \u0153uvre dans ce code du projet SimPLU3D-IAUIDF , mais cet aspect n'est pas encore suffisamment bien formalis\u00e9 pour pouvoir \u00eatre simplement r\u00e9utilis\u00e9 dans les projets de SimPLU3D. Aspects architecturaux : les grammaires utilis\u00e9es dans SimPLU3D sont relativement simples, il s'agit d'un ensemble de formes sans lien les unes avec les autres sur lesquelles des contraintes sont ajout\u00e9es. Elles ne se basent pas sur des grammaires architecturales qui permettent de produire des b\u00e2timents r\u00e9alistes avec un haut niveau de d\u00e9tail. Il pourrait \u00eatre impl\u00e9ment\u00e9 des m\u00e9canismes plus complexes de formalisation des formes et d'optimisation comme ceux d\u00e9crits dans l'article ; Talton, J. O., Lou, Y., Lesser, S., Duke, J., M\u011bch, R., Koltun, V., Apr. 2011. Metropolis procedural modeling. ACM Trans. Graph. 30 (2). URL http://doi.acm.org/10.1145/1944846.1944851","title":"Futurs d\u00e9veloppements"},{"location":"export/","text":"Exporter des r\u00e9sultats de simulation \uf0c1 Export g\u00e9n\u00e9ral \uf0c1 Les objets produits par le simulateur sont stock\u00e9s dans une instance de la classe GraphConfiguration . Il est possible d'it\u00e9rer sur les objets g\u00e9n\u00e9r\u00e9s via le graphe associ\u00e9. Le code ci-dessous montrer comment exporter sous forme d'un ShapeFile les r\u00e9sultats d'une simulation : // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); // Witting the output IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>(); // For all generated boxes for (GraphVertex<Cuboid> v : cc.getGraph().vertexSet()) { // Output feature with generated geometry IFeature feat = new DefaultFeature(v.getValue().generated3DGeom()); iFeatC.add(feat); } ShapefileWriter.write(featC,\"tmp/result.shp\"); Export de bo\u00eetes \uf0c1 Comme les bo\u00eetes sont les objets actuellement les plus utilis\u00e9es comme sorties de SimPLU3D, diff\u00e9rentes m\u00e9thodes pour les exporter avec diff\u00e9rentes transformations ont \u00e9t\u00e9 impl\u00e9ment\u00e9es dans le projet SimPLU3D. Chacune des classes mentionn\u00e9es ci-dessous poss\u00e8de un main permettant leur utilisation. Export simple des bo\u00eetes \uf0c1 La classe fr.ign.cogit.simplu3d.io.shapefile.SaveGeneratedObjects permet d'exporter les bo\u00eetes en ShapeFile (m\u00e9thode saveShapefile ) ou dans une base PostGIS (m\u00e9thode save ) sous forme de MultiPolygon 3D (issus de la m\u00e9thode generated3DGeom ). Dans les donn\u00e9es en sortie, chaque ligne correspond \u00e0 une bo\u00eete. Export d\u00e9coup\u00e9 \uf0c1 Comme les bo\u00eetes g\u00e9n\u00e9r\u00e9es peuvent s'intersecter, ces intersections sont potentiellement des sources de probl\u00e8me pour calculer des indicateurs sur les formes r\u00e9sultantes ou pour les visualiser. Ainsi, la classe fr.ign.cogit.simplu3d.util.merge.SDPCalc permet d'exporter avec la m\u00e9thode getGeometryPairByGroup les bo\u00eetes sous la forme d'une partition des g\u00e9om\u00e9tries r\u00e9sultats avec une hauteur affect\u00e9e \u00e0 chaque patch. Le r\u00e9sultat contient pour chaque enregistrement un polygone 2D et une hauteur pour reg\u00e9n\u00e9rer la forme en 3D. Cet export facilite le calcul de la surface de plancher et de la surface 2D de la construction (m\u00e9thode process et m\u00e9thode processSurface ). Export fusionn\u00e9 \uf0c1 La classe fr.ign.cogit.simplu3d.util.merge.MergeCuboid propose une fusion 3D des bo\u00eetes r\u00e9sultantes via la m\u00e9thode mergeFromShapefile . Les faces int\u00e9rieures sont supprim\u00e9es et les bo\u00eetes g\u00e9n\u00e9r\u00e9es en 3D. Ce cas est tr\u00e8s utile pour la visualisation et le calcul de la surface ext\u00e9rieure avec la m\u00e9thode getSurface . L'attribut statique de cette classe zMIN permet de fixer l'altitude minimale au dessus de laquelle les bo\u00eetes seront extrud\u00e9es. Synth\u00e8se des exports \uf0c1 L'image ci-dessus illustre les diff\u00e9rents types d'exports. Si de base la vue 3D est la m\u00eame pour les trois r\u00e9sultats, les exports sont diff\u00e9rents dans leur mod\u00e9lisation des entit\u00e9s et des g\u00e9om\u00e9tries. La seconde partie de l'image montre dans une vue 2D la s\u00e9lection d'une entit\u00e9 (en jaune) dans les trois types d'export : Export simple : une entit\u00e9 = une bo\u00eete avec une hauteur. Il y a donc beaucoup d'intersections entre objets ; Export d\u00e9coup\u00e9 : une entit\u00e9 = une g\u00e9om\u00e9trie d\u00e9coup\u00e9e par l'intersection des autres g\u00e9om\u00e9tries. Chaque composante g\u00e9om\u00e9trique peut \u00eatre extrud\u00e9e ce qui donne un d\u00e9doublement des faces verticales \u00e0 l'intersection entre deux g\u00e9om\u00e9tries d\u00e9coup\u00e9es ; Export fusionn\u00e9 : une entit\u00e9 = une forme b\u00e2tie, c'est \u00e0 dire la fusion des g\u00e9om\u00e9tries qui s'intersectent. Ici, le r\u00e9sultat est g\u00e9om\u00e9triquement propre, il n'y a pas de doublon au niveau des faces verticales.","title":"Exporter les r\u00e9sultats d'une simulation"},{"location":"export/#exporter-des-resultats-de-simulation","text":"","title":"Exporter des r\u00e9sultats de simulation"},{"location":"export/#export-general","text":"Les objets produits par le simulateur sont stock\u00e9s dans une instance de la classe GraphConfiguration . Il est possible d'it\u00e9rer sur les objets g\u00e9n\u00e9r\u00e9s via le graphe associ\u00e9. Le code ci-dessous montrer comment exporter sous forme d'un ShapeFile les r\u00e9sultats d'une simulation : // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); // Witting the output IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>(); // For all generated boxes for (GraphVertex<Cuboid> v : cc.getGraph().vertexSet()) { // Output feature with generated geometry IFeature feat = new DefaultFeature(v.getValue().generated3DGeom()); iFeatC.add(feat); } ShapefileWriter.write(featC,\"tmp/result.shp\");","title":"Export g\u00e9n\u00e9ral"},{"location":"export/#export-de-boites","text":"Comme les bo\u00eetes sont les objets actuellement les plus utilis\u00e9es comme sorties de SimPLU3D, diff\u00e9rentes m\u00e9thodes pour les exporter avec diff\u00e9rentes transformations ont \u00e9t\u00e9 impl\u00e9ment\u00e9es dans le projet SimPLU3D. Chacune des classes mentionn\u00e9es ci-dessous poss\u00e8de un main permettant leur utilisation.","title":"Export de bo\u00eetes"},{"location":"export/#export-simple-des-boites","text":"La classe fr.ign.cogit.simplu3d.io.shapefile.SaveGeneratedObjects permet d'exporter les bo\u00eetes en ShapeFile (m\u00e9thode saveShapefile ) ou dans une base PostGIS (m\u00e9thode save ) sous forme de MultiPolygon 3D (issus de la m\u00e9thode generated3DGeom ). Dans les donn\u00e9es en sortie, chaque ligne correspond \u00e0 une bo\u00eete.","title":"Export simple des bo\u00eetes"},{"location":"export/#export-decoupe","text":"Comme les bo\u00eetes g\u00e9n\u00e9r\u00e9es peuvent s'intersecter, ces intersections sont potentiellement des sources de probl\u00e8me pour calculer des indicateurs sur les formes r\u00e9sultantes ou pour les visualiser. Ainsi, la classe fr.ign.cogit.simplu3d.util.merge.SDPCalc permet d'exporter avec la m\u00e9thode getGeometryPairByGroup les bo\u00eetes sous la forme d'une partition des g\u00e9om\u00e9tries r\u00e9sultats avec une hauteur affect\u00e9e \u00e0 chaque patch. Le r\u00e9sultat contient pour chaque enregistrement un polygone 2D et une hauteur pour reg\u00e9n\u00e9rer la forme en 3D. Cet export facilite le calcul de la surface de plancher et de la surface 2D de la construction (m\u00e9thode process et m\u00e9thode processSurface ).","title":"Export d\u00e9coup\u00e9"},{"location":"export/#export-fusionne","text":"La classe fr.ign.cogit.simplu3d.util.merge.MergeCuboid propose une fusion 3D des bo\u00eetes r\u00e9sultantes via la m\u00e9thode mergeFromShapefile . Les faces int\u00e9rieures sont supprim\u00e9es et les bo\u00eetes g\u00e9n\u00e9r\u00e9es en 3D. Ce cas est tr\u00e8s utile pour la visualisation et le calcul de la surface ext\u00e9rieure avec la m\u00e9thode getSurface . L'attribut statique de cette classe zMIN permet de fixer l'altitude minimale au dessus de laquelle les bo\u00eetes seront extrud\u00e9es.","title":"Export fusionn\u00e9"},{"location":"export/#synthese-des-exports","text":"L'image ci-dessus illustre les diff\u00e9rents types d'exports. Si de base la vue 3D est la m\u00eame pour les trois r\u00e9sultats, les exports sont diff\u00e9rents dans leur mod\u00e9lisation des entit\u00e9s et des g\u00e9om\u00e9tries. La seconde partie de l'image montre dans une vue 2D la s\u00e9lection d'une entit\u00e9 (en jaune) dans les trois types d'export : Export simple : une entit\u00e9 = une bo\u00eete avec une hauteur. Il y a donc beaucoup d'intersections entre objets ; Export d\u00e9coup\u00e9 : une entit\u00e9 = une g\u00e9om\u00e9trie d\u00e9coup\u00e9e par l'intersection des autres g\u00e9om\u00e9tries. Chaque composante g\u00e9om\u00e9trique peut \u00eatre extrud\u00e9e ce qui donne un d\u00e9doublement des faces verticales \u00e0 l'intersection entre deux g\u00e9om\u00e9tries d\u00e9coup\u00e9es ; Export fusionn\u00e9 : une entit\u00e9 = une forme b\u00e2tie, c'est \u00e0 dire la fusion des g\u00e9om\u00e9tries qui s'intersectent. Ici, le r\u00e9sultat est g\u00e9om\u00e9triquement propre, il n'y a pas de doublon au niveau des faces verticales.","title":"Synth\u00e8se des exports"},{"location":"begin/first_simulation/","text":"Introduction \uf0c1 L'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9e de bo\u00eetes qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi et r\u00e9utilis\u00e9 dans cette documentation. Pour commencer, il est n\u00e9cessaire d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la page d'installation . Le code utilis\u00e9 dans cette page se trouve dans la classe : fr.ign.simplu3d.firstSimulation.BasicSimulator . Donn\u00e9es d'entr\u00e9e \uf0c1 Les donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources resources/firstSimulation/ . Il s'agit du plus petit ensemble de donn\u00e9es n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers : data : qui contient un fichier ShapeFile de parcelles (parcelle.shp). Chaque parcelle a une g\u00e9om\u00e9trie surfacique et un attribut id . Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans la section consacr\u00e9e \u00e0 l'environnement g\u00e9ographique ) ; scenario : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de formes (d\u00e9crits dans la section d\u00e9di\u00e9e aux param\u00e8tres de la g\u00e9n\u00e9ration de formes ) et des visiteurs qui indiqueront l'\u00e9tat d'avancement pendant la simulation ( d\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs ). Code de simulation \uf0c1 Le code comment\u00e9 \u00e0 ex\u00e9cuter est repris ci-dessous. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation : la cr\u00e9ation d'un environnement g\u00e9ographique ; la d\u00e9finition de contraintes morphologiques , \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , bas\u00e9 sur des boites ; l' export de r\u00e9sultats . public static void main(String[] args) throws Exception { //Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environnement using the repository that contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM( new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); //Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 2; // Distance to bottom of the parcel double distReculFond = 3; // Distance to lateral parcel limits double distReculLat = 4; // Distance between two buildings of a parcel double distanceInterBati = 0; // Maximal ratio built area double maximalCES = 0.5; //Instanciation of a predicate class SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); //Step 3 : Defining the regulation that will be applied during the simulation // Instantiation of the sampler OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath(); String fileName = \"params.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); //4 - Writting the output SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0); } Ex\u00e9cution du code de simulation \uf0c1 Avant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable outputFolder qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s. Une fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code. Pendant l'ex\u00e9cution, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section suivre l'\u00e9volution d'une simulation ). Deux sorties sont visualisables pendant la simulation : Dans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives au nombre d'objets et \u00e0 la valeur de la fonction d'optimisation ; Dans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est l'oppos\u00e9 du volume de la configuration courante (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant). R\u00e9sultats de la premi\u00e8re simulation \uf0c1 La sortie est stock\u00e9e sous la forme du ShapeFile out.shp qui contient les diff\u00e9rentes boites avec des attributs stock\u00e9 dans le dossier outputFolder : id : l'identifiant de la parcelle simul\u00e9e ; hauteur : la hauteur de la boite ; longueur : la longueur de la boite ; largeur : la largeur de la boite ; orient : l'azimut de la boite ; centerX , centerY : les coordonn\u00e9es du centre de la boite. La g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ. Vous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diff\u00e9rentes variables de r\u00e8gles. Dans la section suivante , nous d\u00e9taillons le principe de fonctionnement de la simulation. Le r\u00e9sultat est visualisable dans un SIG 2D ou 3D classique.","title":"Premi\u00e8re simulation"},{"location":"begin/first_simulation/#introduction","text":"L'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9e de bo\u00eetes qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi et r\u00e9utilis\u00e9 dans cette documentation. Pour commencer, il est n\u00e9cessaire d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la page d'installation . Le code utilis\u00e9 dans cette page se trouve dans la classe : fr.ign.simplu3d.firstSimulation.BasicSimulator .","title":"Introduction"},{"location":"begin/first_simulation/#donnees-dentree","text":"Les donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources resources/firstSimulation/ . Il s'agit du plus petit ensemble de donn\u00e9es n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers : data : qui contient un fichier ShapeFile de parcelles (parcelle.shp). Chaque parcelle a une g\u00e9om\u00e9trie surfacique et un attribut id . Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans la section consacr\u00e9e \u00e0 l'environnement g\u00e9ographique ) ; scenario : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de formes (d\u00e9crits dans la section d\u00e9di\u00e9e aux param\u00e8tres de la g\u00e9n\u00e9ration de formes ) et des visiteurs qui indiqueront l'\u00e9tat d'avancement pendant la simulation ( d\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs ).","title":"Donn\u00e9es d'entr\u00e9e"},{"location":"begin/first_simulation/#code-de-simulation","text":"Le code comment\u00e9 \u00e0 ex\u00e9cuter est repris ci-dessous. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation : la cr\u00e9ation d'un environnement g\u00e9ographique ; la d\u00e9finition de contraintes morphologiques , \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , bas\u00e9 sur des boites ; l' export de r\u00e9sultats . public static void main(String[] args) throws Exception { //Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environnement using the repository that contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM( new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); //Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 2; // Distance to bottom of the parcel double distReculFond = 3; // Distance to lateral parcel limits double distReculLat = 4; // Distance between two buildings of a parcel double distanceInterBati = 0; // Maximal ratio built area double maximalCES = 0.5; //Instanciation of a predicate class SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); //Step 3 : Defining the regulation that will be applied during the simulation // Instantiation of the sampler OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath(); String fileName = \"params.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); //4 - Writting the output SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0); }","title":"Code de simulation"},{"location":"begin/first_simulation/#execution-du-code-de-simulation","text":"Avant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable outputFolder qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s. Une fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code. Pendant l'ex\u00e9cution, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section suivre l'\u00e9volution d'une simulation ). Deux sorties sont visualisables pendant la simulation : Dans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives au nombre d'objets et \u00e0 la valeur de la fonction d'optimisation ; Dans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est l'oppos\u00e9 du volume de la configuration courante (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant).","title":"Ex\u00e9cution du code de simulation"},{"location":"begin/first_simulation/#resultats-de-la-premiere-simulation","text":"La sortie est stock\u00e9e sous la forme du ShapeFile out.shp qui contient les diff\u00e9rentes boites avec des attributs stock\u00e9 dans le dossier outputFolder : id : l'identifiant de la parcelle simul\u00e9e ; hauteur : la hauteur de la boite ; longueur : la longueur de la boite ; largeur : la largeur de la boite ; orient : l'azimut de la boite ; centerX , centerY : les coordonn\u00e9es du centre de la boite. La g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ. Vous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diff\u00e9rentes variables de r\u00e8gles. Dans la section suivante , nous d\u00e9taillons le principe de fonctionnement de la simulation. Le r\u00e9sultat est visualisable dans un SIG 2D ou 3D classique.","title":"R\u00e9sultats de la premi\u00e8re simulation"},{"location":"begin/installation/","text":"Installer SimPLU3D \uf0c1 Les biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN https://forge-cogit.ign.fr/nexus/#welcome . Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet SimPLU3D-tutorial ou sinon vous pouvez directement installer les biblioth\u00e8ques dans votre projet. Attention : il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions : Installer localement le certificat comme d\u00e9crit dans le lien suivant http://ignf.github.io/geoxygene/documentation/developer/install.html Faire une installation non s\u00e9curis\u00e9e lors du build du projet projet : mvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true Installer le code SimPLU3D-tutorial \uf0c1 Les \u00e9tapes suivantes sont n\u00e9cessaires : 1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes : http://ignf.github.io/geoxygene/documentation/developer/install.html 2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial 3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\" 4 - Lancer une installation avec Maven : Click droit sur le projet et \" Run as Maven Install \" ou directement en ligne de commande : mvn clean install 5 - Lancer une construction du projet avec Eclipse : Project > Build project Vous pouvez d\u00e9sormais ex\u00e9cuter la premi\u00e8re simulation . N\u00e9anmoins, pour avoir acc\u00e8s au code source pendant le tutoriel, il est recommand\u00e9 d'installer en local les codes issus de SimPLU3D et SimPLU3D-rules . Installer SimPLU3D dans un autre projet \uf0c1 L'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes : 1 - Cr\u00e9ation d'un projet Maven 2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises dependencies , en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D. <dependency> <groupId>fr.ign.cogit</groupId> <artifactId>simplu3d</artifactId> <version>1.2-SNAPSHOT</version> </dependency> 3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises repositories <repository> <id>ign-snapshots</id> <name>Cogit Snapshots Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url> <snapshots> <enabled>true</enabled> </snapshots> <releases> <enabled>false</enabled> </releases> </repository> <repository> <id>ign-releases</id> <name>Cogit Releases Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url> <snapshots> <enabled>false</enabled> </snapshots> <releases> <enabled>true</enabled> </releases> </repository> 4 - Faire un build du projet en utilisant par exemple : maven install .","title":"Installation"},{"location":"begin/installation/#installer-simplu3d","text":"Les biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN https://forge-cogit.ign.fr/nexus/#welcome . Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet SimPLU3D-tutorial ou sinon vous pouvez directement installer les biblioth\u00e8ques dans votre projet. Attention : il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions : Installer localement le certificat comme d\u00e9crit dans le lien suivant http://ignf.github.io/geoxygene/documentation/developer/install.html Faire une installation non s\u00e9curis\u00e9e lors du build du projet projet : mvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true","title":"Installer SimPLU3D"},{"location":"begin/installation/#installer-le-code-simplu3d-tutorial","text":"Les \u00e9tapes suivantes sont n\u00e9cessaires : 1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes : http://ignf.github.io/geoxygene/documentation/developer/install.html 2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial 3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\" 4 - Lancer une installation avec Maven : Click droit sur le projet et \" Run as Maven Install \" ou directement en ligne de commande : mvn clean install 5 - Lancer une construction du projet avec Eclipse : Project > Build project Vous pouvez d\u00e9sormais ex\u00e9cuter la premi\u00e8re simulation . N\u00e9anmoins, pour avoir acc\u00e8s au code source pendant le tutoriel, il est recommand\u00e9 d'installer en local les codes issus de SimPLU3D et SimPLU3D-rules .","title":"Installer le code SimPLU3D-tutorial"},{"location":"begin/installation/#installer-simplu3d-dans-un-autre-projet","text":"L'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes : 1 - Cr\u00e9ation d'un projet Maven 2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises dependencies , en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D. <dependency> <groupId>fr.ign.cogit</groupId> <artifactId>simplu3d</artifactId> <version>1.2-SNAPSHOT</version> </dependency> 3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises repositories <repository> <id>ign-snapshots</id> <name>Cogit Snapshots Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url> <snapshots> <enabled>true</enabled> </snapshots> <releases> <enabled>false</enabled> </releases> </repository> <repository> <id>ign-releases</id> <name>Cogit Releases Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url> <snapshots> <enabled>false</enabled> </snapshots> <releases> <enabled>true</enabled> </releases> </repository> 4 - Faire un build du projet en utilisant par exemple : maven install .","title":"Installer SimPLU3D dans un autre projet"},{"location":"begin/intro/","text":"Introduction \uf0c1 SimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re. Cela signifie que pour \u00eatre capable d'utiliser SimPLU3D, il est n\u00e9cessaire d'avoir des comp\u00e9tences : dans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des generics ; dans le gestionnaire de projet Maven afin de pouvoir importer les biblioth\u00e8ques de SimPLU3D ; si possible, sur le fonctionnement de GeOxygene et notamment de son module 3D . Cela peut \u00eatre n\u00e9cessaire \u00e9tant donn\u00e9 que cette biblioth\u00e8que est utilis\u00e9e pour les op\u00e9rations SIG (n\u00e9anmoins, si vous n'\u00eates pas familier avec ce projet, les classes et m\u00e9thodes utilis\u00e9es sont relativement communes aux autres API de d\u00e9veloppement SIG). La documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D : L'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son environnement g\u00e9ographique ; La g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation ; La d\u00e9finition des contraintes morphologiques qui contraignent la g\u00e9n\u00e9ration. Pour illustrer comment utiliser SimPLU3D, des codes comment\u00e9s sont mis \u00e0 disposition dans le projet SimPLU3D-tutorial . Ces codes partent de l'exemple d'une premi\u00e8re simulation et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles. Pour d\u00e9buter, il est tout d'abord n\u00e9cessaire d'installer SimPLU3D .","title":"Introduction"},{"location":"begin/intro/#introduction","text":"SimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re. Cela signifie que pour \u00eatre capable d'utiliser SimPLU3D, il est n\u00e9cessaire d'avoir des comp\u00e9tences : dans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des generics ; dans le gestionnaire de projet Maven afin de pouvoir importer les biblioth\u00e8ques de SimPLU3D ; si possible, sur le fonctionnement de GeOxygene et notamment de son module 3D . Cela peut \u00eatre n\u00e9cessaire \u00e9tant donn\u00e9 que cette biblioth\u00e8que est utilis\u00e9e pour les op\u00e9rations SIG (n\u00e9anmoins, si vous n'\u00eates pas familier avec ce projet, les classes et m\u00e9thodes utilis\u00e9es sont relativement communes aux autres API de d\u00e9veloppement SIG). La documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D : L'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son environnement g\u00e9ographique ; La g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation ; La d\u00e9finition des contraintes morphologiques qui contraignent la g\u00e9n\u00e9ration. Pour illustrer comment utiliser SimPLU3D, des codes comment\u00e9s sont mis \u00e0 disposition dans le projet SimPLU3D-tutorial . Ces codes partent de l'exemple d'une premi\u00e8re simulation et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles. Pour d\u00e9buter, il est tout d'abord n\u00e9cessaire d'installer SimPLU3D .","title":"Introduction"},{"location":"envgeo/integration-test/","text":"V\u00e9rifier l'int\u00e9gration des donn\u00e9es \uf0c1 L'objectif de cette page est de proposer deux m\u00e9thodes pour v\u00e9rifier la bonne int\u00e9gration des donn\u00e9es \u00e0 partir d'un jeu de donn\u00e9es complet. Il est possible soit : d'exporter les instances du mod\u00e8le sous forme de ShapeFiles ; de visualisation en 3D les informations du mod\u00e8le. Ces codes sont disponibles dans le d\u00e9p\u00f4t du tutoriel (simplu3D-tutorial) dans le package fr.ign.simplu3d.testIntegration . Attention : : pour ces codes, la visualisation 3D et le chargement de MNT n\u00e9cessitent l'utilisation de biblioth\u00e8ques natives Java 3D (qui se trouvent dans le projet SimPLU3d-tutorial). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant : -Djava.library.path=./lib/native_libraries/linux-amd64 La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9. Jeu de donn\u00e9es \uf0c1 Un jeu de donn\u00e9es complet suivant les sp\u00e9cifications du processus d'int\u00e9gration est disponible dans le dossier resources/completeDataSet . On peut voir ci-dessous une carte de ces donn\u00e9es : On peut noter dans ce jeu de donn\u00e9es la pr\u00e9sence d'un MNT et de b\u00e2timents 3D avec un toit typifi\u00e9 (ce qui explique les polygones internes aux polygones de b\u00e2timents). Export des informations du mod\u00e8le sous forme de Shapefile \uf0c1 La classe ExportAsShape permet d'exporter l'instance de la classe Environnement sous forme de Shapefiles. Le code n\u00e9cessite de d\u00e9terminer un dossier de sortie pour pouvoir \u00eatre appliqu\u00e9 (et il utilise le dossier de ressource qui se trouve dans le projet). L'ex\u00e9cution du code g\u00e9n\u00e8re une s\u00e9rie de ShapeFiles repr\u00e9sent\u00e9s dans la carte suivante. Les g\u00e9om\u00e9tries en sortie sont triangul\u00e9es car plaqu\u00e9es sur le MNT (s'il est utilis\u00e9). On retrouve les fichiers suivants : Nom du fichier Contenu Attributs int\u00e9ressants bpu.shp Unit\u00e9s fonci\u00e8res parcelles.shp Parcelles ID : Code BounNum : Nombre de limites s\u00e9paratives BuildNum : Nombre de b\u00e2timents subParcels.shp Sous-parcelles NB Bat : Nombre de parties de b\u00e2timents bordures.shp Limites s\u00e9paratives des parcelles Type : type de la limite IDPAR : identifiant de la parcelle Adj : Identifiant de la parcelle adjacente SIDE : c\u00f4t\u00e9 de la limite (droite ou gauche) bordures_translated.shp Limites s\u00e9paratives translat\u00e9e Type : type de la limite SIDE : c\u00f4t\u00e9 de la limite (droite ou gauche) opposites.shp Lien entre une limite et la limite oppos\u00e9e footprints.shp Emprise des b\u00e2timents 3D faitage.shp Fa\u00eetage des b\u00e2timents pignon.shp Pignons des b\u00e2timents roads.shp Surface des routes Nom : nom des routes Les limites s\u00e9paratives du fichier bordures_translate.shp sont translat\u00e9es vers l'int\u00e9rieur des parcelles auxquelles ils appartiennent pour des raison de lisibilit\u00e9 (afin d'\u00e9viter les superposition entre limites appartenant \u00e0 des parcelles adjacentes). Pour les valeurs des \u00e9num\u00e9ration SIDE et Type des limites s\u00e9paratives, vous pouvez vous r\u00e9f\u00e9rer aux \u00e9num\u00e9rations ParcelBoundaryType et ParcelBoundarySide . Visualisation 3D des informations du mod\u00e8le \uf0c1 La classe Integration3DViewer permet une visualisation 3D d'un environnement. Il est possible de d\u00e9terminer via une liste de th\u00e8mes, les informations \u00e0 afficher dans la vue 3D. La liste des th\u00e8mes disponibles est consultable via l'\u00e9num\u00e9ration RepEnvironnement.Theme . Pour chaque th\u00e8me, un rendu est pr\u00e9d\u00e9fini afin de visualiser les informations correspondantes. Le visualisateur 3D utilis\u00e9 est celui de GeOxygene3D vous trouverez plus de documentation sur comment repr\u00e9senter des donn\u00e9es et sur comment naviguer sur le site de GeOxygene .","title":"Tester l'int\u00e9gration"},{"location":"envgeo/integration-test/#verifier-lintegration-des-donnees","text":"L'objectif de cette page est de proposer deux m\u00e9thodes pour v\u00e9rifier la bonne int\u00e9gration des donn\u00e9es \u00e0 partir d'un jeu de donn\u00e9es complet. Il est possible soit : d'exporter les instances du mod\u00e8le sous forme de ShapeFiles ; de visualisation en 3D les informations du mod\u00e8le. Ces codes sont disponibles dans le d\u00e9p\u00f4t du tutoriel (simplu3D-tutorial) dans le package fr.ign.simplu3d.testIntegration . Attention : : pour ces codes, la visualisation 3D et le chargement de MNT n\u00e9cessitent l'utilisation de biblioth\u00e8ques natives Java 3D (qui se trouvent dans le projet SimPLU3d-tutorial). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant : -Djava.library.path=./lib/native_libraries/linux-amd64 La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.","title":"V\u00e9rifier l'int\u00e9gration des donn\u00e9es"},{"location":"envgeo/integration-test/#jeu-de-donnees","text":"Un jeu de donn\u00e9es complet suivant les sp\u00e9cifications du processus d'int\u00e9gration est disponible dans le dossier resources/completeDataSet . On peut voir ci-dessous une carte de ces donn\u00e9es : On peut noter dans ce jeu de donn\u00e9es la pr\u00e9sence d'un MNT et de b\u00e2timents 3D avec un toit typifi\u00e9 (ce qui explique les polygones internes aux polygones de b\u00e2timents).","title":"Jeu de donn\u00e9es"},{"location":"envgeo/integration-test/#export-des-informations-du-modele-sous-forme-de-shapefile","text":"La classe ExportAsShape permet d'exporter l'instance de la classe Environnement sous forme de Shapefiles. Le code n\u00e9cessite de d\u00e9terminer un dossier de sortie pour pouvoir \u00eatre appliqu\u00e9 (et il utilise le dossier de ressource qui se trouve dans le projet). L'ex\u00e9cution du code g\u00e9n\u00e8re une s\u00e9rie de ShapeFiles repr\u00e9sent\u00e9s dans la carte suivante. Les g\u00e9om\u00e9tries en sortie sont triangul\u00e9es car plaqu\u00e9es sur le MNT (s'il est utilis\u00e9). On retrouve les fichiers suivants : Nom du fichier Contenu Attributs int\u00e9ressants bpu.shp Unit\u00e9s fonci\u00e8res parcelles.shp Parcelles ID : Code BounNum : Nombre de limites s\u00e9paratives BuildNum : Nombre de b\u00e2timents subParcels.shp Sous-parcelles NB Bat : Nombre de parties de b\u00e2timents bordures.shp Limites s\u00e9paratives des parcelles Type : type de la limite IDPAR : identifiant de la parcelle Adj : Identifiant de la parcelle adjacente SIDE : c\u00f4t\u00e9 de la limite (droite ou gauche) bordures_translated.shp Limites s\u00e9paratives translat\u00e9e Type : type de la limite SIDE : c\u00f4t\u00e9 de la limite (droite ou gauche) opposites.shp Lien entre une limite et la limite oppos\u00e9e footprints.shp Emprise des b\u00e2timents 3D faitage.shp Fa\u00eetage des b\u00e2timents pignon.shp Pignons des b\u00e2timents roads.shp Surface des routes Nom : nom des routes Les limites s\u00e9paratives du fichier bordures_translate.shp sont translat\u00e9es vers l'int\u00e9rieur des parcelles auxquelles ils appartiennent pour des raison de lisibilit\u00e9 (afin d'\u00e9viter les superposition entre limites appartenant \u00e0 des parcelles adjacentes). Pour les valeurs des \u00e9num\u00e9ration SIDE et Type des limites s\u00e9paratives, vous pouvez vous r\u00e9f\u00e9rer aux \u00e9num\u00e9rations ParcelBoundaryType et ParcelBoundarySide .","title":"Export des informations du mod\u00e8le sous forme de Shapefile"},{"location":"envgeo/integration-test/#visualisation-3d-des-informations-du-modele","text":"La classe Integration3DViewer permet une visualisation 3D d'un environnement. Il est possible de d\u00e9terminer via une liste de th\u00e8mes, les informations \u00e0 afficher dans la vue 3D. La liste des th\u00e8mes disponibles est consultable via l'\u00e9num\u00e9ration RepEnvironnement.Theme . Pour chaque th\u00e8me, un rendu est pr\u00e9d\u00e9fini afin de visualiser les informations correspondantes. Le visualisateur 3D utilis\u00e9 est celui de GeOxygene3D vous trouverez plus de documentation sur comment repr\u00e9senter des donn\u00e9es et sur comment naviguer sur le site de GeOxygene .","title":"Visualisation 3D des informations du mod\u00e8le"},{"location":"envgeo/integration/","text":"Processus d'int\u00e9gration \uf0c1 Un processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe Environnement en renseignant un certain nombre d'attributs. Le processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP du d\u00e9pot SimPLU3D-rules ) ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS , m\u00eame d\u00e9pot). Quel que soit l'approche choisie, les deux classes ont une m\u00e9thode load , qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de IFeature de GeOxygene et faire appelle \u00e0 la m\u00e9thode load de la classe fr.ign.cogit.simplu3d.io.LoadFromCollection qui va instancier les entit\u00e9s du mod\u00e8le. Dans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en fonction de la source de donn\u00e9es utilis\u00e9e , puis d\u00e9crire dans le d\u00e9tail le processus d'int\u00e9gration . Attention : actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen direct d'instancier le mod\u00e8le g\u00e9ographique convenablement. Sources de donn\u00e9es utilis\u00e9es \uf0c1 La donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es d\u00e9pendent du choix de la source de donn\u00e9es ShapeFiles ou PostGIS . Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires. Cependant, les noms des attributs utilis\u00e9s sont les m\u00eames quelle que soit la source utilis\u00e9e et sont stock\u00e9s au m\u00eame endroit dans le code. Source de donn\u00e9es ShapeFile \uf0c1 La classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_FICHIER_PLU doc_urba.shp Non utilis\u00e9e Zonage r\u00e9glementaire NOM_FICHIER_ZONAGE zone_urba.shp (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle.shp Polygone 2D (sans intersection) B\u00e2timents NOM_FICHIER_BATIMENTS batiment.shp Multi-Polygone 3D Route NOM_FICHIER_VOIRIE route.shp (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt.asc MNT grille maill\u00e9 Prescriptions ponctuelles NOM_FICHIER_PRESC_PONCTUELLE prescription_pct.shp (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_FICHIER_PRESC_LINEAIRE prescription_lin.shp (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_FICHIER_PRESC_SURFACIQUE prescription_surf.shp (Multi-) Surfacique 2D Source de donn\u00e9es PostGIS \uf0c1 La classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tables est fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS . Le MNT est stock\u00e9 comme un raster dans PostGIS. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_TABLE_PLU plu Non utilis\u00e9es Zonage r\u00e9glementaire NOM_TABLE_ZONAGE zonage (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle Polygones 2D (sans intersection) B\u00e2timents NOM_TABLE_BATIMENTS batiment Multi-Polygone 3D Route NOM_TABLE_VOIRIE route (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt MNT grille maill\u00e9 Prescriptions ponctuelles NOM_TABLE_PRESC_PCT prescriptionpct (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_TABLE_PRESC_LINEAIRE prescriptionlin (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_TABLE_PRESC_SURF prescriptionsurf (Multi-) Surfacique 2D Nom des attributs \uf0c1 Pour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe : fr.ign.cogit.simplu3d.io.feature.AttribNames . Document d'urbanisme \uf0c1 Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant ATT_ID_URBA IDURBA String Type de document ATT_TYPE_DOC TYPEDOC String Date Approbation ATT_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date Fin ATT_DATE_FIN DATEFIN Date (yyyyMMdd) Intercommunalit\u00e9 ATT_INTER_CO INTERCO String Num\u00e9ro SIREN ATT_SIREN SIREN String \u00c9tat du document ATT_ETAT ETAT String Nom de la r\u00e9gion ATT_NOM_REG NOMREG String URL de la r\u00e9gion ATT_URL_REG URLREG String Nom du plan ATT_NOM_PLAN NOMPLAN String URL du plan ATT_URL_PLAN URLPLAN String Site web ATT_SITE_WEB SITEWEB String Type ref ATT_TYPE_REF TYPEREF String Date de r\u00e9f\u00e9rence ATT_DATE_REF DATEREF Date (yyyy) Zonage r\u00e9glementaire \uf0c1 Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Libell\u00e9 ATT_LIBELLE LIBELLE String Libell\u00e9 long ATT_LIBELONG LIBELONG String Type de zone ATT_TYPE_ZONE TYPEZONE String Destination dominante ATT_DESTDOMI DESTDOMI String Nom de fichier associ\u00e9 ATT_NOMFIC NOMFIC String URL du fichier associ\u00e9 ATT_URLFIC URLFIC String INSEE ATT_INSEE INSEE String Date d'approbation VALIDITY_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date de validation VALIDITY_DATE_VALID DATVALID Date (yyyyMMdd) Commentaires \u00e9ventuels ATT_TEXT TEXT String Parcelles \uf0c1 Chaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut ATT_CODE_PARC ou est construit par la concat\u00e9nation des attributs valeurs des ATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO et accessible par la m\u00e9thode getCode de la classe * fr.ign.cogit.simplu3d.model.CadastralParcel*. L'attribut ATT_HAS_TO_BE_SIMULATED est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false). Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant de la parcelle ATT_CODE_PARC CODE String Code du d\u00e9partement ATT_BDP_CODE_DEP CODE_DEP String Code de la commune ATT_BDP_CODE_COM CODE_COM String Compl\u00e9ment pour code INSEE ATT_BDP_COM_ABS COM_ABS String Section cadastrale ATT_BDP_SECTION SECTION String Num\u00e9ro de parcelle ATT_BDP_NUMERO NUMERO String Indique si la parcelle doit \u00eatre simul\u00e9e ATT_HAS_TO_BE_SIMULATED SIMUL Boolean, Integer, String B\u00e2timents \uf0c1 Pas d'attribut utilis\u00e9. Route \uf0c1 Attribut Nom de la variable Valeur par d\u00e9faut Type Nom de la rue ATT_NOM_RUE NOM_RUE_G String Largeur en m ATT_LARGEUR LARGEUR Double Type de la rue ATT_TYPE_ROAD NATURE String MNT \uf0c1 Pas d'attribut utilis\u00e9. Prescriptions ponctuelles, lin\u00e9aires et surfaciques \uf0c1 Attribut Nom de la variable Valeur par d\u00e9faut Type Type de prescription ATT_TYPE_PRESCRIPTION TYPEPSC String Libell\u00e9 de la prescription ATT_LABEL LIBELLE Double Valeur de recul ATT_RECOIL RECOIL String Code d'int\u00e9gration \uf0c1 Le code d'int\u00e9gration se trouve ci-dessous, il est compos\u00e9 de 12 \u00e9tapes. Pour en savoir plus sur les diff\u00e9rentes m\u00e9thodes d'int\u00e9gration, vous pouvez vous r\u00e9f\u00e9rer \u00e0 la th\u00e8se de Micka\u00ebl Brasebin (chapitre 4) . Cr\u00e9ation de l'objet PLU Cr\u00e9ation des zones et assignation des r\u00e8gles aux zones Affectation des zonages au PLU Chargement des parcelles et cr\u00e9ations des bordures Import des sous parcelles Cr\u00e9ation des unit\u00e9s fonci\u00e8res Import des b\u00e2timents et Assignation des b\u00e2timents aux BpU Chargement des voiries Affectation des liens entre une bordure et ses objets adjacents (bordure sur route => route + relation entre les limites de parcelles) D\u00e9tection des limites s\u00e9paratives oppos\u00e9es Import des alignements Affectation de la coordonn\u00e9es Z \u00e0 l'ensemble des \u00e9l\u00e9ments Quelques \u00e9tapes sont param\u00e9trables : La premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible d'activer la transformation avec le boolean Environnement.TRANSLATE_TO_ZERO et en assignant des coordonn\u00e9es (classe DirectPosition de GeOxygene) \u00e0 l'attribut statique Environnement.dpTranslate . Pendant l'\u00e9tape d'annotation des limites s\u00e9paratives en limites de fond, lat\u00e9rales et de voirie (\u00e9tape 4), le processus d\u00e9termine automatiquement ces types. L'algorithme d\u00e9termine tout d'abord les limites donnant sur la voirie en d\u00e9tectant celles qui se trouvent \u00e0 l'ext\u00e9rieur de l'\u00eelot form\u00e9 par les parcelles connexes. Puis, les limites lat\u00e9rales sont d\u00e9tect\u00e9es suivant une \u00e9valuation du d\u00e9passement de la limite s\u00e9parative par rapport au point d'intersection avec la voirie (cf image suivante). Pour cette \u00e9tape, il s'agit d'une m\u00e9thode it\u00e9rative, on s\u00e9lectionne les limites donnant sur la voirie et non affect\u00e9es comme \u00e9tant des limites de voirie. Pour chacune de ces limites, on parcourt de proche en proche les limites adjacentes non \u00e9tiquet\u00e9es. Tant que ces limites sont incluses dans une bo\u00eete englobante orient\u00e9e de largeur inf\u00e9rieure \u00e0 la valeur du d\u00e9passement, on les \u00e9tiquette comme lat\u00e9rales, sinon on arr\u00eate le parcours de proche en proche. Apr\u00e8s avoir appliqu\u00e9 cette m\u00e9thode, les limites restantes sont \u00e9tiquet\u00e9es comme de fond de parcelle . Par d\u00e9faut, la valeur de d\u00e9passement jusqu'\u00e0 laquelle les limites sont affect\u00e9es comme lat\u00e9rales est de 3 m, mais elle peut \u00eatre fix\u00e9e en modifiant la valeur AbstractBoundaryAnalyzer.setThresholdIni(double) . Pour les parcelles plus petites, le seuil est automatiquement ajust\u00e9 pour atteindre 1/3 de la largeur de la bo\u00eete englobante orient\u00e9e. Pour une parcelle n'ayant pas d'acc\u00e8s \u00e0 la voirie, toutes les limites sont de type \"Fond\". Le c\u00f4t\u00e9 (GAUCHE ou DROITE) des limites lat\u00e9rales est d\u00e9termin\u00e9e en regardant la parcelle depuis la voirie. Si une parcelle donne sur plusieurs voiries, les c\u00f4t\u00e9s DROITE et GAUCHE sont d\u00e9termin\u00e9s al\u00e9atoirement. Pour les \u00e9tapes qui recherchent des objets \u00e0 proximit\u00e9 des limites s\u00e9paratives comme les \u00e9tapes 9 et 10, il est possible de fixer la distance maximale de recherche en fixant les valeurs : NearestRoadFinder.setMaximumDistance() pour la recherche de la voirie la plus proche d'une limite cadastrale et OppositeBoundaryFinder.setMaximalValue() pour la recherche de la limite oppos\u00e9e \u00e0 une limite cadastrale. Afin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D parcelles, prescriptions, zonages et \u00e9ventuellement voiries (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe fr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ . Deux types de transformation sont possibles : - Si le MNT est d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ; - S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut). public static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl, IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl, IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions, AbstractDTM dtm, Environnement env) throws Exception { // Etape 0 : doit on translater tous les objets ? if (Environnement.TRANSLATE_TO_ZERO) { Environnement.dpTranslate = zoneColl.envelope().center(); for (IFeature feat : zoneColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : parcelleColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : voirieColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : batiColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : prescriptions) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } } // Etape 1 : cr\u00e9ation de l'objet PLU logger.info(\"Read UrbaDocument...\"); UrbaDocument plu; if (featPLU == null) { plu = new UrbaDocument(); } else { UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader(); plu = urbaDocumentReader.read(featPLU); } env.setUrbaDocument(plu); // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones logger.info(\"Loading UrbaZone...\"); UrbaZoneReader urbaZoneReader = new UrbaZoneReader(); IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>(); zones.addAll(urbaZoneReader.readAll(zoneColl)); // Etape 3 : assignement des zonages au PLU env.setUrbaZones(zones); logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\"); // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader .assignBordureToParcelleWithOrientation(parcelleColl); env.setCadastralParcels(parcelles); // Etape 5 : import des sous parcelles logger.info(\"Loading SubParcels...\"); { IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>(); SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones); for (CadastralParcel cadastralParcel : parcelles) { sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel)); } env.setSubParcels(sousParcelles); } // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es logger.info(\"Loading BasicPropertyUnits...\"); BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles); IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits(); env.setBpU(collBPU); // Etape 7 : import des b\u00e2timents logger.info(\"Loading Buildings...\"); BuildingReader buildingReader = new BuildingReader(); Collection<Building> buildings = buildingReader.readAll(batiColl); env.getBuildings().addAll(buildings); // Etape 7.1 : assignation des batiments aux BpU logger.info(\"Assigning building to SubParcels...\"); AssignBuildingPartToSubParcel.assign(buildings, collBPU); // Etape 8 : chargement des voiries logger.info(\"Loading Roads...\"); RoadReader roadReader = new RoadReader(); IFeatureCollection<Road> roads = new FT_FeatureCollection<>(); roads.addAll(roadReader.readAll(voirieColl)); env.setRoads(roads); // Etape 9 : on affecte les liens entres une bordure et ses objets // adjacents (bordure sur route => route + relation entre les limites de // parcelles) logger.info(\"Assigning Roads to ParcelBoundaries...\"); AssignRoadToParcelBoundary.process(parcelles, roads); // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es logger.info(\"Assigning opposite boundaries to parcel boundaries...\"); AssignOppositeToBoundary.process(parcelles); // Etape 11 : on importe les alignements logger.info(\"Loading Prescriptions...\"); { PrescriptionReader prescriptionReader = new PrescriptionReader(); Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions); env.getPrescriptions().addAll(prescriptionsRead); } logger.info(\"Assign Z to features...\"); // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles, // sous-parcelles route sans z, zonage, les bordures etc... env.setTerrain(dtm); try { AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED); AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED); AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED); AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED); AssignZ.toZone(env.getUrbaZones(), dtm, false); } catch (Exception e) { e.printStackTrace(); } logger.info(\"Loading complete\"); return env; } Dans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).","title":"Processus d'int\u00e9gration"},{"location":"envgeo/integration/#processus-dintegration","text":"Un processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe Environnement en renseignant un certain nombre d'attributs. Le processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP du d\u00e9pot SimPLU3D-rules ) ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS , m\u00eame d\u00e9pot). Quel que soit l'approche choisie, les deux classes ont une m\u00e9thode load , qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de IFeature de GeOxygene et faire appelle \u00e0 la m\u00e9thode load de la classe fr.ign.cogit.simplu3d.io.LoadFromCollection qui va instancier les entit\u00e9s du mod\u00e8le. Dans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en fonction de la source de donn\u00e9es utilis\u00e9e , puis d\u00e9crire dans le d\u00e9tail le processus d'int\u00e9gration . Attention : actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen direct d'instancier le mod\u00e8le g\u00e9ographique convenablement.","title":"Processus d'int\u00e9gration"},{"location":"envgeo/integration/#sources-de-donnees-utilisees","text":"La donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es d\u00e9pendent du choix de la source de donn\u00e9es ShapeFiles ou PostGIS . Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires. Cependant, les noms des attributs utilis\u00e9s sont les m\u00eames quelle que soit la source utilis\u00e9e et sont stock\u00e9s au m\u00eame endroit dans le code.","title":"Sources de donn\u00e9es utilis\u00e9es"},{"location":"envgeo/integration/#source-de-donnees-shapefile","text":"La classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_FICHIER_PLU doc_urba.shp Non utilis\u00e9e Zonage r\u00e9glementaire NOM_FICHIER_ZONAGE zone_urba.shp (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle.shp Polygone 2D (sans intersection) B\u00e2timents NOM_FICHIER_BATIMENTS batiment.shp Multi-Polygone 3D Route NOM_FICHIER_VOIRIE route.shp (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt.asc MNT grille maill\u00e9 Prescriptions ponctuelles NOM_FICHIER_PRESC_PONCTUELLE prescription_pct.shp (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_FICHIER_PRESC_LINEAIRE prescription_lin.shp (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_FICHIER_PRESC_SURFACIQUE prescription_surf.shp (Multi-) Surfacique 2D","title":"Source de donn\u00e9es ShapeFile"},{"location":"envgeo/integration/#source-de-donnees-postgis","text":"La classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tables est fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS . Le MNT est stock\u00e9 comme un raster dans PostGIS. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_TABLE_PLU plu Non utilis\u00e9es Zonage r\u00e9glementaire NOM_TABLE_ZONAGE zonage (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle Polygones 2D (sans intersection) B\u00e2timents NOM_TABLE_BATIMENTS batiment Multi-Polygone 3D Route NOM_TABLE_VOIRIE route (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt MNT grille maill\u00e9 Prescriptions ponctuelles NOM_TABLE_PRESC_PCT prescriptionpct (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_TABLE_PRESC_LINEAIRE prescriptionlin (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_TABLE_PRESC_SURF prescriptionsurf (Multi-) Surfacique 2D","title":"Source de donn\u00e9es PostGIS"},{"location":"envgeo/integration/#nom-des-attributs","text":"Pour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe : fr.ign.cogit.simplu3d.io.feature.AttribNames .","title":"Nom des attributs"},{"location":"envgeo/integration/#document-durbanisme","text":"Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant ATT_ID_URBA IDURBA String Type de document ATT_TYPE_DOC TYPEDOC String Date Approbation ATT_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date Fin ATT_DATE_FIN DATEFIN Date (yyyyMMdd) Intercommunalit\u00e9 ATT_INTER_CO INTERCO String Num\u00e9ro SIREN ATT_SIREN SIREN String \u00c9tat du document ATT_ETAT ETAT String Nom de la r\u00e9gion ATT_NOM_REG NOMREG String URL de la r\u00e9gion ATT_URL_REG URLREG String Nom du plan ATT_NOM_PLAN NOMPLAN String URL du plan ATT_URL_PLAN URLPLAN String Site web ATT_SITE_WEB SITEWEB String Type ref ATT_TYPE_REF TYPEREF String Date de r\u00e9f\u00e9rence ATT_DATE_REF DATEREF Date (yyyy)","title":"Document d'urbanisme"},{"location":"envgeo/integration/#zonage-reglementaire","text":"Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Libell\u00e9 ATT_LIBELLE LIBELLE String Libell\u00e9 long ATT_LIBELONG LIBELONG String Type de zone ATT_TYPE_ZONE TYPEZONE String Destination dominante ATT_DESTDOMI DESTDOMI String Nom de fichier associ\u00e9 ATT_NOMFIC NOMFIC String URL du fichier associ\u00e9 ATT_URLFIC URLFIC String INSEE ATT_INSEE INSEE String Date d'approbation VALIDITY_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date de validation VALIDITY_DATE_VALID DATVALID Date (yyyyMMdd) Commentaires \u00e9ventuels ATT_TEXT TEXT String","title":"Zonage r\u00e9glementaire"},{"location":"envgeo/integration/#parcelles","text":"Chaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut ATT_CODE_PARC ou est construit par la concat\u00e9nation des attributs valeurs des ATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO et accessible par la m\u00e9thode getCode de la classe * fr.ign.cogit.simplu3d.model.CadastralParcel*. L'attribut ATT_HAS_TO_BE_SIMULATED est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false). Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant de la parcelle ATT_CODE_PARC CODE String Code du d\u00e9partement ATT_BDP_CODE_DEP CODE_DEP String Code de la commune ATT_BDP_CODE_COM CODE_COM String Compl\u00e9ment pour code INSEE ATT_BDP_COM_ABS COM_ABS String Section cadastrale ATT_BDP_SECTION SECTION String Num\u00e9ro de parcelle ATT_BDP_NUMERO NUMERO String Indique si la parcelle doit \u00eatre simul\u00e9e ATT_HAS_TO_BE_SIMULATED SIMUL Boolean, Integer, String","title":"Parcelles"},{"location":"envgeo/integration/#batiments","text":"Pas d'attribut utilis\u00e9.","title":"B\u00e2timents"},{"location":"envgeo/integration/#route","text":"Attribut Nom de la variable Valeur par d\u00e9faut Type Nom de la rue ATT_NOM_RUE NOM_RUE_G String Largeur en m ATT_LARGEUR LARGEUR Double Type de la rue ATT_TYPE_ROAD NATURE String","title":"Route"},{"location":"envgeo/integration/#mnt","text":"Pas d'attribut utilis\u00e9.","title":"MNT"},{"location":"envgeo/integration/#prescriptions-ponctuelles-lineaires-et-surfaciques","text":"Attribut Nom de la variable Valeur par d\u00e9faut Type Type de prescription ATT_TYPE_PRESCRIPTION TYPEPSC String Libell\u00e9 de la prescription ATT_LABEL LIBELLE Double Valeur de recul ATT_RECOIL RECOIL String","title":"Prescriptions ponctuelles, lin\u00e9aires et surfaciques"},{"location":"envgeo/integration/#code-dintegration","text":"Le code d'int\u00e9gration se trouve ci-dessous, il est compos\u00e9 de 12 \u00e9tapes. Pour en savoir plus sur les diff\u00e9rentes m\u00e9thodes d'int\u00e9gration, vous pouvez vous r\u00e9f\u00e9rer \u00e0 la th\u00e8se de Micka\u00ebl Brasebin (chapitre 4) . Cr\u00e9ation de l'objet PLU Cr\u00e9ation des zones et assignation des r\u00e8gles aux zones Affectation des zonages au PLU Chargement des parcelles et cr\u00e9ations des bordures Import des sous parcelles Cr\u00e9ation des unit\u00e9s fonci\u00e8res Import des b\u00e2timents et Assignation des b\u00e2timents aux BpU Chargement des voiries Affectation des liens entre une bordure et ses objets adjacents (bordure sur route => route + relation entre les limites de parcelles) D\u00e9tection des limites s\u00e9paratives oppos\u00e9es Import des alignements Affectation de la coordonn\u00e9es Z \u00e0 l'ensemble des \u00e9l\u00e9ments Quelques \u00e9tapes sont param\u00e9trables : La premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible d'activer la transformation avec le boolean Environnement.TRANSLATE_TO_ZERO et en assignant des coordonn\u00e9es (classe DirectPosition de GeOxygene) \u00e0 l'attribut statique Environnement.dpTranslate . Pendant l'\u00e9tape d'annotation des limites s\u00e9paratives en limites de fond, lat\u00e9rales et de voirie (\u00e9tape 4), le processus d\u00e9termine automatiquement ces types. L'algorithme d\u00e9termine tout d'abord les limites donnant sur la voirie en d\u00e9tectant celles qui se trouvent \u00e0 l'ext\u00e9rieur de l'\u00eelot form\u00e9 par les parcelles connexes. Puis, les limites lat\u00e9rales sont d\u00e9tect\u00e9es suivant une \u00e9valuation du d\u00e9passement de la limite s\u00e9parative par rapport au point d'intersection avec la voirie (cf image suivante). Pour cette \u00e9tape, il s'agit d'une m\u00e9thode it\u00e9rative, on s\u00e9lectionne les limites donnant sur la voirie et non affect\u00e9es comme \u00e9tant des limites de voirie. Pour chacune de ces limites, on parcourt de proche en proche les limites adjacentes non \u00e9tiquet\u00e9es. Tant que ces limites sont incluses dans une bo\u00eete englobante orient\u00e9e de largeur inf\u00e9rieure \u00e0 la valeur du d\u00e9passement, on les \u00e9tiquette comme lat\u00e9rales, sinon on arr\u00eate le parcours de proche en proche. Apr\u00e8s avoir appliqu\u00e9 cette m\u00e9thode, les limites restantes sont \u00e9tiquet\u00e9es comme de fond de parcelle . Par d\u00e9faut, la valeur de d\u00e9passement jusqu'\u00e0 laquelle les limites sont affect\u00e9es comme lat\u00e9rales est de 3 m, mais elle peut \u00eatre fix\u00e9e en modifiant la valeur AbstractBoundaryAnalyzer.setThresholdIni(double) . Pour les parcelles plus petites, le seuil est automatiquement ajust\u00e9 pour atteindre 1/3 de la largeur de la bo\u00eete englobante orient\u00e9e. Pour une parcelle n'ayant pas d'acc\u00e8s \u00e0 la voirie, toutes les limites sont de type \"Fond\". Le c\u00f4t\u00e9 (GAUCHE ou DROITE) des limites lat\u00e9rales est d\u00e9termin\u00e9e en regardant la parcelle depuis la voirie. Si une parcelle donne sur plusieurs voiries, les c\u00f4t\u00e9s DROITE et GAUCHE sont d\u00e9termin\u00e9s al\u00e9atoirement. Pour les \u00e9tapes qui recherchent des objets \u00e0 proximit\u00e9 des limites s\u00e9paratives comme les \u00e9tapes 9 et 10, il est possible de fixer la distance maximale de recherche en fixant les valeurs : NearestRoadFinder.setMaximumDistance() pour la recherche de la voirie la plus proche d'une limite cadastrale et OppositeBoundaryFinder.setMaximalValue() pour la recherche de la limite oppos\u00e9e \u00e0 une limite cadastrale. Afin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D parcelles, prescriptions, zonages et \u00e9ventuellement voiries (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe fr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ . Deux types de transformation sont possibles : - Si le MNT est d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ; - S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut). public static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl, IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl, IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions, AbstractDTM dtm, Environnement env) throws Exception { // Etape 0 : doit on translater tous les objets ? if (Environnement.TRANSLATE_TO_ZERO) { Environnement.dpTranslate = zoneColl.envelope().center(); for (IFeature feat : zoneColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : parcelleColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : voirieColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : batiColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : prescriptions) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } } // Etape 1 : cr\u00e9ation de l'objet PLU logger.info(\"Read UrbaDocument...\"); UrbaDocument plu; if (featPLU == null) { plu = new UrbaDocument(); } else { UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader(); plu = urbaDocumentReader.read(featPLU); } env.setUrbaDocument(plu); // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones logger.info(\"Loading UrbaZone...\"); UrbaZoneReader urbaZoneReader = new UrbaZoneReader(); IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>(); zones.addAll(urbaZoneReader.readAll(zoneColl)); // Etape 3 : assignement des zonages au PLU env.setUrbaZones(zones); logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\"); // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader .assignBordureToParcelleWithOrientation(parcelleColl); env.setCadastralParcels(parcelles); // Etape 5 : import des sous parcelles logger.info(\"Loading SubParcels...\"); { IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>(); SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones); for (CadastralParcel cadastralParcel : parcelles) { sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel)); } env.setSubParcels(sousParcelles); } // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es logger.info(\"Loading BasicPropertyUnits...\"); BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles); IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits(); env.setBpU(collBPU); // Etape 7 : import des b\u00e2timents logger.info(\"Loading Buildings...\"); BuildingReader buildingReader = new BuildingReader(); Collection<Building> buildings = buildingReader.readAll(batiColl); env.getBuildings().addAll(buildings); // Etape 7.1 : assignation des batiments aux BpU logger.info(\"Assigning building to SubParcels...\"); AssignBuildingPartToSubParcel.assign(buildings, collBPU); // Etape 8 : chargement des voiries logger.info(\"Loading Roads...\"); RoadReader roadReader = new RoadReader(); IFeatureCollection<Road> roads = new FT_FeatureCollection<>(); roads.addAll(roadReader.readAll(voirieColl)); env.setRoads(roads); // Etape 9 : on affecte les liens entres une bordure et ses objets // adjacents (bordure sur route => route + relation entre les limites de // parcelles) logger.info(\"Assigning Roads to ParcelBoundaries...\"); AssignRoadToParcelBoundary.process(parcelles, roads); // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es logger.info(\"Assigning opposite boundaries to parcel boundaries...\"); AssignOppositeToBoundary.process(parcelles); // Etape 11 : on importe les alignements logger.info(\"Loading Prescriptions...\"); { PrescriptionReader prescriptionReader = new PrescriptionReader(); Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions); env.getPrescriptions().addAll(prescriptionsRead); } logger.info(\"Assign Z to features...\"); // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles, // sous-parcelles route sans z, zonage, les bordures etc... env.setTerrain(dtm); try { AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED); AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED); AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED); AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED); AssignZ.toZone(env.getUrbaZones(), dtm, false); } catch (Exception e) { e.printStackTrace(); } logger.info(\"Loading complete\"); return env; } Dans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).","title":"Code d'int\u00e9gration"},{"location":"envgeo/intro/","text":"Introduction \u00e0 l'environnement g\u00e9ographique \uf0c1 L'environnement g\u00e9ographique de SimPLU3D permet de d\u00e9crire l'ensemble des objets g\u00e9ographiques n\u00e9cessaires \u00e0 la g\u00e9n\u00e9ration de formes b\u00e2ties et notamment \u00e0 la v\u00e9rification des contraintes morphologiques. Ces objets g\u00e9ographiques peuvent concerner d'autres objets de la ville qui seront utilis\u00e9s pour v\u00e9rifier le respect des contraintes morphologiques (Par exemple, les routes,les limites s\u00e9paratives des parcelles, etc.) ou en lien avec l'application de r\u00e8glements d'urbanisme d'un territoire (Par exemple, les plans de zonage ou les servitudes d'utilit\u00e9 publique). L'ensemble des codes g\u00e9rant cet aspect se trouve dans le d\u00e9p\u00f4t SimPLU3D-rules dont la javadoc est consultable en ligne : https://SimPLU3D.github.io/simplu3D-rules . Il contient : un mod\u00e8le g\u00e9ographique ; des m\u00e9thodes automatiques d'int\u00e9gration , pour renseigner automatiquement les classes, les attributs et les relations n\u00e9cessaires au mod\u00e8le \u00e0 partir de donn\u00e9es g\u00e9ographiques usuelles \u00e0 partir de sources de donn\u00e9es ShapeFile ou PostGIS ; un exporteur pour visualiser dans un SIG les \u00e9l\u00e9ments cr\u00e9\u00e9s.","title":"Introduction"},{"location":"envgeo/intro/#introduction-a-lenvironnement-geographique","text":"L'environnement g\u00e9ographique de SimPLU3D permet de d\u00e9crire l'ensemble des objets g\u00e9ographiques n\u00e9cessaires \u00e0 la g\u00e9n\u00e9ration de formes b\u00e2ties et notamment \u00e0 la v\u00e9rification des contraintes morphologiques. Ces objets g\u00e9ographiques peuvent concerner d'autres objets de la ville qui seront utilis\u00e9s pour v\u00e9rifier le respect des contraintes morphologiques (Par exemple, les routes,les limites s\u00e9paratives des parcelles, etc.) ou en lien avec l'application de r\u00e8glements d'urbanisme d'un territoire (Par exemple, les plans de zonage ou les servitudes d'utilit\u00e9 publique). L'ensemble des codes g\u00e9rant cet aspect se trouve dans le d\u00e9p\u00f4t SimPLU3D-rules dont la javadoc est consultable en ligne : https://SimPLU3D.github.io/simplu3D-rules . Il contient : un mod\u00e8le g\u00e9ographique ; des m\u00e9thodes automatiques d'int\u00e9gration , pour renseigner automatiquement les classes, les attributs et les relations n\u00e9cessaires au mod\u00e8le \u00e0 partir de donn\u00e9es g\u00e9ographiques usuelles \u00e0 partir de sources de donn\u00e9es ShapeFile ou PostGIS ; un exporteur pour visualiser dans un SIG les \u00e9l\u00e9ments cr\u00e9\u00e9s.","title":"Introduction \u00e0 l'environnement g\u00e9ographique"},{"location":"envgeo/modelgeo/","text":"Mod\u00e8le g\u00e9ographique d\u00e9taill\u00e9 \uf0c1 Le mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels il est possible de d\u00e9finir des contraintes morphologiques et notamment de d\u00e9crire une r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des Plans Locaux d'Urbanisme . Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents. Ce mod\u00e8le a \u00e9t\u00e9 produit \u00e0 partir de la lecture de plusieurs PLU et des fiches m\u00e9thodologiques d'\u00e9criture des PLU du GRIDAUH . Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante : le mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non la r\u00e8gle form\u00e9e par cette phrase. La prise en compte de telles contraintes est d\u00e9crite dans la section d\u00e9finition de contraintes morphologiques . Pour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014 Vue global du mod\u00e8le \uf0c1 Le mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package fr.ign.cogit.simplu3d.model du projet SimPLU3D-rules . La javadoc est consultable en ligne . Vous pouvez cliquer sur les diff\u00e9rents sch\u00e9mas UML pr\u00e9sent\u00e9s dans cette section afin de les consulter en pleine r\u00e9solution. La figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es : les classes repr\u00e9sentant la r\u00e9glementation , c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ; les classes mod\u00e9lisant le parcellaire ; les classes concernant la mod\u00e9lisation 3D des b\u00e2timents ; les classes concernant les espaces publiques . Avant de pr\u00e9senter les classes, la classe parent Environnement sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le. Le mod\u00e8le est certes complexe dans l'absolu, n\u00e9anmoins il n'est pas n\u00e9cessaire (comme pr\u00e9sent\u00e9 dans l' exemple de la simulation basique ) de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une autre page . Les diagrammes de classes sont g\u00e9n\u00e9r\u00e9s avec le plugin ObjectAID d'Eclipse et les fichiers sont disponibles dans le dossier diagram de SimPLU3D-rules . Classe Environnement \uf0c1 La classe Environnement est une classe centrale dans le mod\u00e8le de SimPLU3D car elle est le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques. Elle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et s'il est d\u00e9fini au terrain qui servira de r\u00e9f\u00e9rence d'altitudes pour les donn\u00e9es n'ayant pas de g\u00e9om\u00e9trie 3D. L'instanciation d'un environnement s'effectue : soit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur les processus d'int\u00e9gration ) ; soit par le biais de la m\u00e9thode statique Environnement.createEnvironnement() qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide. Dans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique Environnement.getInstance() . L'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. L'attribut statique TRANSLATE_TO_ZERO indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et dpTranslate la valeur de cette translation. Classes de r\u00e9glementation \uf0c1 Les classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent et \u00e0 quels endroits. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS concernant la d\u00e9mat\u00e9rialisation des documents d'urbanisme. Cette norme vise \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce standard ( disponible en ligne ). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9s dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas pour les attributs purement informatifs et qui n'ont, a priori, pas d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire. La classe UrbaDocument est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration UrbaDocumentType comme les valeurs POS, PLU, etc. . La classe UrbaDocument poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode getGeom() ). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque UrbaZone et accessibles \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface IZoneRegulation ). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone (voir l'exemple sur les formats de r\u00e8gles ). Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie ( getUrbaZone() ) et un convertisseur en texte pour consulter les informations contenues ( toText() ). La classe Prescription vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, lin\u00e9aire ou surfacique et a un type qui est d\u00e9fini \u00e0 travers l'\u00e9num\u00e9ration PrescriptionType . Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans cette norme. Classes du parcellaire \uf0c1 Ces classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image, on trouve les diff\u00e9rentes relations d'inclusion entre BasicPropertyUnit , CadastralParcel et SubParcel ) les diff\u00e9rentes relations entre les parcelles, leurs limites s\u00e9paratives ( ParcelBoundary ) et les objets environnants. Les unit\u00e9s fonci\u00e8res (classe BasicPropertyUnit ) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re. Elles regroupent un ensemble de parcelles cadastrales (classe CadastralParcel ). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents ( getBuildings() ) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode getPol2D() et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode generateGeom() . Les parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles ( SubParcel ). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 ( UrbaZone ). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode ( getCode() ) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode hasToBeSimulated() ). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets ( ParcelBoundary ) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode getBoundaries() ) ou de les filtrer en fonction de leurs attributs (m\u00e9thode getBoundariesByType() ou getBoundariesBySide() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les sous-parcelles (classe SubParcel ) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe UrbaZone ). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode getUrbaZone() . Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode ( getBoundaries() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par getGeom() ). Ils mod\u00e9lisent les limites des parcelles ou des sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration ParcelBoundaryType et accessible par la m\u00e9thode getType() ) : BOT : pour les limites de fond de parcelle ; LAT : pour les limites lat\u00e9rales parcelle ; UNKNOWN : pour les limites dont on ne conna\u00eet pas le type ; INTRA : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ; ROAD : pour les limites donnant sur une route ( cf les classes concernant les espaces publiques ) ; PUB : pour les limites donnant sur l'espace publique ( cf les classes concernant les espaces publiques ). Les limites de type LAT ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration ParcelBoundarySide et accessible par la m\u00e9thode getSide() ) qui peut prendre les valeur RIGHT ou LEFT pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche. Les limites permettent d'acc\u00e9der aux objets topologiquement voisins comme une route ( getRoad() ), un espace public ( getPublicSpace() ) ou une parcelle ( getCadastralParcel() ). Les deux premiers objets ne sont acessibles que pour les limites de type ROAD ou PUB et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode getFeatAdj() mais n\u00e9cessite de caster l'objet en sortie. La m\u00e9thode getOppositeBoundary() permet d'obtenir pour les limites de type ROAD ou PUB , si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle. Classes des b\u00e2timents \uf0c1 Les classes mod\u00e9lisant les b\u00e2timents sont issues du standard CityGML V2.0 . Il y a deux classes de b\u00e2timents : les b\u00e2timents (classe Building ) et les parties de b\u00e2timents (classe BuildingPart ) qui instancient toutes les deux la classe abstraite AbstractBuilding . Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode getBPU() ). Ces b\u00e2timents sont d\u00e9coup\u00e9s en parties de b\u00e2timent en fonction des sous-parcelles (accessibles avec la m\u00e9thode getSubParcel() ). La plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite AbstractBuilding , parmi celles-ci les plus importantes pour un usage de SimPLU3D sont : isNew() : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ; getLOD2MultiSurface() : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ; getBuildingParts() : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ; getDestination() : renvoie le type du b\u00e2timent ; getFootPrint() : renvoie en 2D l'emprise du b\u00e2timent. Deux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes : prospect(IGeometry geom, double slope, double hIni) : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie. height(int pB, int pH) : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas. Valeurs de point haut : 0 : point en haut du plus haut \u00e9tage du b\u00e2timent ; 1 : point le plus bas du toit ; 2 : point le plus haut du b\u00e2timents. Valeurs de point bas : 0 : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ; 1 : point le plus bas de la parcelle ; 2 : point le plus bas du terrain ; 3 : point le plus haut du terrain. Les b\u00e2timents sont compos\u00e9s d'un objet de toit (classe RoofSurface ) accessible par la m\u00e9thode getRoof() et des objets de type surface de murs classe WallSurface accessibles par la m\u00e9thode getWallSurfaces() . L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits. Le toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode getGutter() ) en vert dans l'image, des ar\u00eates de pignons ( getGable() ) en orange dans l'image et des ar\u00eates sommets ( getRoofing() ) en bordeau sur l'image. Des angles minimaux (m\u00e9thode getAngleMin() ) et maximaux (m\u00e9thode getAngleMax() ) sont \u00e9galement disponibles. Concernant les surfaces de mur, chaque objet de la classe WallSurface repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration WallSurfaceType ) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode isWindowLess() ). Ces deux types de surface poss\u00e8dent des mat\u00e9riaux (classe Materiau ) qui ont un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuels placage de textures. Classes de l'espace publique \uf0c1 Ces classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les formes b\u00e2ties simul\u00e9es. Ces objets sont accessibles via les limites s\u00e9paratives (classe ParcelBoundary ). La classe PublicSpace repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode getType() ). Les routes (classe Road ) ont quelques informations attributaires classiques comme un nom (m\u00e9thode getName() ), une largeur (m\u00e9thode getWidth() ) et une liste d'usages (m\u00e9thode getUsages() ). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe ( getAxis() ) ou par une surface ( getGeom() ).","title":"Mod\u00e8le g\u00e9ographique d\u00e9taill\u00e9"},{"location":"envgeo/modelgeo/#modele-geographique-detaille","text":"Le mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels il est possible de d\u00e9finir des contraintes morphologiques et notamment de d\u00e9crire une r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des Plans Locaux d'Urbanisme . Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents. Ce mod\u00e8le a \u00e9t\u00e9 produit \u00e0 partir de la lecture de plusieurs PLU et des fiches m\u00e9thodologiques d'\u00e9criture des PLU du GRIDAUH . Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante : le mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non la r\u00e8gle form\u00e9e par cette phrase. La prise en compte de telles contraintes est d\u00e9crite dans la section d\u00e9finition de contraintes morphologiques . Pour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014","title":"Mod\u00e8le g\u00e9ographique d\u00e9taill\u00e9"},{"location":"envgeo/modelgeo/#vue-global-du-modele","text":"Le mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package fr.ign.cogit.simplu3d.model du projet SimPLU3D-rules . La javadoc est consultable en ligne . Vous pouvez cliquer sur les diff\u00e9rents sch\u00e9mas UML pr\u00e9sent\u00e9s dans cette section afin de les consulter en pleine r\u00e9solution. La figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es : les classes repr\u00e9sentant la r\u00e9glementation , c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ; les classes mod\u00e9lisant le parcellaire ; les classes concernant la mod\u00e9lisation 3D des b\u00e2timents ; les classes concernant les espaces publiques . Avant de pr\u00e9senter les classes, la classe parent Environnement sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le. Le mod\u00e8le est certes complexe dans l'absolu, n\u00e9anmoins il n'est pas n\u00e9cessaire (comme pr\u00e9sent\u00e9 dans l' exemple de la simulation basique ) de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une autre page . Les diagrammes de classes sont g\u00e9n\u00e9r\u00e9s avec le plugin ObjectAID d'Eclipse et les fichiers sont disponibles dans le dossier diagram de SimPLU3D-rules .","title":"Vue global du mod\u00e8le"},{"location":"envgeo/modelgeo/#classe-environnement","text":"La classe Environnement est une classe centrale dans le mod\u00e8le de SimPLU3D car elle est le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques. Elle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et s'il est d\u00e9fini au terrain qui servira de r\u00e9f\u00e9rence d'altitudes pour les donn\u00e9es n'ayant pas de g\u00e9om\u00e9trie 3D. L'instanciation d'un environnement s'effectue : soit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur les processus d'int\u00e9gration ) ; soit par le biais de la m\u00e9thode statique Environnement.createEnvironnement() qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide. Dans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique Environnement.getInstance() . L'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. L'attribut statique TRANSLATE_TO_ZERO indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et dpTranslate la valeur de cette translation.","title":"Classe Environnement"},{"location":"envgeo/modelgeo/#classes-de-reglementation","text":"Les classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent et \u00e0 quels endroits. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS concernant la d\u00e9mat\u00e9rialisation des documents d'urbanisme. Cette norme vise \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce standard ( disponible en ligne ). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9s dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas pour les attributs purement informatifs et qui n'ont, a priori, pas d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire. La classe UrbaDocument est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration UrbaDocumentType comme les valeurs POS, PLU, etc. . La classe UrbaDocument poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode getGeom() ). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque UrbaZone et accessibles \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface IZoneRegulation ). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone (voir l'exemple sur les formats de r\u00e8gles ). Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie ( getUrbaZone() ) et un convertisseur en texte pour consulter les informations contenues ( toText() ). La classe Prescription vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, lin\u00e9aire ou surfacique et a un type qui est d\u00e9fini \u00e0 travers l'\u00e9num\u00e9ration PrescriptionType . Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans cette norme.","title":"Classes de r\u00e9glementation"},{"location":"envgeo/modelgeo/#classes-du-parcellaire","text":"Ces classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image, on trouve les diff\u00e9rentes relations d'inclusion entre BasicPropertyUnit , CadastralParcel et SubParcel ) les diff\u00e9rentes relations entre les parcelles, leurs limites s\u00e9paratives ( ParcelBoundary ) et les objets environnants. Les unit\u00e9s fonci\u00e8res (classe BasicPropertyUnit ) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re. Elles regroupent un ensemble de parcelles cadastrales (classe CadastralParcel ). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents ( getBuildings() ) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode getPol2D() et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode generateGeom() . Les parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles ( SubParcel ). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 ( UrbaZone ). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode ( getCode() ) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode hasToBeSimulated() ). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets ( ParcelBoundary ) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode getBoundaries() ) ou de les filtrer en fonction de leurs attributs (m\u00e9thode getBoundariesByType() ou getBoundariesBySide() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les sous-parcelles (classe SubParcel ) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe UrbaZone ). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode getUrbaZone() . Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode ( getBoundaries() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par getGeom() ). Ils mod\u00e9lisent les limites des parcelles ou des sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration ParcelBoundaryType et accessible par la m\u00e9thode getType() ) : BOT : pour les limites de fond de parcelle ; LAT : pour les limites lat\u00e9rales parcelle ; UNKNOWN : pour les limites dont on ne conna\u00eet pas le type ; INTRA : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ; ROAD : pour les limites donnant sur une route ( cf les classes concernant les espaces publiques ) ; PUB : pour les limites donnant sur l'espace publique ( cf les classes concernant les espaces publiques ). Les limites de type LAT ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration ParcelBoundarySide et accessible par la m\u00e9thode getSide() ) qui peut prendre les valeur RIGHT ou LEFT pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche. Les limites permettent d'acc\u00e9der aux objets topologiquement voisins comme une route ( getRoad() ), un espace public ( getPublicSpace() ) ou une parcelle ( getCadastralParcel() ). Les deux premiers objets ne sont acessibles que pour les limites de type ROAD ou PUB et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode getFeatAdj() mais n\u00e9cessite de caster l'objet en sortie. La m\u00e9thode getOppositeBoundary() permet d'obtenir pour les limites de type ROAD ou PUB , si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle.","title":"Classes du parcellaire"},{"location":"envgeo/modelgeo/#classes-des-batiments","text":"Les classes mod\u00e9lisant les b\u00e2timents sont issues du standard CityGML V2.0 . Il y a deux classes de b\u00e2timents : les b\u00e2timents (classe Building ) et les parties de b\u00e2timents (classe BuildingPart ) qui instancient toutes les deux la classe abstraite AbstractBuilding . Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode getBPU() ). Ces b\u00e2timents sont d\u00e9coup\u00e9s en parties de b\u00e2timent en fonction des sous-parcelles (accessibles avec la m\u00e9thode getSubParcel() ). La plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite AbstractBuilding , parmi celles-ci les plus importantes pour un usage de SimPLU3D sont : isNew() : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ; getLOD2MultiSurface() : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ; getBuildingParts() : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ; getDestination() : renvoie le type du b\u00e2timent ; getFootPrint() : renvoie en 2D l'emprise du b\u00e2timent. Deux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes : prospect(IGeometry geom, double slope, double hIni) : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie. height(int pB, int pH) : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas. Valeurs de point haut : 0 : point en haut du plus haut \u00e9tage du b\u00e2timent ; 1 : point le plus bas du toit ; 2 : point le plus haut du b\u00e2timents. Valeurs de point bas : 0 : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ; 1 : point le plus bas de la parcelle ; 2 : point le plus bas du terrain ; 3 : point le plus haut du terrain. Les b\u00e2timents sont compos\u00e9s d'un objet de toit (classe RoofSurface ) accessible par la m\u00e9thode getRoof() et des objets de type surface de murs classe WallSurface accessibles par la m\u00e9thode getWallSurfaces() . L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits. Le toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode getGutter() ) en vert dans l'image, des ar\u00eates de pignons ( getGable() ) en orange dans l'image et des ar\u00eates sommets ( getRoofing() ) en bordeau sur l'image. Des angles minimaux (m\u00e9thode getAngleMin() ) et maximaux (m\u00e9thode getAngleMax() ) sont \u00e9galement disponibles. Concernant les surfaces de mur, chaque objet de la classe WallSurface repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration WallSurfaceType ) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode isWindowLess() ). Ces deux types de surface poss\u00e8dent des mat\u00e9riaux (classe Materiau ) qui ont un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuels placage de textures.","title":"Classes des b\u00e2timents"},{"location":"envgeo/modelgeo/#classes-de-lespace-publique","text":"Ces classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les formes b\u00e2ties simul\u00e9es. Ces objets sont accessibles via les limites s\u00e9paratives (classe ParcelBoundary ). La classe PublicSpace repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode getType() ). Les routes (classe Road ) ont quelques informations attributaires classiques comme un nom (m\u00e9thode getName() ), une largeur (m\u00e9thode getWidth() ) et une liste d'usages (m\u00e9thode getUsages() ). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe ( getAxis() ) ou par une surface ( getGeom() ).","title":"Classes de l'espace publique"},{"location":"generator/custom-generator/","text":"Param\u00e9trer les bo\u00eetes d'une configuration \uf0c1 Dans cette partie, nous d\u00e9crivons comment le syst\u00e8me d\u00e9finit la cr\u00e9ation de nouveaux objets param\u00e9triques et les modifications qui leur seront apport\u00e9es durant l'optimisation. Il s'agit de l'\u00e9tape 1 du code d\u00e9crit dans la section principe de simulation . Cet exemple s'appuie sur la g\u00e9n\u00e9ration de bo\u00eetes, mais il est possible de d\u00e9finir d'autres types de g\u00e9om\u00e9tries (cela sera d\u00e9crit dans la section G\u00e9n\u00e9rer d'autres types de formes ). Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans la derni\u00e8re partie de la page sur l'impl\u00e9mentation (\u00e9tape 1) , c'est \u00e0 dire le code suivant : // Step 1 : // Sampler creation (definition of the class and of the kernel modifications) // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications) Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p, bpu, pred, geom); D\u00e9finition des formes g\u00e9n\u00e9rables \uf0c1 Pour rappel, le processus d'optimisation vise \u00e0 g\u00e9n\u00e9rer une configuration compos\u00e9e de n bo\u00eetes chaque bo\u00eete pouvant \u00eatre d\u00e9finie par un vecteur de dimension 6 : b = ( x , y , l , w , h , \u03b8 ). Afin de pouvoir \u00e9chantillonner, il est n\u00e9cessaire de d\u00e9finir les intervalles dans lesquels le tirage des bo\u00eetes sera effectu\u00e9 : xmin < x < xmax ymin < y < ymax min\u03b8 < \u03b8 < max\u03b8 minwid < w < maxwid minlen < l < maxlen minheight < h < maxheight Les deux premi\u00e8res valeurs sont contraintes par l'enveloppe contenant la g\u00e9om\u00e9trie dans laquelle les centres de bo\u00eetes seront \u00e9chantillonn\u00e9s. Dans l'exemple de la premi\u00e8re simulation , min\u03b8 et max\u03b8 sont fix\u00e9s \u00e0 0 et \u03c0 afin de permettre tout type d'orientation. Les autres param\u00e8tres sont fix\u00e9s dans le fichier de configuration params.json . Afin que le syst\u00e8me puisse g\u00e9n\u00e9rer des formes, il est n\u00e9cessaire de d\u00e9finir une classe Builder qui permet d'instancier les objets \u00e0 partir d'un tableau contenant les param\u00e8tres de la forme. Dans l'exemple, il s'agit de la classe CuboidBuilder . D\u00e9finition des modifications \uf0c1 Une modification al\u00e9atoire est est d\u00e9termin\u00e9e par le choix d\u2019un des noyaux de proposition. Chaque noyau a la m\u00eame probabilit\u00e9 d'\u00eatre s\u00e9lectionn\u00e9. Dans le cadre de l'exemple, 6 noyaux sont utilis\u00e9s : ajout/suppression d\u2019une nouvelle bo\u00eete ; translation d\u2019une bo\u00eete ; changement de la longueur d\u2019une bo\u00eete ; changement de la largeur d\u2019une bo\u00eete ; changement de la hauteur d\u2019une bo\u00eete ; rotation d\u2019une bo\u00eete. Except\u00e9s les modifications issues du premier noyau, toutes les modifications sont impl\u00e9ment\u00e9es comme la suppression et l'ajout d'une bo\u00eete. Par exemple, une modification de type changement de longueur d'une bo\u00eete b = ( x , y , l , w , h , \u03b8 ) est traduite comme la suppression de cette bo\u00eete et la cr\u00e9ation d'une nouvelle bo\u00eete avec une longueur diff\u00e9rente, d\u00e9finie comme : b' = ( x , y , l + ( 1 - rand ) x ampli , w , h , \u03b8 ) o\u00f9 rand est un nombre al\u00e9atoire pris dans [0,1] et ampli est un coefficient d'amplification du d\u00e9placement (r\u00e9el strictement positif). Ainsi, dans la simulation exemple, les coefficients des amplifications ( amplitudeMove , amplitudeMaxDim , amplitudeHeight , amplitudeRotate ) sont stock\u00e9s dans le fichier de param\u00e9trage params.json . Les modifications sont impl\u00e9ment\u00e9es \u00e0 partir de la classe Kernel de la librjmcmc4j qui d\u00e9finit comment modifier un objet de la classe param\u00e9trique utilis\u00e9e \u00e0 partir d'un tirage al\u00e9atoire. Cr\u00e9ation de l'\u00e9chantillonneur de Green \uf0c1 Les derni\u00e8res \u00e9tapes visent \u00e0 d\u00e9finir l'objet qui va effectuer les tirages al\u00e9atoires des bo\u00eetes qui seront cr\u00e9\u00e9es (classe DirectSampler de librjmcmc4j) et l'\u00e9chantillonneur de Green qui va d\u00e9finir les modifications \u00e0 appliquer pendant la simulation et notamment la probabilit\u00e9 d'acception durant le process. Impl\u00e9mentation \uf0c1 Le code ci-dessous reprend l'impl\u00e9mentation de la cr\u00e9ation d'un \u00e9chantilloneur. /** * Creation of the sampler * @param rng a random generator * @param p the parameters loaded from the json file * @param bpU the basic property unit on which the simulation will be proceeded * @param pred a predicate that will check the respect of the rules * @param geom a geometry that will contains all the cuboid * @return a sampler that will be used during the simulation process */ public Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> create_sampler(RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU, ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred, IGeometry geom) { //Step 1 : Creation of the object that will control the birth and death of cuboid //Getting minimal and maximal dimension from the parameter file double minlen = Double.isNaN(this.minLengthBox) ? p.getDouble(\"minlen\") : this.minLengthBox; double maxlen = Double.isNaN(this.maxLengthBox) ? p.getDouble(\"maxlen\") : this.maxLengthBox; double minwid = Double.isNaN(this.minWidthBox) ? p.getDouble(\"minwid\") : this.minWidthBox; double maxwid = Double.isNaN(this.maxWidthBox) ? p.getDouble(\"maxwid\") : this.maxWidthBox; double minheight = p.getDouble(\"minheight\"); double maxheight = p.getDouble(\"maxheight\"); //Builder class of the object ObjectBuilder<Cuboid> builder = new CuboidBuilder(); //The geometry in which the sampler will be instanciated if (geom != null) { samplingSurface = geom; } if (samplingSurface == null) { samplingSurface = bpU.getGeom(); } IEnvelope env = samplingSurface.getEnvelope(); //Instanciation of the object dedicated for the creation of new cuboid during the process //Passing the building, the class (TransformToSurface) that will make // the transformation between random numbers and coordinates inside the samplingSurface UniformBirth<Cuboid> birth = new UniformBirth<Cuboid>(rng, new Cuboid(env.minX(), env.minY(), minlen, minwid, minheight, 0), new Cuboid(env.maxX(), env.maxY(), maxlen, maxwid, maxheight, Math.PI), builder, TransformToSurface.class, samplingSurface); //Step 2 : Listing the modification kernel //List of kernel for modification during the process List<Kernel<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> kernels = new ArrayList<>(); //A factory to create proper kernels KernelFactory<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> factory = new KernelFactory<>(); //Adding the birth/death kernel kernels.add( factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\")); //Adding the other modification kernel double amplitudeMove = p.getDouble(\"amplitudeMove\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveCuboid(amplitudeMove), 0.2, \"Move\")); double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180; kernels.add(factory.make_uniform_modification_kernel(rng, builder, new RotateCuboid(amplitudeRotate), 0.2, \"Rotate\")); double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeWidth(amplitudeMaxDim), 0.2, \"ChgWidth\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeLength(amplitudeMaxDim), 0.2, \"ChgLength\")); double amplitudeHeight = p.getDouble(\"amplitudeHeight\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeHeight(amplitudeHeight), 0.2, \"ChgHeight\")); //Step 3 : Creation of the sampler for the brith/death of cuboid // This distribution create a biais to make the system tends around a certain number of boxes PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\")); //Creation of the sampler with the modification in itself DirectSampler<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> ds = new DirectRejectionSampler<>( distribution, birth, pred); //Step 4 : Creation of the GreenSampler that will be used during the optimization process //It notably control the acception ratio and that the created objects and that the proposed configurations area generated //According to the uniformbirth Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> s = new GreenSamplerBlockTemperature<>(rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels); return s; }","title":"Param\u00e9trer la g\u00e9n\u00e9ration de bo\u00eetes"},{"location":"generator/custom-generator/#parametrer-les-boites-dune-configuration","text":"Dans cette partie, nous d\u00e9crivons comment le syst\u00e8me d\u00e9finit la cr\u00e9ation de nouveaux objets param\u00e9triques et les modifications qui leur seront apport\u00e9es durant l'optimisation. Il s'agit de l'\u00e9tape 1 du code d\u00e9crit dans la section principe de simulation . Cet exemple s'appuie sur la g\u00e9n\u00e9ration de bo\u00eetes, mais il est possible de d\u00e9finir d'autres types de g\u00e9om\u00e9tries (cela sera d\u00e9crit dans la section G\u00e9n\u00e9rer d'autres types de formes ). Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans la derni\u00e8re partie de la page sur l'impl\u00e9mentation (\u00e9tape 1) , c'est \u00e0 dire le code suivant : // Step 1 : // Sampler creation (definition of the class and of the kernel modifications) // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications) Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p, bpu, pred, geom);","title":"Param\u00e9trer les bo\u00eetes d'une configuration"},{"location":"generator/custom-generator/#definition-des-formes-generables","text":"Pour rappel, le processus d'optimisation vise \u00e0 g\u00e9n\u00e9rer une configuration compos\u00e9e de n bo\u00eetes chaque bo\u00eete pouvant \u00eatre d\u00e9finie par un vecteur de dimension 6 : b = ( x , y , l , w , h , \u03b8 ). Afin de pouvoir \u00e9chantillonner, il est n\u00e9cessaire de d\u00e9finir les intervalles dans lesquels le tirage des bo\u00eetes sera effectu\u00e9 : xmin < x < xmax ymin < y < ymax min\u03b8 < \u03b8 < max\u03b8 minwid < w < maxwid minlen < l < maxlen minheight < h < maxheight Les deux premi\u00e8res valeurs sont contraintes par l'enveloppe contenant la g\u00e9om\u00e9trie dans laquelle les centres de bo\u00eetes seront \u00e9chantillonn\u00e9s. Dans l'exemple de la premi\u00e8re simulation , min\u03b8 et max\u03b8 sont fix\u00e9s \u00e0 0 et \u03c0 afin de permettre tout type d'orientation. Les autres param\u00e8tres sont fix\u00e9s dans le fichier de configuration params.json . Afin que le syst\u00e8me puisse g\u00e9n\u00e9rer des formes, il est n\u00e9cessaire de d\u00e9finir une classe Builder qui permet d'instancier les objets \u00e0 partir d'un tableau contenant les param\u00e8tres de la forme. Dans l'exemple, il s'agit de la classe CuboidBuilder .","title":"D\u00e9finition des formes g\u00e9n\u00e9rables"},{"location":"generator/custom-generator/#definition-des-modifications","text":"Une modification al\u00e9atoire est est d\u00e9termin\u00e9e par le choix d\u2019un des noyaux de proposition. Chaque noyau a la m\u00eame probabilit\u00e9 d'\u00eatre s\u00e9lectionn\u00e9. Dans le cadre de l'exemple, 6 noyaux sont utilis\u00e9s : ajout/suppression d\u2019une nouvelle bo\u00eete ; translation d\u2019une bo\u00eete ; changement de la longueur d\u2019une bo\u00eete ; changement de la largeur d\u2019une bo\u00eete ; changement de la hauteur d\u2019une bo\u00eete ; rotation d\u2019une bo\u00eete. Except\u00e9s les modifications issues du premier noyau, toutes les modifications sont impl\u00e9ment\u00e9es comme la suppression et l'ajout d'une bo\u00eete. Par exemple, une modification de type changement de longueur d'une bo\u00eete b = ( x , y , l , w , h , \u03b8 ) est traduite comme la suppression de cette bo\u00eete et la cr\u00e9ation d'une nouvelle bo\u00eete avec une longueur diff\u00e9rente, d\u00e9finie comme : b' = ( x , y , l + ( 1 - rand ) x ampli , w , h , \u03b8 ) o\u00f9 rand est un nombre al\u00e9atoire pris dans [0,1] et ampli est un coefficient d'amplification du d\u00e9placement (r\u00e9el strictement positif). Ainsi, dans la simulation exemple, les coefficients des amplifications ( amplitudeMove , amplitudeMaxDim , amplitudeHeight , amplitudeRotate ) sont stock\u00e9s dans le fichier de param\u00e9trage params.json . Les modifications sont impl\u00e9ment\u00e9es \u00e0 partir de la classe Kernel de la librjmcmc4j qui d\u00e9finit comment modifier un objet de la classe param\u00e9trique utilis\u00e9e \u00e0 partir d'un tirage al\u00e9atoire.","title":"D\u00e9finition des modifications"},{"location":"generator/custom-generator/#creation-de-lechantillonneur-de-green","text":"Les derni\u00e8res \u00e9tapes visent \u00e0 d\u00e9finir l'objet qui va effectuer les tirages al\u00e9atoires des bo\u00eetes qui seront cr\u00e9\u00e9es (classe DirectSampler de librjmcmc4j) et l'\u00e9chantillonneur de Green qui va d\u00e9finir les modifications \u00e0 appliquer pendant la simulation et notamment la probabilit\u00e9 d'acception durant le process.","title":"Cr\u00e9ation de l'\u00e9chantillonneur de Green"},{"location":"generator/custom-generator/#implementation","text":"Le code ci-dessous reprend l'impl\u00e9mentation de la cr\u00e9ation d'un \u00e9chantilloneur. /** * Creation of the sampler * @param rng a random generator * @param p the parameters loaded from the json file * @param bpU the basic property unit on which the simulation will be proceeded * @param pred a predicate that will check the respect of the rules * @param geom a geometry that will contains all the cuboid * @return a sampler that will be used during the simulation process */ public Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> create_sampler(RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU, ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred, IGeometry geom) { //Step 1 : Creation of the object that will control the birth and death of cuboid //Getting minimal and maximal dimension from the parameter file double minlen = Double.isNaN(this.minLengthBox) ? p.getDouble(\"minlen\") : this.minLengthBox; double maxlen = Double.isNaN(this.maxLengthBox) ? p.getDouble(\"maxlen\") : this.maxLengthBox; double minwid = Double.isNaN(this.minWidthBox) ? p.getDouble(\"minwid\") : this.minWidthBox; double maxwid = Double.isNaN(this.maxWidthBox) ? p.getDouble(\"maxwid\") : this.maxWidthBox; double minheight = p.getDouble(\"minheight\"); double maxheight = p.getDouble(\"maxheight\"); //Builder class of the object ObjectBuilder<Cuboid> builder = new CuboidBuilder(); //The geometry in which the sampler will be instanciated if (geom != null) { samplingSurface = geom; } if (samplingSurface == null) { samplingSurface = bpU.getGeom(); } IEnvelope env = samplingSurface.getEnvelope(); //Instanciation of the object dedicated for the creation of new cuboid during the process //Passing the building, the class (TransformToSurface) that will make // the transformation between random numbers and coordinates inside the samplingSurface UniformBirth<Cuboid> birth = new UniformBirth<Cuboid>(rng, new Cuboid(env.minX(), env.minY(), minlen, minwid, minheight, 0), new Cuboid(env.maxX(), env.maxY(), maxlen, maxwid, maxheight, Math.PI), builder, TransformToSurface.class, samplingSurface); //Step 2 : Listing the modification kernel //List of kernel for modification during the process List<Kernel<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> kernels = new ArrayList<>(); //A factory to create proper kernels KernelFactory<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> factory = new KernelFactory<>(); //Adding the birth/death kernel kernels.add( factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\")); //Adding the other modification kernel double amplitudeMove = p.getDouble(\"amplitudeMove\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveCuboid(amplitudeMove), 0.2, \"Move\")); double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180; kernels.add(factory.make_uniform_modification_kernel(rng, builder, new RotateCuboid(amplitudeRotate), 0.2, \"Rotate\")); double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeWidth(amplitudeMaxDim), 0.2, \"ChgWidth\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeLength(amplitudeMaxDim), 0.2, \"ChgLength\")); double amplitudeHeight = p.getDouble(\"amplitudeHeight\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeHeight(amplitudeHeight), 0.2, \"ChgHeight\")); //Step 3 : Creation of the sampler for the brith/death of cuboid // This distribution create a biais to make the system tends around a certain number of boxes PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\")); //Creation of the sampler with the modification in itself DirectSampler<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> ds = new DirectRejectionSampler<>( distribution, birth, pred); //Step 4 : Creation of the GreenSampler that will be used during the optimization process //It notably control the acception ratio and that the created objects and that the proposed configurations area generated //According to the uniformbirth Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> s = new GreenSamplerBlockTemperature<>(rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels); return s; }","title":"Impl\u00e9mentation"},{"location":"generator/custom-optimisation/","text":"Param\u00e9trer la fonction d'optimisation \uf0c1 Dans cette partie, nous pr\u00e9sentons comment est configur\u00e9 l'algorithme d'optimisation \u00e0 travers les conditions initiales et d'arr\u00eat, ainsi que la d\u00e9finition de la fonction d'optimisation. Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans la derni\u00e8re partie de la page sur l'impl\u00e9mentation (\u00e9tape 2) , c'est \u00e0 dire le code suivant : //Step 2 : Preparation of the optimizer //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur //Initializing the configuration (optimisation function + set of cuboid) //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante GraphConfiguration<Cuboid> conf = null; try { conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu); } catch (Exception e) { e.printStackTrace(); } // Temperature initialization //Initialization de la fonction de la temp\u00e9rature Schedule<SimpleTemperature> sch = create_schedule(p); //The end test condition end = create_end_test(p); D\u00e9finition de la fonction d'optimisation \uf0c1 Principe g\u00e9n\u00e9ral \uf0c1 La fonction \u00e0 optimiser est contenue dans un objet de la classe g\u00e9n\u00e9rique GraphConfiguration<?> \u00e0 typer en fonction de la classe param\u00e9trique utilis\u00e9e. La fonction d'optimisation est compos\u00e9e de 3 \u00e9nergies : une \u00e9nergie unaire (interface UnaryEnergy<?> ), qui \u00e9value ind\u00e9pendant une \u00e9nergie pour chacun des objets ; une \u00e9nergie binaire (interface BinaryEnergy<?> ), qui \u00e9value une \u00e9nergie pour chaque couple d'objet ; une \u00e9nergie de collection facultative (interface CollectionEnergy<?> ), qui \u00e9value la somme pour l'ensemble de la collection. Les interfaces des classes ne d\u00e9finissent qu'une m\u00e9thode double getValue() qui renvoie la valeur num\u00e9rique associ\u00e9e La valeur de la fonction d'optimisation est la somme des contributions de ces trois types d'\u00e9nergie. Pour produire ces contributions, il est possible, pour chaque type d'\u00e9nergie, de combiner diff\u00e9rents op\u00e9rateurs (addition, soustraction, multiplication, etc.) pour produire des \u00e9nergies composites. La d\u00e9finition de ces op\u00e9rateurs se trouve dans le package fr.ign.rjmcmc.energy de la librjmcmc4j. Attention : la librjmcmc4j est une biblioth\u00e8que minimisant par convention la fonction \u00e9nerg\u00e9tique, il est n\u00e9cessaire d'adapter l'instanciation de la fonction d'\u00e9nergie en accord avec ce principe. Dans l'exemple au d\u00e9but, il s'agit de minimiser - volume(configuration)). Illustration avec l'exemple \uf0c1 La formule de l'\u00e9nergie dans l'exemple est la suivante : L'\u00e9nergie unaire contient diff\u00e9rents termes : Ecreation a pour objectif de p\u00e9naliser les bo\u00eetes ne contribuant pas suffisamment \u00e0 la configuration. La d\u00e9finition de ce param\u00e8tre est indispensable : en effet, rien n\u2019emp\u00eache l\u2019intersection de bo\u00eetes et pour proposer des configurations plus parcimonieuses, il est n\u00e9cessaire pour le syst\u00e8me d'optimisation de p\u00e9naliser l'ajout de bo\u00eetes. Sans ce param\u00e8tre, que nous nommons \u00e9nergie de cr\u00e9ation, le syst\u00e8me pourrait tr\u00e8s bien proposer des configurations contenant de tr\u00e8s nombreuses bo\u00eetes qui ne contribueraient pas \u00e0 augmenter le volume global de la configuration. Au final, avec ce terme, le syst\u00e8me ne garde une bo\u00eete que si elle am\u00e9liore le score globale et elle n'am\u00e9liore le score globale que si le fait d'ajouter une bo\u00eete am\u00e9liore le score global d'au moins la p\u00e9nalisation du co\u00fbt cr\u00e9ation de la bo\u00eete ; volume(b) qui d\u00e9finit le volume de chaque bo\u00eete ind\u00e9pendamment ; volumeDifference(bPU,b) qui d\u00e9finit une \u00e9nergie en fonction du d\u00e9passement en termes de volume de l'unit\u00e9 fonci\u00e8re simul\u00e9e (bPU). Cette contrainte est ajout\u00e9e comme les r\u00e8gles n'imposent pas dans l'exemple que les bo\u00eetes se trouvent strictement \u00e0 l'int\u00e9rieur de l'unit\u00e9 fonci\u00e8re. L'objectif de ce terme est d'autoriser le d\u00e9passement que si celui-ci contribue significativement \u00e0 l'am\u00e9lioration du volume. Les deux derniers termes sont pond\u00e9r\u00e9s par les ponderationVolume et ponderationDifference . L'\u00e9nergie binaire est compos\u00e9 de l'op\u00e9rateur volumeintersection(b1, b2) qui \u00e9value la diff\u00e9rence des volumes entre chaque couple de bo\u00eete qui est pond\u00e9r\u00e9 par ponderation_volume_inter . Les diff\u00e9rentes pond\u00e9rations et la valeur Ecreation sont param\u00e9trables, dans l'exemple, dans le fichier params.json . La figure ci-dessus repr\u00e9sente le graphe d'\u00e9nergie tel que mod\u00e9lis\u00e9 en accord avec le formalisme de la librjmcmc4j. Les \u00e9nergies dynamiques sont \u00e9valu\u00e9es \u00e0 chaque it\u00e9ration et impl\u00e9mentent UnaryEnergy<?> et BinaryEnergy<?> en fonction de l'\u00e9nergie mod\u00e9lis\u00e9e. Il s'agit d'une repr\u00e9sentation du code qui se situe ci-dessous et qui est utilis\u00e9 dans le premier exemple de simulation. /** * Creation of a cuboid configuration * @param p parameters from the json file * @param bpu the basic property unit on which the optimization will be * proceeded * @param geom the geometry that contains the cuboids * @return a new configuration that embeds the calculation of the optimization * function */ public GraphConfiguration<Cuboid> create_configuration(SimpluParameters p, Geometry geom, BasicPropertyUnit bpu) { // \u00c9nergie constante : \u00e0 la cr\u00e9ation d'un nouvel objet ConstantEnergy<Cuboid, Cuboid> energyCreation = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"energy\")); // \u00c9nergie constante : pond\u00e9ration de l'intersection ConstantEnergy<Cuboid, Cuboid> ponderationVolume = new ConstantEnergy<Cuboid, Cuboid>( p.getDouble(\"ponderation_volume\")); // \u00c9nergie unaire : aire dans la parcelle UnaryEnergy<Cuboid> energyVolume = new VolumeUnaryEnergy<Cuboid>(); // Multiplication de l'\u00e9nergie d'intersection et de l'aire UnaryEnergy<Cuboid> energyVolumePondere = new MultipliesUnaryEnergy<Cuboid>(ponderationVolume, energyVolume); // On retire de l'\u00e9nergie de cr\u00e9ation, l'\u00e9nergie de l'aire UnaryEnergy<Cuboid> u3 = new MinusUnaryEnergy<Cuboid>(energyCreation, energyVolumePondere); double ponderationExt = p.getDouble(\"ponderation_difference_ext\"); UnaryEnergy<Cuboid> unaryEnergy; if (ponderationExt != 0) { // \u00c9nergie constante : pond\u00e9ration de la diff\u00e9rence ConstantEnergy<Cuboid, Cuboid> ponderationDifference = new ConstantEnergy<Cuboid, Cuboid>( p.getDouble(\"ponderation_difference_ext\")); // On ajoute l'\u00e9nergie de diff\u00e9rence : la zone en dehors de la parcelle UnaryEnergy<Cuboid> u4 = new DifferenceVolumeUnaryEnergy<Cuboid>(geom); UnaryEnergy<Cuboid> u5 = new MultipliesUnaryEnergy<Cuboid>(ponderationDifference, u4); unaryEnergy = new PlusUnaryEnergy<Cuboid>(u3, u5); } else { unaryEnergy = u3; } // \u00c9nergie binaire : intersection entre deux rectangles ConstantEnergy<Cuboid, Cuboid> c3 = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"ponderation_volume_inter\")); BinaryEnergy<Cuboid, Cuboid> b1 = new IntersectionVolumeBinaryEnergy<Cuboid>(); BinaryEnergy<Cuboid, Cuboid> binaryEnergy = new MultipliesBinaryEnergy<Cuboid, Cuboid>(c3, b1); // empty initial configuration*/ GraphConfiguration<Cuboid> conf = new GraphConfiguration<>(unaryEnergy, binaryEnergy); return conf; } Conditions initiales et condition d'arr\u00eat \uf0c1 La fonction de temp\u00e9rature est fix\u00e9e dans la m\u00e9thode create_schedule et vise \u00e0 moduler la probabilit\u00e9 d'acceptation durant la simulation. Les diff\u00e9rents types possibles de temp\u00e9rature sont ceux de la librjmcmc4j (package fr.ign.simulatedannealing.schedule ). Dans le cadre de SimPLU3D, nous avons opt\u00e9 pour la temp\u00e9rature de M\u00e9tropolis. Il s'agit d'une fonction g\u00e9om\u00e9trique d\u00e9croissante qui n\u00e9cessite deux param\u00e8tres : une temp\u00e9rature initiale (valeur temp du fichier de configuration) et un coefficient de d\u00e9croissance (valeur deccoef ). D'apr\u00e8s les articles sur le recuit simul\u00e9, il est conseill\u00e9 de fixer cette valeur comme \u00e9tant la plus grande variation possible de la fonction d'optimisation entre deux \u00e9tats (par exemple, dans le cadre du volume, il s'agit de l'\u00e9cart entre une parcelle vide et une parcelle compl\u00e8tement b\u00e2tie par le b\u00e2timent le plus haut possible). Le coefficient doit \u00eatre fix\u00e9 tr\u00e8s proche de 1 (comme dans les fichiers exemples). Si vous souhaitez en savoir plus, vous pouvez consulter l'article suivant : Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf ) Trois types de condition d'arr\u00eat sont utilisables \u00e0 travers la m\u00e9thode create_end_test et leurs param\u00e8tres sont d\u00e9finis dans le fichier de configuration : - absolute : le simulateur s'arr\u00eate au bout de absolute_nb_iter ) it\u00e9rations, ce nombre est fix\u00e9 dans le fichier de configuration ; - relative : le simulateur si la fonction \u00e9nerg\u00e9tique ne s'am\u00e9liore pas de la valeur delta pendant relative_nb_iter it\u00e9rations ; - composite : le simulation s'arr\u00eate lorsque la premi\u00e8re condition d'arr\u00eat (entre absolute et relative) est atteinte. On peut choisir avec le fichier de configuration entre ces trois types gr\u00e2ce au param\u00e8tre end_test_type qui peut prendre comme valeur absolute , relative ou composite .","title":"Personnaliser la fonction d'optimisation"},{"location":"generator/custom-optimisation/#parametrer-la-fonction-doptimisation","text":"Dans cette partie, nous pr\u00e9sentons comment est configur\u00e9 l'algorithme d'optimisation \u00e0 travers les conditions initiales et d'arr\u00eat, ainsi que la d\u00e9finition de la fonction d'optimisation. Les parties suivantes reprennent les principales \u00e9tapes de cr\u00e9ation du sampler dont le code est repris dans la derni\u00e8re partie de la page sur l'impl\u00e9mentation (\u00e9tape 2) , c'est \u00e0 dire le code suivant : //Step 2 : Preparation of the optimizer //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur //Initializing the configuration (optimisation function + set of cuboid) //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante GraphConfiguration<Cuboid> conf = null; try { conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu); } catch (Exception e) { e.printStackTrace(); } // Temperature initialization //Initialization de la fonction de la temp\u00e9rature Schedule<SimpleTemperature> sch = create_schedule(p); //The end test condition end = create_end_test(p);","title":"Param\u00e9trer la fonction d'optimisation"},{"location":"generator/custom-optimisation/#definition-de-la-fonction-doptimisation","text":"","title":"D\u00e9finition de la fonction d'optimisation"},{"location":"generator/custom-optimisation/#principe-general","text":"La fonction \u00e0 optimiser est contenue dans un objet de la classe g\u00e9n\u00e9rique GraphConfiguration<?> \u00e0 typer en fonction de la classe param\u00e9trique utilis\u00e9e. La fonction d'optimisation est compos\u00e9e de 3 \u00e9nergies : une \u00e9nergie unaire (interface UnaryEnergy<?> ), qui \u00e9value ind\u00e9pendant une \u00e9nergie pour chacun des objets ; une \u00e9nergie binaire (interface BinaryEnergy<?> ), qui \u00e9value une \u00e9nergie pour chaque couple d'objet ; une \u00e9nergie de collection facultative (interface CollectionEnergy<?> ), qui \u00e9value la somme pour l'ensemble de la collection. Les interfaces des classes ne d\u00e9finissent qu'une m\u00e9thode double getValue() qui renvoie la valeur num\u00e9rique associ\u00e9e La valeur de la fonction d'optimisation est la somme des contributions de ces trois types d'\u00e9nergie. Pour produire ces contributions, il est possible, pour chaque type d'\u00e9nergie, de combiner diff\u00e9rents op\u00e9rateurs (addition, soustraction, multiplication, etc.) pour produire des \u00e9nergies composites. La d\u00e9finition de ces op\u00e9rateurs se trouve dans le package fr.ign.rjmcmc.energy de la librjmcmc4j. Attention : la librjmcmc4j est une biblioth\u00e8que minimisant par convention la fonction \u00e9nerg\u00e9tique, il est n\u00e9cessaire d'adapter l'instanciation de la fonction d'\u00e9nergie en accord avec ce principe. Dans l'exemple au d\u00e9but, il s'agit de minimiser - volume(configuration)).","title":"Principe g\u00e9n\u00e9ral"},{"location":"generator/custom-optimisation/#illustration-avec-lexemple","text":"La formule de l'\u00e9nergie dans l'exemple est la suivante : L'\u00e9nergie unaire contient diff\u00e9rents termes : Ecreation a pour objectif de p\u00e9naliser les bo\u00eetes ne contribuant pas suffisamment \u00e0 la configuration. La d\u00e9finition de ce param\u00e8tre est indispensable : en effet, rien n\u2019emp\u00eache l\u2019intersection de bo\u00eetes et pour proposer des configurations plus parcimonieuses, il est n\u00e9cessaire pour le syst\u00e8me d'optimisation de p\u00e9naliser l'ajout de bo\u00eetes. Sans ce param\u00e8tre, que nous nommons \u00e9nergie de cr\u00e9ation, le syst\u00e8me pourrait tr\u00e8s bien proposer des configurations contenant de tr\u00e8s nombreuses bo\u00eetes qui ne contribueraient pas \u00e0 augmenter le volume global de la configuration. Au final, avec ce terme, le syst\u00e8me ne garde une bo\u00eete que si elle am\u00e9liore le score globale et elle n'am\u00e9liore le score globale que si le fait d'ajouter une bo\u00eete am\u00e9liore le score global d'au moins la p\u00e9nalisation du co\u00fbt cr\u00e9ation de la bo\u00eete ; volume(b) qui d\u00e9finit le volume de chaque bo\u00eete ind\u00e9pendamment ; volumeDifference(bPU,b) qui d\u00e9finit une \u00e9nergie en fonction du d\u00e9passement en termes de volume de l'unit\u00e9 fonci\u00e8re simul\u00e9e (bPU). Cette contrainte est ajout\u00e9e comme les r\u00e8gles n'imposent pas dans l'exemple que les bo\u00eetes se trouvent strictement \u00e0 l'int\u00e9rieur de l'unit\u00e9 fonci\u00e8re. L'objectif de ce terme est d'autoriser le d\u00e9passement que si celui-ci contribue significativement \u00e0 l'am\u00e9lioration du volume. Les deux derniers termes sont pond\u00e9r\u00e9s par les ponderationVolume et ponderationDifference . L'\u00e9nergie binaire est compos\u00e9 de l'op\u00e9rateur volumeintersection(b1, b2) qui \u00e9value la diff\u00e9rence des volumes entre chaque couple de bo\u00eete qui est pond\u00e9r\u00e9 par ponderation_volume_inter . Les diff\u00e9rentes pond\u00e9rations et la valeur Ecreation sont param\u00e9trables, dans l'exemple, dans le fichier params.json . La figure ci-dessus repr\u00e9sente le graphe d'\u00e9nergie tel que mod\u00e9lis\u00e9 en accord avec le formalisme de la librjmcmc4j. Les \u00e9nergies dynamiques sont \u00e9valu\u00e9es \u00e0 chaque it\u00e9ration et impl\u00e9mentent UnaryEnergy<?> et BinaryEnergy<?> en fonction de l'\u00e9nergie mod\u00e9lis\u00e9e. Il s'agit d'une repr\u00e9sentation du code qui se situe ci-dessous et qui est utilis\u00e9 dans le premier exemple de simulation. /** * Creation of a cuboid configuration * @param p parameters from the json file * @param bpu the basic property unit on which the optimization will be * proceeded * @param geom the geometry that contains the cuboids * @return a new configuration that embeds the calculation of the optimization * function */ public GraphConfiguration<Cuboid> create_configuration(SimpluParameters p, Geometry geom, BasicPropertyUnit bpu) { // \u00c9nergie constante : \u00e0 la cr\u00e9ation d'un nouvel objet ConstantEnergy<Cuboid, Cuboid> energyCreation = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"energy\")); // \u00c9nergie constante : pond\u00e9ration de l'intersection ConstantEnergy<Cuboid, Cuboid> ponderationVolume = new ConstantEnergy<Cuboid, Cuboid>( p.getDouble(\"ponderation_volume\")); // \u00c9nergie unaire : aire dans la parcelle UnaryEnergy<Cuboid> energyVolume = new VolumeUnaryEnergy<Cuboid>(); // Multiplication de l'\u00e9nergie d'intersection et de l'aire UnaryEnergy<Cuboid> energyVolumePondere = new MultipliesUnaryEnergy<Cuboid>(ponderationVolume, energyVolume); // On retire de l'\u00e9nergie de cr\u00e9ation, l'\u00e9nergie de l'aire UnaryEnergy<Cuboid> u3 = new MinusUnaryEnergy<Cuboid>(energyCreation, energyVolumePondere); double ponderationExt = p.getDouble(\"ponderation_difference_ext\"); UnaryEnergy<Cuboid> unaryEnergy; if (ponderationExt != 0) { // \u00c9nergie constante : pond\u00e9ration de la diff\u00e9rence ConstantEnergy<Cuboid, Cuboid> ponderationDifference = new ConstantEnergy<Cuboid, Cuboid>( p.getDouble(\"ponderation_difference_ext\")); // On ajoute l'\u00e9nergie de diff\u00e9rence : la zone en dehors de la parcelle UnaryEnergy<Cuboid> u4 = new DifferenceVolumeUnaryEnergy<Cuboid>(geom); UnaryEnergy<Cuboid> u5 = new MultipliesUnaryEnergy<Cuboid>(ponderationDifference, u4); unaryEnergy = new PlusUnaryEnergy<Cuboid>(u3, u5); } else { unaryEnergy = u3; } // \u00c9nergie binaire : intersection entre deux rectangles ConstantEnergy<Cuboid, Cuboid> c3 = new ConstantEnergy<Cuboid, Cuboid>(p.getDouble(\"ponderation_volume_inter\")); BinaryEnergy<Cuboid, Cuboid> b1 = new IntersectionVolumeBinaryEnergy<Cuboid>(); BinaryEnergy<Cuboid, Cuboid> binaryEnergy = new MultipliesBinaryEnergy<Cuboid, Cuboid>(c3, b1); // empty initial configuration*/ GraphConfiguration<Cuboid> conf = new GraphConfiguration<>(unaryEnergy, binaryEnergy); return conf; }","title":"Illustration avec l'exemple"},{"location":"generator/custom-optimisation/#conditions-initiales-et-condition-darret","text":"La fonction de temp\u00e9rature est fix\u00e9e dans la m\u00e9thode create_schedule et vise \u00e0 moduler la probabilit\u00e9 d'acceptation durant la simulation. Les diff\u00e9rents types possibles de temp\u00e9rature sont ceux de la librjmcmc4j (package fr.ign.simulatedannealing.schedule ). Dans le cadre de SimPLU3D, nous avons opt\u00e9 pour la temp\u00e9rature de M\u00e9tropolis. Il s'agit d'une fonction g\u00e9om\u00e9trique d\u00e9croissante qui n\u00e9cessite deux param\u00e8tres : une temp\u00e9rature initiale (valeur temp du fichier de configuration) et un coefficient de d\u00e9croissance (valeur deccoef ). D'apr\u00e8s les articles sur le recuit simul\u00e9, il est conseill\u00e9 de fixer cette valeur comme \u00e9tant la plus grande variation possible de la fonction d'optimisation entre deux \u00e9tats (par exemple, dans le cadre du volume, il s'agit de l'\u00e9cart entre une parcelle vide et une parcelle compl\u00e8tement b\u00e2tie par le b\u00e2timent le plus haut possible). Le coefficient doit \u00eatre fix\u00e9 tr\u00e8s proche de 1 (comme dans les fichiers exemples). Si vous souhaitez en savoir plus, vous pouvez consulter l'article suivant : Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf ) Trois types de condition d'arr\u00eat sont utilisables \u00e0 travers la m\u00e9thode create_end_test et leurs param\u00e8tres sont d\u00e9finis dans le fichier de configuration : - absolute : le simulateur s'arr\u00eate au bout de absolute_nb_iter ) it\u00e9rations, ce nombre est fix\u00e9 dans le fichier de configuration ; - relative : le simulateur si la fonction \u00e9nerg\u00e9tique ne s'am\u00e9liore pas de la valeur delta pendant relative_nb_iter it\u00e9rations ; - composite : le simulation s'arr\u00eate lorsque la premi\u00e8re condition d'arr\u00eat (entre absolute et relative) est atteinte. On peut choisir avec le fichier de configuration entre ces trois types gr\u00e2ce au param\u00e8tre end_test_type qui peut prendre comme valeur absolute , relative ou composite .","title":"Conditions initiales et condition d'arr\u00eat"},{"location":"generator/custom-shape/","text":"G\u00e9n\u00e9ration de b\u00e2timents en L \uf0c1 L'objectif de cette partie est de pr\u00e9senter un code permettant de g\u00e9n\u00e9rer des b\u00e2timents en forme de L avec un toit typifi\u00e9 et de d\u00e9crire les \u00e9tapes \u00e0 suivre pour g\u00e9n\u00e9rer des configurations avec d'autres types de forme \u00e0 partir du simulateur basique pr\u00e9sent\u00e9 dans la premi\u00e8re exp\u00e9rimentation . Code exemple \uf0c1 L'ex\u00e9cution du code pr\u00e9sent\u00e9 ici se trouve dans la classe fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection du projet SimPLU3D-tutorial. La classe de g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e (pr\u00e9sent\u00e9e dans le sch\u00e9ma pr\u00e9c\u00e9dent) comporte 10 dimensions : x : coordonn\u00e9e x du centre de la forme ; y : coordonn\u00e9e y du centre de la forme ; l1 : longueur de la forme hors barre du L ; l2 : longueur de la barre du L ; h1 : hauteur totale de la forme hors barre du L; h2 : hauteur totale de la barre du L; height : hauteur maximale de la forme ; orientation : orientation (azimut) du L ; hgutter : hauteur \u00e0 la goutti\u00e8re. shift : pente du toit aux extr\u00e9mit\u00e9s du L (entre 0 pas de pente et 1 pente jusqu'au milieu de la forme). D\u00e9finition de la classe repr\u00e9sentant la forme \uf0c1 La classe d\u00e9finissant la g\u00e9om\u00e9trie simul\u00e9e est la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.geometry.impl.LBuildingWithRoof du projet SimPLU3D. Cette classe impl\u00e9mente la classe AbstractSimpleBuilding (comme nous simulons un objet de type b\u00e2timent, comme c'est le cas pour la classe Cubboid ). Cela implique l'instanciation de 3 niveaux de classes abstraites et d'interfaces : - la classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.impl.AbstractSimpleBuilding de SimPLU3D-rules : qui contient les informations n\u00e9cessaires pour mod\u00e9liser un objet de type b\u00e2timent de SimPLU3D ; - l'interface fr.ign.cogit.simplu3d.rjmcmc.generic.objectISimPLU3DPrimitive : qui contient les m\u00e9thodes propres \u00e0 SimPLU3D concernant l'optimisation de forme ; - l'interface de la librjmcmc4j fr.ign.geometry.Primitive : qui contient les informations n\u00e9cessaires pour simuler des objets g\u00e9ographiques avec la librjmcmc4j. Seule l'impl\u00e9mentation de la derni\u00e8re interface est n\u00e9cessaire pour g\u00e9n\u00e9rer des formes, les deux autres niveaux enrichissent les m\u00e9thodes accessibles pour la v\u00e9rification des r\u00e8gles et la d\u00e9finition de la fonction d'optimisation. Elles facilitent \u00e9galement la r\u00e9-utilisation du code de la premi\u00e8re simulation. L'impl\u00e9mentation de l'interface Primitive n\u00e9cessite la d\u00e9finition des m\u00e9thodes suivantes : int size(); : renvoie la taille de la dimension de la forme (ici 10 pour le b\u00e2timent en L) ; double[] toArray() : traduit les attributs de la classe en un tableau de double (il s'agit ici d'un tableau de dimension 10 contenant les valeurs des diff\u00e9rentes dimensions de la forme) ; Object[] getArray(); : m\u00eame m\u00e9thode que pr\u00e9c\u00e9demment, mais avec des valeurs sous forme d'objets ; void set(List list); : affecte aux attributs de la classe les valeurs provenant d'un tableau de double (ici une liste de 10 chiffres qui correspondent aux 10 dimensions de la classe) ; double intersectionArea(Primitive p); : \u00e9value la surface de l'intersection 2D avec une autre primitive (ici avec d'autres b\u00e2timents en L) ; Geometry toGeometry(); : convertit la forme en g\u00e9om\u00e9trie 2D JTS (ici l'emprise 2D du b\u00e2timent, la conversion JTS permet d'optimiser les temps de calcul par rapport \u00e0 l'utilisation de g\u00e9om\u00e9tries GeOxygene) ; double getArea(); : l'aire 2D de l'emprise de la forme. La classe LBuildingWithRoof impl\u00e9mente cette interface \u00e0 travers la classe AbstractSimpleBuilding . Elle impl\u00e9mente \u00e9galement l'interface fr.ign.cogit.simplu3d.rjmcmc.generic.object.ISimPLU3DPrimitive qui est n\u00e9cessaire pour pouvoir appliquer le v\u00e9rificateur de forme. Cela n\u00e9cessite l'impl\u00e9mentation de trois m\u00e9thodes : double getHeight(); : la hauteur maximale de la forme ; double getVolume(); : le volume de la forme ; IGeometry generated3DGeom(); renvoie une g\u00e9om\u00e9trie GeOXygene3D de la forme, utile pour la v\u00e9rification de r\u00e8gles ou pour l'export des donn\u00e9es. D\u00e9finition d'une classe de constructeur \uf0c1 Il s'agit de la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.builder.LBuildingWithRoofBuilder qui \u00e9tend la classe de la librjmcmc4j fr.ign.mpp.kernelObjectBuilder cela implique l'impl\u00e9mentation de 3 m\u00e9thodes : T build(double[] val); : instance un objet de la classe param\u00e9tr\u00e9e (ici LBuildingWithRoof) \u00e0 partir d'un tableau de valeurs de double ; void setCoordinates(T t, double[] val); : affecte les coordonn\u00e9es d'un tableau de doubles \u00e0 un objet de la classe param\u00e9tr\u00e9e ; int size(); : la dimension de la taille des objets construits par le constructeur (ici 10). D\u00e9finition de l'optimiseur \uf0c1 L'optimiseur est d\u00e9fini dans la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.optimizer. OptimisedLShapeDirectRejection dans le projet SimPLU3D. L'\u00e9tape peut sembler complexe car le code de la classe est tr\u00e8s long, n\u00e9anmoins, comme presque toutes les m\u00e9thodes \u00e0 d\u00e9finir sont les m\u00eames que celles utilis\u00e9e pour simuler des formes compos\u00e9es de bo\u00eetes ( fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.cuboid.OptimisedBuildingsCuboidFinalDirectRejection ) mais param\u00e9tr\u00e9es avec la classe LBuildingWithRoof . La seule m\u00e9thode significativement diff\u00e9rente est create_sampler qui cr\u00e9\u00e9 l'\u00e9chantillonneur de b\u00e2timents en L. L'impl\u00e9mentation de cette m\u00e9thode est similaire \u00e0 celle des bo\u00eetes avec la d\u00e9finition des intervalles de tirage, du constructeur d'objets et des noyaux de modification. Le code de cette m\u00e9thode est repris et comment\u00e9 ci-dessous : /** * * @param rng a random generator * @param p a json parameter files * @param bpU a basic property unit * @param pred a predicate to check the rules * @param polygon a polygon that contains al the cuboid * @return a sampler for the optimization process */ public Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> create_sampler( RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU, ConfigurationModificationPredicate<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred, IGeometry polygon) { // On cr\u00e9\u00e9 les bornes min et max pour le sampler (10 param\u00e8tres dans le // cas du LBuildingWithRoof) IEnvelope env = polygon.envelope(); double xmin = env.getLowerCorner().getX(); double xmax = env.getUpperCorner().getX(); double ymin = env.getLowerCorner().getY(); double ymax = env.getUpperCorner().getY(); double l1min = p.getDouble(\"l1min\"); double l1max = p.getDouble(\"l1max\"); double l2min = p.getDouble(\"l2min\"); double l2max = p.getDouble(\"l2max\"); double h1min = p.getDouble(\"h1min\"); double h1max = p.getDouble(\"h1max\"); double h2min = p.getDouble(\"h2min\"); double h2max = p.getDouble(\"h2max\"); double heightToTopMin = p.getDouble(\"heightToTopMin\"); double heightToTopgMax = p.getDouble(\"heightToTopgMax\"); double orientationMin = 0; double orientationMax = Math.PI; double heightgutterMin = p.getDouble(\"heightgutterMin\"); ; double heightguterrMax = p.getDouble(\"heightgutterMax\"); ; double shiftMin = 0; double shiftMax = 1; // A priori on red\u00e9fini le constructeur de l'objet // A priori on red\u00e9fini le constructeur de l'objet LBuildingWithRoofBuilder builder = new LBuildingWithRoofBuilder(); // On initialise la surface sur laquelle on fait la simulation if (samplingSurface == null) { samplingSurface = bpU.getPol2D(); } // On initialise l'espace sur lequel on va calculer les objets // (normalement tu as juste \u00e0 changer le nom des classes) UniformBirth<LBuildingWithRoof> birth = new UniformBirth<LBuildingWithRoof>(rng, new LBuildingWithRoof(xmin, ymin, l1min, l2min, h1min, h2min, heightToTopMin, orientationMin, heightgutterMin, shiftMin), new LBuildingWithRoof(xmax, ymax, l1max, l2max, h1max, h2max, heightToTopgMax, orientationMax, heightguterrMax, shiftMax), builder, TransformToSurface.class, (IGeometry) polygon); // La distribution de poisson qui drive le nombre total d'objets PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\")); // Le sampler qui d\u00e9termine comment on tire al\u00e9atoirement un objet dans // l'espace d\u00e9fini DirectSampler<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> ds = new DirectRejectionSampler<>( distribution, birth, pred); // Probabilit\u00e9 de naissance-morts modifications List<Kernel<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>>> kernels = new ArrayList<>( 3); KernelFactory<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> factory = new KernelFactory<>(); // On liste les kernels, pour le premier, tu devrais probablement le // d\u00e9finir toi .... kernels.add( factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\")); double amplitudeMove = p.getDouble(\"amplitudeMove\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveLShapeBuilding(amplitudeMove), 0.2, \"Move\")); // Pour les autres, le ChangeValue peut \u00eatre utiliser (attention, le // deuxi\u00e8me arguement est la taille de ton builder +1) // car il utilise un tableau pour stocker les param\u00e8tres et le +1 est // pour stocker de mani\u00e8re temporaire le tirage al\u00e9atoire double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 2), 0.2, \"h1Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 3), 0.2, \"h2Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 4), 0.2, \"l1Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 5), 0.2, \"l2Change\")); double amplitudeHeight = p.getDouble(\"amplitudeHeight\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeHeight, builder.size() + 1, 6), 0.2, \"heightChange\")); double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180; kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeRotate, builder.size() + 1, 7), 0.2, \"Rotate\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeHeight, builder.size() + 1, 8), 0.2, \"changeHeightGutter\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(0.1, builder.size() + 1, 9), 0.2, \"changeShift\")); // On instancie le sampler avec tous les objets. Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> s = new GreenSamplerBlockTemperature<>( rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels); return s; } Impl\u00e9mentation de l'ex\u00e9cution \uf0c1 Le code ex\u00e9cut\u00e9 se trouve dans la classe fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection du projet SimPLU3D-tutoriel. Les diff\u00e9rences par rapport \u00e0 la simulation basique de formes compos\u00e9es de bo\u00eetes sont : - l'utilisation du nouvel optimiseur ; - la prise en compte d'un autre fichier de configurations, le b\u00e2timent en L ayant besoin de la d\u00e9finition de plus d'intervalles de valeurs ; - un code sp\u00e9cifique pour \u00e9crire les sorties des formes. On peut noter que le v\u00e9rificateur de r\u00e8gles utilis\u00e9 est le m\u00eame que pour la simulation de formes compos\u00e9es de bo\u00eetes et qu'il n'est pas n\u00e9cessaire de le d\u00e9finir gr\u00e2ce aux interfaces impl\u00e9ment\u00e9es. // Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environment using the repository that // contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM(new File( BasicParametricShapeSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); // Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 0; // Distance to bottom of the parcel double distReculFond = 0; // Distance to lateral parcel limits double distReculLat = 0; // Distance between two buildings of a parcel double distanceInterBati = 3; // Maximal ratio built area double maximalCES = 1; // Instanciation of a predicate class // Same as in the first sample fr.ign.simplu3d.firstSimulation.BasicSimulator // As LBuildingWithRoof and Cuboid extends ISimPLU3DPrimitive SamplePredicate<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); // Step 3 : Defining the sampler that will be applied during the simulation // Instantiation of the sampler OptimisedLShapeDirectRejection optimisedLShapedSampler = new OptimisedLShapeDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicParametricShapeSimulator.class.getClassLoader() .getResource(\"firstSimulation/scenario/\").getPath(); // We use a specific scenario dedicated to LShape String fileName = \"paramsLShape.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<? extends ISimPLU3DPrimitive> cc = optimisedLShapedSampler.process(bPU, p, env, bPU.getId(), pred, bPU.getGeom()); // 4 - Writing the output IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>(); for (GraphVertex<? extends ISimPLU3DPrimitive> v : cc.getGraph().vertexSet()) { IFeature feat = new DefaultFeature(v.getValue().generated3DGeom()); // On ajoute des attributs aux entit\u00e9s (dimension des objets) AttributeManager.addAttribute(feat, \"Info\", v.getValue().toString(), \"Double\"); iFeatC.add(feat); } // Writng the shapefile from the collection ShapefileWriter.write(iFeatC, outputFolder + \"out.shp\");","title":"Personnaliser les formes utilis\u00e9es"},{"location":"generator/custom-shape/#generation-de-batiments-en-l","text":"L'objectif de cette partie est de pr\u00e9senter un code permettant de g\u00e9n\u00e9rer des b\u00e2timents en forme de L avec un toit typifi\u00e9 et de d\u00e9crire les \u00e9tapes \u00e0 suivre pour g\u00e9n\u00e9rer des configurations avec d'autres types de forme \u00e0 partir du simulateur basique pr\u00e9sent\u00e9 dans la premi\u00e8re exp\u00e9rimentation .","title":"G\u00e9n\u00e9ration de b\u00e2timents en L"},{"location":"generator/custom-shape/#code-exemple","text":"L'ex\u00e9cution du code pr\u00e9sent\u00e9 ici se trouve dans la classe fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection du projet SimPLU3D-tutorial. La classe de g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e (pr\u00e9sent\u00e9e dans le sch\u00e9ma pr\u00e9c\u00e9dent) comporte 10 dimensions : x : coordonn\u00e9e x du centre de la forme ; y : coordonn\u00e9e y du centre de la forme ; l1 : longueur de la forme hors barre du L ; l2 : longueur de la barre du L ; h1 : hauteur totale de la forme hors barre du L; h2 : hauteur totale de la barre du L; height : hauteur maximale de la forme ; orientation : orientation (azimut) du L ; hgutter : hauteur \u00e0 la goutti\u00e8re. shift : pente du toit aux extr\u00e9mit\u00e9s du L (entre 0 pas de pente et 1 pente jusqu'au milieu de la forme).","title":"Code exemple"},{"location":"generator/custom-shape/#definition-de-la-classe-representant-la-forme","text":"La classe d\u00e9finissant la g\u00e9om\u00e9trie simul\u00e9e est la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.geometry.impl.LBuildingWithRoof du projet SimPLU3D. Cette classe impl\u00e9mente la classe AbstractSimpleBuilding (comme nous simulons un objet de type b\u00e2timent, comme c'est le cas pour la classe Cubboid ). Cela implique l'instanciation de 3 niveaux de classes abstraites et d'interfaces : - la classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.impl.AbstractSimpleBuilding de SimPLU3D-rules : qui contient les informations n\u00e9cessaires pour mod\u00e9liser un objet de type b\u00e2timent de SimPLU3D ; - l'interface fr.ign.cogit.simplu3d.rjmcmc.generic.objectISimPLU3DPrimitive : qui contient les m\u00e9thodes propres \u00e0 SimPLU3D concernant l'optimisation de forme ; - l'interface de la librjmcmc4j fr.ign.geometry.Primitive : qui contient les informations n\u00e9cessaires pour simuler des objets g\u00e9ographiques avec la librjmcmc4j. Seule l'impl\u00e9mentation de la derni\u00e8re interface est n\u00e9cessaire pour g\u00e9n\u00e9rer des formes, les deux autres niveaux enrichissent les m\u00e9thodes accessibles pour la v\u00e9rification des r\u00e8gles et la d\u00e9finition de la fonction d'optimisation. Elles facilitent \u00e9galement la r\u00e9-utilisation du code de la premi\u00e8re simulation. L'impl\u00e9mentation de l'interface Primitive n\u00e9cessite la d\u00e9finition des m\u00e9thodes suivantes : int size(); : renvoie la taille de la dimension de la forme (ici 10 pour le b\u00e2timent en L) ; double[] toArray() : traduit les attributs de la classe en un tableau de double (il s'agit ici d'un tableau de dimension 10 contenant les valeurs des diff\u00e9rentes dimensions de la forme) ; Object[] getArray(); : m\u00eame m\u00e9thode que pr\u00e9c\u00e9demment, mais avec des valeurs sous forme d'objets ; void set(List list); : affecte aux attributs de la classe les valeurs provenant d'un tableau de double (ici une liste de 10 chiffres qui correspondent aux 10 dimensions de la classe) ; double intersectionArea(Primitive p); : \u00e9value la surface de l'intersection 2D avec une autre primitive (ici avec d'autres b\u00e2timents en L) ; Geometry toGeometry(); : convertit la forme en g\u00e9om\u00e9trie 2D JTS (ici l'emprise 2D du b\u00e2timent, la conversion JTS permet d'optimiser les temps de calcul par rapport \u00e0 l'utilisation de g\u00e9om\u00e9tries GeOxygene) ; double getArea(); : l'aire 2D de l'emprise de la forme. La classe LBuildingWithRoof impl\u00e9mente cette interface \u00e0 travers la classe AbstractSimpleBuilding . Elle impl\u00e9mente \u00e9galement l'interface fr.ign.cogit.simplu3d.rjmcmc.generic.object.ISimPLU3DPrimitive qui est n\u00e9cessaire pour pouvoir appliquer le v\u00e9rificateur de forme. Cela n\u00e9cessite l'impl\u00e9mentation de trois m\u00e9thodes : double getHeight(); : la hauteur maximale de la forme ; double getVolume(); : le volume de la forme ; IGeometry generated3DGeom(); renvoie une g\u00e9om\u00e9trie GeOXygene3D de la forme, utile pour la v\u00e9rification de r\u00e8gles ou pour l'export des donn\u00e9es.","title":"D\u00e9finition de la classe repr\u00e9sentant la forme"},{"location":"generator/custom-shape/#definition-dune-classe-de-constructeur","text":"Il s'agit de la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.builder.LBuildingWithRoofBuilder qui \u00e9tend la classe de la librjmcmc4j fr.ign.mpp.kernelObjectBuilder cela implique l'impl\u00e9mentation de 3 m\u00e9thodes : T build(double[] val); : instance un objet de la classe param\u00e9tr\u00e9e (ici LBuildingWithRoof) \u00e0 partir d'un tableau de valeurs de double ; void setCoordinates(T t, double[] val); : affecte les coordonn\u00e9es d'un tableau de doubles \u00e0 un objet de la classe param\u00e9tr\u00e9e ; int size(); : la dimension de la taille des objets construits par le constructeur (ici 10).","title":"D\u00e9finition d'une classe de constructeur"},{"location":"generator/custom-shape/#definition-de-loptimiseur","text":"L'optimiseur est d\u00e9fini dans la classe fr.ign.cogit.simplu3d.rjmcmc.paramshp.optimizer. OptimisedLShapeDirectRejection dans le projet SimPLU3D. L'\u00e9tape peut sembler complexe car le code de la classe est tr\u00e8s long, n\u00e9anmoins, comme presque toutes les m\u00e9thodes \u00e0 d\u00e9finir sont les m\u00eames que celles utilis\u00e9e pour simuler des formes compos\u00e9es de bo\u00eetes ( fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.cuboid.OptimisedBuildingsCuboidFinalDirectRejection ) mais param\u00e9tr\u00e9es avec la classe LBuildingWithRoof . La seule m\u00e9thode significativement diff\u00e9rente est create_sampler qui cr\u00e9\u00e9 l'\u00e9chantillonneur de b\u00e2timents en L. L'impl\u00e9mentation de cette m\u00e9thode est similaire \u00e0 celle des bo\u00eetes avec la d\u00e9finition des intervalles de tirage, du constructeur d'objets et des noyaux de modification. Le code de cette m\u00e9thode est repris et comment\u00e9 ci-dessous : /** * * @param rng a random generator * @param p a json parameter files * @param bpU a basic property unit * @param pred a predicate to check the rules * @param polygon a polygon that contains al the cuboid * @return a sampler for the optimization process */ public Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> create_sampler( RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU, ConfigurationModificationPredicate<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred, IGeometry polygon) { // On cr\u00e9\u00e9 les bornes min et max pour le sampler (10 param\u00e8tres dans le // cas du LBuildingWithRoof) IEnvelope env = polygon.envelope(); double xmin = env.getLowerCorner().getX(); double xmax = env.getUpperCorner().getX(); double ymin = env.getLowerCorner().getY(); double ymax = env.getUpperCorner().getY(); double l1min = p.getDouble(\"l1min\"); double l1max = p.getDouble(\"l1max\"); double l2min = p.getDouble(\"l2min\"); double l2max = p.getDouble(\"l2max\"); double h1min = p.getDouble(\"h1min\"); double h1max = p.getDouble(\"h1max\"); double h2min = p.getDouble(\"h2min\"); double h2max = p.getDouble(\"h2max\"); double heightToTopMin = p.getDouble(\"heightToTopMin\"); double heightToTopgMax = p.getDouble(\"heightToTopgMax\"); double orientationMin = 0; double orientationMax = Math.PI; double heightgutterMin = p.getDouble(\"heightgutterMin\"); ; double heightguterrMax = p.getDouble(\"heightgutterMax\"); ; double shiftMin = 0; double shiftMax = 1; // A priori on red\u00e9fini le constructeur de l'objet // A priori on red\u00e9fini le constructeur de l'objet LBuildingWithRoofBuilder builder = new LBuildingWithRoofBuilder(); // On initialise la surface sur laquelle on fait la simulation if (samplingSurface == null) { samplingSurface = bpU.getPol2D(); } // On initialise l'espace sur lequel on va calculer les objets // (normalement tu as juste \u00e0 changer le nom des classes) UniformBirth<LBuildingWithRoof> birth = new UniformBirth<LBuildingWithRoof>(rng, new LBuildingWithRoof(xmin, ymin, l1min, l2min, h1min, h2min, heightToTopMin, orientationMin, heightgutterMin, shiftMin), new LBuildingWithRoof(xmax, ymax, l1max, l2max, h1max, h2max, heightToTopgMax, orientationMax, heightguterrMax, shiftMax), builder, TransformToSurface.class, (IGeometry) polygon); // La distribution de poisson qui drive le nombre total d'objets PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(\"poisson\")); // Le sampler qui d\u00e9termine comment on tire al\u00e9atoirement un objet dans // l'espace d\u00e9fini DirectSampler<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> ds = new DirectRejectionSampler<>( distribution, birth, pred); // Probabilit\u00e9 de naissance-morts modifications List<Kernel<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>>> kernels = new ArrayList<>( 3); KernelFactory<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> factory = new KernelFactory<>(); // On liste les kernels, pour le premier, tu devrais probablement le // d\u00e9finir toi .... kernels.add( factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(\"pbirth\"), 1.0, \"BirthDeath\")); double amplitudeMove = p.getDouble(\"amplitudeMove\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveLShapeBuilding(amplitudeMove), 0.2, \"Move\")); // Pour les autres, le ChangeValue peut \u00eatre utiliser (attention, le // deuxi\u00e8me arguement est la taille de ton builder +1) // car il utilise un tableau pour stocker les param\u00e8tres et le +1 est // pour stocker de mani\u00e8re temporaire le tirage al\u00e9atoire double amplitudeMaxDim = p.getDouble(\"amplitudeMaxDim\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 2), 0.2, \"h1Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 3), 0.2, \"h2Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 4), 0.2, \"l1Change\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeMaxDim, builder.size() + 1, 5), 0.2, \"l2Change\")); double amplitudeHeight = p.getDouble(\"amplitudeHeight\"); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeHeight, builder.size() + 1, 6), 0.2, \"heightChange\")); double amplitudeRotate = p.getDouble(\"amplitudeRotate\") * Math.PI / 180; kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeRotate, builder.size() + 1, 7), 0.2, \"Rotate\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(amplitudeHeight, builder.size() + 1, 8), 0.2, \"changeHeightGutter\")); kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(0.1, builder.size() + 1, 9), 0.2, \"changeShift\")); // On instancie le sampler avec tous les objets. Sampler<GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> s = new GreenSamplerBlockTemperature<>( rng, ds, new MetropolisAcceptance<SimpleTemperature>(), kernels); return s; }","title":"D\u00e9finition de l'optimiseur"},{"location":"generator/custom-shape/#implementation-de-lexecution","text":"Le code ex\u00e9cut\u00e9 se trouve dans la classe fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection du projet SimPLU3D-tutoriel. Les diff\u00e9rences par rapport \u00e0 la simulation basique de formes compos\u00e9es de bo\u00eetes sont : - l'utilisation du nouvel optimiseur ; - la prise en compte d'un autre fichier de configurations, le b\u00e2timent en L ayant besoin de la d\u00e9finition de plus d'intervalles de valeurs ; - un code sp\u00e9cifique pour \u00e9crire les sorties des formes. On peut noter que le v\u00e9rificateur de r\u00e8gles utilis\u00e9 est le m\u00eame que pour la simulation de formes compos\u00e9es de bo\u00eetes et qu'il n'est pas n\u00e9cessaire de le d\u00e9finir gr\u00e2ce aux interfaces impl\u00e9ment\u00e9es. // Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environment using the repository that // contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM(new File( BasicParametricShapeSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); // Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 0; // Distance to bottom of the parcel double distReculFond = 0; // Distance to lateral parcel limits double distReculLat = 0; // Distance between two buildings of a parcel double distanceInterBati = 3; // Maximal ratio built area double maximalCES = 1; // Instanciation of a predicate class // Same as in the first sample fr.ign.simplu3d.firstSimulation.BasicSimulator // As LBuildingWithRoof and Cuboid extends ISimPLU3DPrimitive SamplePredicate<LBuildingWithRoof, GraphConfiguration<LBuildingWithRoof>, BirthDeathModification<LBuildingWithRoof>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); // Step 3 : Defining the sampler that will be applied during the simulation // Instantiation of the sampler OptimisedLShapeDirectRejection optimisedLShapedSampler = new OptimisedLShapeDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicParametricShapeSimulator.class.getClassLoader() .getResource(\"firstSimulation/scenario/\").getPath(); // We use a specific scenario dedicated to LShape String fileName = \"paramsLShape.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<? extends ISimPLU3DPrimitive> cc = optimisedLShapedSampler.process(bPU, p, env, bPU.getId(), pred, bPU.getGeom()); // 4 - Writing the output IFeatureCollection<IFeature> iFeatC = new FT_FeatureCollection<>(); for (GraphVertex<? extends ISimPLU3DPrimitive> v : cc.getGraph().vertexSet()) { IFeature feat = new DefaultFeature(v.getValue().generated3DGeom()); // On ajoute des attributs aux entit\u00e9s (dimension des objets) AttributeManager.addAttribute(feat, \"Info\", v.getValue().toString(), \"Double\"); iFeatC.add(feat); } // Writng the shapefile from the collection ShapefileWriter.write(iFeatC, outputFolder + \"out.shp\");","title":"Impl\u00e9mentation de l'ex\u00e9cution"},{"location":"generator/intro/","text":"Introduction au g\u00e9n\u00e9rateur de formes \uf0c1 L'objectif de cette section est de d\u00e9crire le code de g\u00e9n\u00e9ration de formes b\u00e2ties. La g\u00e9n\u00e9ration de formes b\u00e2ties se base sur une m\u00e9thode d'optimisation du recuit-simul\u00e9 transdimensionnel (en utilisant la biblioth\u00e8que librjmcmc4j ). Les codes qui permettent la g\u00e9n\u00e9ration de formes se trouvent dans le projet SimPLU3D et la javadoc est d\u00e9ploy\u00e9e \u00e0 l'adresse suivante : https://SimPLU3D.github.io/simplu3D/ . Le package principal ( fr.ign.cogit.simplu3d.rjmcmc ) de SimPLU3D est compos\u00e9 de sous-packages en fonction des types de formes utilis\u00e9es ( generic pour toutes les formes, cuboid pour les bo\u00eetes, paramShp pour des formes param\u00e9triques et trapezoid pour les trapezes). Dans cette section, nous pr\u00e9senterons tout d'abord la m\u00e9thode de g\u00e9n\u00e9ration des formes b\u00e2ties , puis comment il est possible de : Param\u00e9trer l'algorithme pour la g\u00e9n\u00e9ration de formes compos\u00e9es de bo\u00eetes ; Modifier la fonction d'optimisation ; G\u00e9n\u00e9rer des formes b\u00e2ties compos\u00e9es de g\u00e9om\u00e9tries autres que des bo\u00eetes .","title":"Introduction"},{"location":"generator/intro/#introduction-au-generateur-de-formes","text":"L'objectif de cette section est de d\u00e9crire le code de g\u00e9n\u00e9ration de formes b\u00e2ties. La g\u00e9n\u00e9ration de formes b\u00e2ties se base sur une m\u00e9thode d'optimisation du recuit-simul\u00e9 transdimensionnel (en utilisant la biblioth\u00e8que librjmcmc4j ). Les codes qui permettent la g\u00e9n\u00e9ration de formes se trouvent dans le projet SimPLU3D et la javadoc est d\u00e9ploy\u00e9e \u00e0 l'adresse suivante : https://SimPLU3D.github.io/simplu3D/ . Le package principal ( fr.ign.cogit.simplu3d.rjmcmc ) de SimPLU3D est compos\u00e9 de sous-packages en fonction des types de formes utilis\u00e9es ( generic pour toutes les formes, cuboid pour les bo\u00eetes, paramShp pour des formes param\u00e9triques et trapezoid pour les trapezes). Dans cette section, nous pr\u00e9senterons tout d'abord la m\u00e9thode de g\u00e9n\u00e9ration des formes b\u00e2ties , puis comment il est possible de : Param\u00e9trer l'algorithme pour la g\u00e9n\u00e9ration de formes compos\u00e9es de bo\u00eetes ; Modifier la fonction d'optimisation ; G\u00e9n\u00e9rer des formes b\u00e2ties compos\u00e9es de g\u00e9om\u00e9tries autres que des bo\u00eetes .","title":"Introduction au g\u00e9n\u00e9rateur de formes"},{"location":"generator/principe/","text":"Principe du fonctionnement du g\u00e9n\u00e9rateur de formes \uf0c1 Dans cette partie nous introduirons les diff\u00e9rents aspects concernant la g\u00e9n\u00e9ration de formes dans SimPLU3D et la mani\u00e8re avec laquelle l'algorithme du recuit-simul\u00e9 est utilis\u00e9. Configuration b\u00e2tie \uf0c1 Dans SimPLU3D, une configuration b\u00e2tie est compos\u00e9e d'un ensemble de g\u00e9om\u00e9tries param\u00e9triques. Une g\u00e9om\u00e9trie est dite param\u00e9trique quand on peut la d\u00e9crire \u00e0 travers un vecteur de dimension constante. Dans la plupart des exp\u00e9rimentations de SimPLU3D, comme dans l'exemple de la premi\u00e8re simulation, les g\u00e9om\u00e9tries param\u00e9triques manipul\u00e9es sont des bo\u00eetes. Dans ce cas, s'agit d'une g\u00e9om\u00e9trie de 6 dimensions d\u00e9crite par le vecteur b = ( x , y , l , w , h , \u03b8 ). N\u00e9anmoins, il est tout \u00e0 fait possible d'utiliser d'autres types de g\u00e9om\u00e9tries param\u00e9triques comme nous le verrons dans la section sur la personnalisation des formes g\u00e9n\u00e9r\u00e9es . G\u00e9n\u00e9ration de configurations b\u00e2ties \uf0c1 La g\u00e9n\u00e9ration de formes b\u00e2ties avec SimPLU3D se base sur la technique du recuit-simul\u00e9 transdimensionnel. Le recuit simul\u00e9 est une technique d'optimisation, qui cherche \u00e0 maximiser ou minimiser une quantit\u00e9 , appell\u00e9e objectif . Le fait que l'approche soit transdimensionnelle indique que c'est le syst\u00e8me qui d\u00e9termine le nombre d'objets formant la solution candidate (et donc sa dimension) pour atteindre l'objectif. Ainsi, si on consid\u00e8re une fonction d'optimisation f , comme le volume, le recuit simul\u00e9 d\u00e9termine les n bo\u00eetes et leurs param\u00e8tres qui permettent de produire la configuration b\u00e2tie la plus volumineuse possible. D\u00e9roulement de l'algorithme \uf0c1 \u00c0 chaque it\u00e9ration, on consid\u00e8re une configuration b\u00e2tie courante. Le syst\u00e8me choisit une modification parmi les noyaux de proposition de modification disponibles (dans l'exemple, le noyau d'ajout est s\u00e9lectionn\u00e9 pour ajouter une nouvelle bo\u00eete). Ensuite, une probabilit\u00e9 d'acceptation est d\u00e9termin\u00e9e suivant la th\u00e9orie du recuit simul\u00e9e. Elle prend en compte les scores des configurations avant et apr\u00e8s modification et la temp\u00e9rature courante (il s'agit d'une valeur qui d\u00e9cro\u00eet au fur et \u00e0 mesure des it\u00e9rations). Ainsi, il existe une certaine probabilit\u00e9 pour que cette modification soit rejet\u00e9e (1 - \u03b1(t,s,s\u2019)) et une certaine probabilit\u00e9 pour que la modification soit accept\u00e9e (\u03b1(t,s,s\u2019)). Si la configuration est accept\u00e9e, on s'assure qu'elle respecte les r\u00e8gles morphologiques, si c'est le cas elle remplace la configuration courante sinon la modification est rejet\u00e9e. Impl\u00e9mentation de l'algorithme \uf0c1 L'impl\u00e9mentation de l'algorithme est effectu\u00e9e gr\u00e2ce \u00e0 la biblioth\u00e8que g\u00e9n\u00e9rique et OpenSource librjmcmc4j . Pour en savoir plus, vous pouvez consulter l'article : Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf ) Dans l'exemple de la premi\u00e8re simulation , les \u00e9tapes de l'algorithme, pr\u00e9sent\u00e9s dans le sch\u00e9ma pr\u00e9c\u00e9dent, s'effectue dans la m\u00e9thode process() de la classe OptimisedBuildingsCuboidFinalDirectRejection . L'algorithme peut se d\u00e9composer en 3 phases : \u00c9tape 1 : la d\u00e9finition des configurations b\u00e2ties et des modifications appliqu\u00e9es , ce qui correspond aux bo\u00eetes \"Classe de g\u00e9om\u00e9trie param\u00e9trique\" et \"Noyaux de propositions\" du sch\u00e9ma ; \u00c9tape 2 : la d\u00e9finition des param\u00e8tres de l'algorithme en lui-m\u00eame , c'est \u00e0-dire la fonction d'optimisation et les conditions initiales et d'arr\u00eat ; \u00c9tape 3 : la mise en place de visiteurs , c'est \u00e0 dire d'objets qui produiront des sorties au fur et \u00e0 mesure de la simulation. Ils sont pr\u00e9sent\u00e9s dans une autre section mais n'influent pas sur le processus d'optimisation) ; \u00c9tape 4 : l'ex\u00e9cution de la simulation. /** * Process the generation of the optimization * @param bpu Basic property unit * @param geom The geometry in which the centroid of the * cuboids will be generated * @param p the parameters * @param env the environement * @param id the id of the experiments * @param pred the rules to check * @return a set of cuboid as a graph */ public GraphConfiguration<Cuboid> process(BasicPropertyUnit bpu, IGeometry geom, SimpluParameters p, Environnement env, int id, ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred, List<Visitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> lSupplementaryVisitors) { //Step 1 : // Sampler creation (definition of the class and of the kernel modifications) // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications) Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p, bpu, pred, geom); //Step 2 : Preparation of the optimizer //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur //Initializing the configuration (optimisation function + set of cuboid) //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante GraphConfiguration<Cuboid> conf = null; try { conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu); } catch (Exception e) { e.printStackTrace(); } // Temperature initialization //Initialization de la fonction de la temp\u00e9rature Schedule<SimpleTemperature> sch = create_schedule(p); //The end test condition end = create_end_test(p); //Step 3 : Visitor instanciation //\u00c9tape 3 : Pr\u00e9paration des visiteurs //The visitors initialisation PrepareVisitors<Cuboid> pv = new PrepareVisitors<>(env, lSupplementaryVisitors); CompositeVisitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> mVisitor = pv.prepare(p, id); //Step 4 : Running the optimization process //\u00c9tape 4 : Ex\u00e9cution de l'optimization SimulatedAnnealing.optimize(Random.random(), conf, samp, sch, end, mVisitor); return conf; }","title":"Principe de fonctionnement du g\u00e9n\u00e9rateur"},{"location":"generator/principe/#principe-du-fonctionnement-du-generateur-de-formes","text":"Dans cette partie nous introduirons les diff\u00e9rents aspects concernant la g\u00e9n\u00e9ration de formes dans SimPLU3D et la mani\u00e8re avec laquelle l'algorithme du recuit-simul\u00e9 est utilis\u00e9.","title":"Principe du fonctionnement du g\u00e9n\u00e9rateur de formes"},{"location":"generator/principe/#configuration-batie","text":"Dans SimPLU3D, une configuration b\u00e2tie est compos\u00e9e d'un ensemble de g\u00e9om\u00e9tries param\u00e9triques. Une g\u00e9om\u00e9trie est dite param\u00e9trique quand on peut la d\u00e9crire \u00e0 travers un vecteur de dimension constante. Dans la plupart des exp\u00e9rimentations de SimPLU3D, comme dans l'exemple de la premi\u00e8re simulation, les g\u00e9om\u00e9tries param\u00e9triques manipul\u00e9es sont des bo\u00eetes. Dans ce cas, s'agit d'une g\u00e9om\u00e9trie de 6 dimensions d\u00e9crite par le vecteur b = ( x , y , l , w , h , \u03b8 ). N\u00e9anmoins, il est tout \u00e0 fait possible d'utiliser d'autres types de g\u00e9om\u00e9tries param\u00e9triques comme nous le verrons dans la section sur la personnalisation des formes g\u00e9n\u00e9r\u00e9es .","title":"Configuration b\u00e2tie"},{"location":"generator/principe/#generation-de-configurations-baties","text":"La g\u00e9n\u00e9ration de formes b\u00e2ties avec SimPLU3D se base sur la technique du recuit-simul\u00e9 transdimensionnel. Le recuit simul\u00e9 est une technique d'optimisation, qui cherche \u00e0 maximiser ou minimiser une quantit\u00e9 , appell\u00e9e objectif . Le fait que l'approche soit transdimensionnelle indique que c'est le syst\u00e8me qui d\u00e9termine le nombre d'objets formant la solution candidate (et donc sa dimension) pour atteindre l'objectif. Ainsi, si on consid\u00e8re une fonction d'optimisation f , comme le volume, le recuit simul\u00e9 d\u00e9termine les n bo\u00eetes et leurs param\u00e8tres qui permettent de produire la configuration b\u00e2tie la plus volumineuse possible.","title":"G\u00e9n\u00e9ration de configurations b\u00e2ties"},{"location":"generator/principe/#deroulement-de-lalgorithme","text":"\u00c0 chaque it\u00e9ration, on consid\u00e8re une configuration b\u00e2tie courante. Le syst\u00e8me choisit une modification parmi les noyaux de proposition de modification disponibles (dans l'exemple, le noyau d'ajout est s\u00e9lectionn\u00e9 pour ajouter une nouvelle bo\u00eete). Ensuite, une probabilit\u00e9 d'acceptation est d\u00e9termin\u00e9e suivant la th\u00e9orie du recuit simul\u00e9e. Elle prend en compte les scores des configurations avant et apr\u00e8s modification et la temp\u00e9rature courante (il s'agit d'une valeur qui d\u00e9cro\u00eet au fur et \u00e0 mesure des it\u00e9rations). Ainsi, il existe une certaine probabilit\u00e9 pour que cette modification soit rejet\u00e9e (1 - \u03b1(t,s,s\u2019)) et une certaine probabilit\u00e9 pour que la modification soit accept\u00e9e (\u03b1(t,s,s\u2019)). Si la configuration est accept\u00e9e, on s'assure qu'elle respecte les r\u00e8gles morphologiques, si c'est le cas elle remplace la configuration courante sinon la modification est rejet\u00e9e.","title":"D\u00e9roulement de l'algorithme"},{"location":"generator/principe/#implementation-de-lalgorithme","text":"L'impl\u00e9mentation de l'algorithme est effectu\u00e9e gr\u00e2ce \u00e0 la biblioth\u00e8que g\u00e9n\u00e9rique et OpenSource librjmcmc4j . Pour en savoir plus, vous pouvez consulter l'article : Br\u00e9dif, M., Tournaire, O. , Aug. 2012. librjmcmc: An open-source generic c++ library for stochastic optimization. In: The XXII Congress of the International Society of Photogrammetry and Remote Sensing. ( https://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XXXIX-B3/259/2012/isprsarchives-XXXIX-B3-259-2012.pdf ) Dans l'exemple de la premi\u00e8re simulation , les \u00e9tapes de l'algorithme, pr\u00e9sent\u00e9s dans le sch\u00e9ma pr\u00e9c\u00e9dent, s'effectue dans la m\u00e9thode process() de la classe OptimisedBuildingsCuboidFinalDirectRejection . L'algorithme peut se d\u00e9composer en 3 phases : \u00c9tape 1 : la d\u00e9finition des configurations b\u00e2ties et des modifications appliqu\u00e9es , ce qui correspond aux bo\u00eetes \"Classe de g\u00e9om\u00e9trie param\u00e9trique\" et \"Noyaux de propositions\" du sch\u00e9ma ; \u00c9tape 2 : la d\u00e9finition des param\u00e8tres de l'algorithme en lui-m\u00eame , c'est \u00e0-dire la fonction d'optimisation et les conditions initiales et d'arr\u00eat ; \u00c9tape 3 : la mise en place de visiteurs , c'est \u00e0 dire d'objets qui produiront des sorties au fur et \u00e0 mesure de la simulation. Ils sont pr\u00e9sent\u00e9s dans une autre section mais n'influent pas sur le processus d'optimisation) ; \u00c9tape 4 : l'ex\u00e9cution de la simulation. /** * Process the generation of the optimization * @param bpu Basic property unit * @param geom The geometry in which the centroid of the * cuboids will be generated * @param p the parameters * @param env the environement * @param id the id of the experiments * @param pred the rules to check * @return a set of cuboid as a graph */ public GraphConfiguration<Cuboid> process(BasicPropertyUnit bpu, IGeometry geom, SimpluParameters p, Environnement env, int id, ConfigurationModificationPredicate<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred, List<Visitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>>> lSupplementaryVisitors) { //Step 1 : // Sampler creation (definition of the class and of the kernel modifications) // Cr\u00e9ation de l'\u00e9chantilloneeur (d\u00e9finition de la classe et des noyaux de modifications) Sampler<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> samp = create_sampler(Random.random(), p, bpu, pred, geom); //Step 2 : Preparation of the optimizer //\u00c9tape 2 : Pr\u00e9paration de l'optimiseur //Initializing the configuration (optimisation function + set of cuboid) //Initizialization de la configuration (fonction d'optimisation + stock les cuboids de la configuration courante GraphConfiguration<Cuboid> conf = null; try { conf = create_configuration(p, AdapterFactory.toGeometry(new GeometryFactory(), bpu.getGeom()), bpu); } catch (Exception e) { e.printStackTrace(); } // Temperature initialization //Initialization de la fonction de la temp\u00e9rature Schedule<SimpleTemperature> sch = create_schedule(p); //The end test condition end = create_end_test(p); //Step 3 : Visitor instanciation //\u00c9tape 3 : Pr\u00e9paration des visiteurs //The visitors initialisation PrepareVisitors<Cuboid> pv = new PrepareVisitors<>(env, lSupplementaryVisitors); CompositeVisitor<GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> mVisitor = pv.prepare(p, id); //Step 4 : Running the optimization process //\u00c9tape 4 : Ex\u00e9cution de l'optimization SimulatedAnnealing.optimize(Random.random(), conf, samp, sch, end, mVisitor); return conf; }","title":"Impl\u00e9mentation de l'algorithme"},{"location":"openmole/intro/","text":"Introduction au couplage SimPLU3D - OpenMOLE \uf0c1 OpenMOLE (https://openmole.org/) est une plate-forme d\u00e9di\u00e9e \u00e0 l'exploration de mod\u00e8les de simulation. Cette plate-forme permet \u00e0 travers la distribution de calculs de calibrer ou d'explorer de mani\u00e8re efficace l'espace de param\u00e8tres de mod\u00e8les. Ce couplage a \u00e9t\u00e9 utilis\u00e9 pour deux exp\u00e9rimentations : la production des simulations sur de grandes zones et pour la simulation de l'influence de param\u00e8tres de r\u00e8gles sur des formes b\u00e2ties. Ces aspects sont pr\u00e9sent\u00e9s dans l'article suivant : Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017) Cr\u00e9ation d'un plug-in OpenMOLE. \uf0c1 Pour utiliser conjointement les deux projets, il est conseill\u00e9 de cr\u00e9er un plug-in OpenMOLE . Les diff\u00e9rents couplages d\u00e9j\u00e0 effectu\u00e9s se trouvent dans le projet SimPLU3D-OpenMole . Dans la suite, nous d\u00e9crivons les \u00e9tapes n\u00e9cessaires \u00e0 la production d'un tel plug-in. Ce plug-in utilisera un simulateur programm\u00e9 en Java. Afin que le plugin puisse \u00eatre fonctionnel, il est recommand\u00e9 d'initialiser les factories de la biblioth\u00e8que GeoTools, en ex\u00e9cutant, par exemple, le code d\u00e9di\u00e9 du projet SimPLU3D fr.ign.cogit.simplu3d.util.distribution.Initialize.init() au tout d\u00e9but du code Java. 1 Cr\u00e9ation du projet Scala \uf0c1 Le plus simple pour cr\u00e9er le projet Scala est de re-partir d'un exemple existant, en t\u00e9l\u00e9chargeant par exemple, le projet SimPLU3D-OpenMole . L'organisation du projet est classique, il y a un fichier build.sbt qui d\u00e9crit la mani\u00e8re avec laquelle le projet est construit. Dans celui-l\u00e0, il est d\u00e9j\u00e0 sp\u00e9cifi\u00e9 que l'on cherche \u00e0 compiler un projet OSGI (mani\u00e8re de compiler un plugin OpenMOLE). Pour pouvoir utiliser SimPLU3D depuis ce projet, il faut le sp\u00e9cifier dans les d\u00e9pendances, cela se fait en d\u00e9finissant les resolvers (c'est \u00e0 dire le d\u00e9p\u00f4t dans lequel on peut trouver le .jar contenant le code) : resolvers += Resolver.mavenLocal resolvers += \"IGN snapshots\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/\" resolvers += \"IGN releases\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/releases/\" et en sp\u00e9cifiant les d\u00e9pendances \u00e0 utiliser : libraryDependencies += \"fr.ign.cogit\" %% \"simplu3d\" % \"1.2-SNAPSHOT\" 2 Cr\u00e9ation du code Scala \u00e0 ex\u00e9cuter \uf0c1 Il est tout d'abord n\u00e9cessaire de pr\u00e9parer la t\u00e2che \u00e0 ex\u00e9cuter en Java ou en Scala. Afin de pouvoir faciliter la distribution en ce qui concerne la gestion des fichiers envoy\u00e9s et re\u00e7us pendant la distribution, nous conseillons au possible que le code ait la m\u00eame signature que dans la m\u00e9thode suivante (+ d'autres arguments) package simplu3dopenmoleplugin import java.io.File import fr.ign.cogit.simplu3d.experiments.openmole._ object DistribTask { def apply(folderIn: File, folderOut: File, paramFile: File, seed: Long): (Boolean, File) = { val res = IAUIDFTask.run(folderIn, folderOut, paramFile, seed); (res, folderOut) } } Ce qui est utile pour la suite est : 1/ de bien se rappeler du package Scala (mot clef package ) et de l'objet (mot clef object ) ; 2/ qu'il faut d\u00e9finir une m\u00e9thode apply qui prend en entr\u00e9e les param\u00e8tres n\u00e9cessaires au fonctionnement de la t\u00e2che et qui indique les sorties (il est possible d'avoir plusieurs objets en sortie avec Scala, il suffit de d\u00e9finir les types en les s\u00e9parant par des , comme ici (Boolean, File) et la sortie est indiqu\u00e9e \u00e0 la fin ( res, folderOut) '. 3 Production du bundle OSGI \uf0c1 A la racine, du projet, l\u00e0 o\u00f9 se trouve le build.sbt , il suffit d'ex\u00e9cuter : sbt osgiBundle -U Un fichier .jar est alors produit dans \"''target/scala''\" 4 D\u00e9finition du plan d'exp\u00e9rimentation et ex\u00e9cution dans OpenMole \uf0c1 Pour faire cela, je vous invite \u00e0 regarder les tutoriels d'OpenMole pour apprendre \u00e0 bien d\u00e9finir un script. Une fois le plugin charg\u00e9, il est possible de l'utiliser dans la d\u00e9finition du workflow comme cela est expliqu\u00e9 en bas de cette page .","title":"Distribuer avec OpenMole"},{"location":"openmole/intro/#introduction-au-couplage-simplu3d-openmole","text":"OpenMOLE (https://openmole.org/) est une plate-forme d\u00e9di\u00e9e \u00e0 l'exploration de mod\u00e8les de simulation. Cette plate-forme permet \u00e0 travers la distribution de calculs de calibrer ou d'explorer de mani\u00e8re efficace l'espace de param\u00e8tres de mod\u00e8les. Ce couplage a \u00e9t\u00e9 utilis\u00e9 pour deux exp\u00e9rimentations : la production des simulations sur de grandes zones et pour la simulation de l'influence de param\u00e8tres de r\u00e8gles sur des formes b\u00e2ties. Ces aspects sont pr\u00e9sent\u00e9s dans l'article suivant : Brasebin, M., P. Chapron, G. Ch\u00e9rel, M. Leclaire, I. Lokhat, J. Perret and R. Reuillon (2017) Apports des m\u00e9thodes d\u2019exploration et de distribution appliqu\u00e9es \u00e0 la simulation des droits \u00e0 b\u00e2tir, Actes du Colloque International de G\u00e9omatique et d'Analyse Spatiale (SAGEO 2017)","title":"Introduction au couplage SimPLU3D - OpenMOLE"},{"location":"openmole/intro/#creation-dun-plug-in-openmole","text":"Pour utiliser conjointement les deux projets, il est conseill\u00e9 de cr\u00e9er un plug-in OpenMOLE . Les diff\u00e9rents couplages d\u00e9j\u00e0 effectu\u00e9s se trouvent dans le projet SimPLU3D-OpenMole . Dans la suite, nous d\u00e9crivons les \u00e9tapes n\u00e9cessaires \u00e0 la production d'un tel plug-in. Ce plug-in utilisera un simulateur programm\u00e9 en Java. Afin que le plugin puisse \u00eatre fonctionnel, il est recommand\u00e9 d'initialiser les factories de la biblioth\u00e8que GeoTools, en ex\u00e9cutant, par exemple, le code d\u00e9di\u00e9 du projet SimPLU3D fr.ign.cogit.simplu3d.util.distribution.Initialize.init() au tout d\u00e9but du code Java.","title":"Cr\u00e9ation d'un plug-in OpenMOLE."},{"location":"openmole/intro/#1-creation-du-projet-scala","text":"Le plus simple pour cr\u00e9er le projet Scala est de re-partir d'un exemple existant, en t\u00e9l\u00e9chargeant par exemple, le projet SimPLU3D-OpenMole . L'organisation du projet est classique, il y a un fichier build.sbt qui d\u00e9crit la mani\u00e8re avec laquelle le projet est construit. Dans celui-l\u00e0, il est d\u00e9j\u00e0 sp\u00e9cifi\u00e9 que l'on cherche \u00e0 compiler un projet OSGI (mani\u00e8re de compiler un plugin OpenMOLE). Pour pouvoir utiliser SimPLU3D depuis ce projet, il faut le sp\u00e9cifier dans les d\u00e9pendances, cela se fait en d\u00e9finissant les resolvers (c'est \u00e0 dire le d\u00e9p\u00f4t dans lequel on peut trouver le .jar contenant le code) : resolvers += Resolver.mavenLocal resolvers += \"IGN snapshots\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/\" resolvers += \"IGN releases\" at \"https://forge-cogit.ign.fr/nexus/content/repositories/releases/\" et en sp\u00e9cifiant les d\u00e9pendances \u00e0 utiliser : libraryDependencies += \"fr.ign.cogit\" %% \"simplu3d\" % \"1.2-SNAPSHOT\"","title":"1 Cr\u00e9ation du projet Scala"},{"location":"openmole/intro/#2-creation-du-code-scala-a-executer","text":"Il est tout d'abord n\u00e9cessaire de pr\u00e9parer la t\u00e2che \u00e0 ex\u00e9cuter en Java ou en Scala. Afin de pouvoir faciliter la distribution en ce qui concerne la gestion des fichiers envoy\u00e9s et re\u00e7us pendant la distribution, nous conseillons au possible que le code ait la m\u00eame signature que dans la m\u00e9thode suivante (+ d'autres arguments) package simplu3dopenmoleplugin import java.io.File import fr.ign.cogit.simplu3d.experiments.openmole._ object DistribTask { def apply(folderIn: File, folderOut: File, paramFile: File, seed: Long): (Boolean, File) = { val res = IAUIDFTask.run(folderIn, folderOut, paramFile, seed); (res, folderOut) } } Ce qui est utile pour la suite est : 1/ de bien se rappeler du package Scala (mot clef package ) et de l'objet (mot clef object ) ; 2/ qu'il faut d\u00e9finir une m\u00e9thode apply qui prend en entr\u00e9e les param\u00e8tres n\u00e9cessaires au fonctionnement de la t\u00e2che et qui indique les sorties (il est possible d'avoir plusieurs objets en sortie avec Scala, il suffit de d\u00e9finir les types en les s\u00e9parant par des , comme ici (Boolean, File) et la sortie est indiqu\u00e9e \u00e0 la fin ( res, folderOut) '.","title":"2 Cr\u00e9ation du code Scala \u00e0 ex\u00e9cuter"},{"location":"openmole/intro/#3-production-du-bundle-osgi","text":"A la racine, du projet, l\u00e0 o\u00f9 se trouve le build.sbt , il suffit d'ex\u00e9cuter : sbt osgiBundle -U Un fichier .jar est alors produit dans \"''target/scala''\"","title":"3 Production du bundle OSGI"},{"location":"openmole/intro/#4-definition-du-plan-dexperimentation-et-execution-dans-openmole","text":"Pour faire cela, je vous invite \u00e0 regarder les tutoriels d'OpenMole pour apprendre \u00e0 bien d\u00e9finir un script. Une fois le plugin charg\u00e9, il est possible de l'utiliser dans la d\u00e9finition du workflow comme cela est expliqu\u00e9 en bas de cette page .","title":"4 D\u00e9finition du plan d'exp\u00e9rimentation et ex\u00e9cution dans OpenMole"},{"location":"principe/intro/","text":"Principe du fonctionnement de SimPLU3D \uf0c1 Le simulateur de base fait ressortir trois composants principaux de SimPLU3D : l'environnement g\u00e9ographique environnement g\u00e9ographique qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , qui d\u00e9termine \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9e par le simulateur et la forme des g\u00e9om\u00e9tries composant des configurations simul\u00e9es ; la d\u00e9finition de contraintes morphologiques , qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique et contraignent la g\u00e9n\u00e9ration des formes b\u00e2ties. Pr\u00e9sentation simple de l'approche \uf0c1 Pendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation et la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le recuit simul\u00e9 ). Dans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.","title":"Principe"},{"location":"principe/intro/#principe-du-fonctionnement-de-simplu3d","text":"Le simulateur de base fait ressortir trois composants principaux de SimPLU3D : l'environnement g\u00e9ographique environnement g\u00e9ographique qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , qui d\u00e9termine \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9e par le simulateur et la forme des g\u00e9om\u00e9tries composant des configurations simul\u00e9es ; la d\u00e9finition de contraintes morphologiques , qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique et contraignent la g\u00e9n\u00e9ration des formes b\u00e2ties.","title":"Principe du fonctionnement de SimPLU3D"},{"location":"principe/intro/#presentation-simple-de-lapproche","text":"Pendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation et la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le recuit simul\u00e9 ). Dans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.","title":"Pr\u00e9sentation simple de l'approche"},{"location":"rules/formats/","text":"Formats de stockage des r\u00e8gles \uf0c1 SimPLU3D ne poss\u00e8de pas de format pour stocker les r\u00e8gles morphologiques. En effet, les diff\u00e9rentes exp\u00e9riences ont montr\u00e9 que suivant les besoins, l'\u00e9chelle d'\u00e9tude et les r\u00e9glementations locales, les r\u00e8gles n\u00e9cessaires \u00e0 mod\u00e9liser pouvaient beaucoup varier. Ainsi, pour rester g\u00e9n\u00e9rique, c'est \u00e0 l'utilisateur de d\u00e9finir comment stocker ces r\u00e8gles et impl\u00e9menter l'interface Predicate en fonction de ces r\u00e8gles. Cependant, dans cette partie nous pr\u00e9senterons d'abord un exemple de code avec une d\u00e9marche conseill\u00e9e pour int\u00e9grer des r\u00e8gles \u00e0 partir d'un tableau. Puis, nous pointerons vers diff\u00e9rentes exp\u00e9rimentations utilisant diff\u00e9rents formats de r\u00e8gles. Int\u00e9gration de r\u00e8gles sous forme d'un tableau \uf0c1 Ici, nous pr\u00e9senterons un exemple pour charger des r\u00e8gles stock\u00e9es dans un fichier .csv et pour appliquer ces r\u00e8gles aux diff\u00e9rentes zones d'un plan de zonage via le SamplerPredicate . Le code est disponible dans la classe fr.ign.simplu3d.simulRules.SimulWithRules du projet SimPLU3D-tutorial . Les donn\u00e9es utilis\u00e9es sont stock\u00e9es dans le dossier resources/simulationWithRules qui contient notamment un fichier rules.csv en plus (mis en tableau ci dessous). La jointure entre les zones urbaines et les valeurs de ce tableau s'effectue via le champ libelle . libelle distReculVoirie distReculFond distReculLat distanceInterBati maximalCES ub1 2 3 4 8 0.5 ub2 4 5 4 8 1 Le r\u00e9sultat de la simulation est visible ci dessous, seules 2 parcelles sont simul\u00e9es (celles avec 1 comme valeur pour l'attribut SIMUL) Code de r\u00e9glementation \uf0c1 Au pr\u00e9alable, une classe de r\u00e9glementation a \u00e9t\u00e9 cr\u00e9\u00e9e ( fr.ign.simplu3d.simulRules.RegulationTuto ). Cette classe impl\u00e9mente l'interface IZoneRegulation qui permet de rattacher une r\u00e9glementation \u00e0 une zone (classe UrbaZone ). Cette interface a d\u00e9j\u00e0 \u00e9t\u00e9 vue dans la section pr\u00e9sentant le mod\u00e8le g\u00e9ographique . Il s'agit d'une simple classe ayant des accesseurs aux diff\u00e9rents param\u00e8tres du r\u00e8glement ainsi qu'\u00e0 son libell\u00e9. Code de simulation \uf0c1 Le code de simulation ressemble \u00e0 celui pr\u00e9sent\u00e9 dans la simulation de base avec quelques modifications. La plus importante diff\u00e9rence concerne la m\u00e9thode readAndAssociateRules qui parse le fichier rules.csv contenant les r\u00e8gles et cr\u00e9\u00e9 le lien entre les diff\u00e9rentes zones urbaines et les instances des diff\u00e9rents r\u00e8glements. public static void readAndAssociateRules(String ruleFile, Environnement env) throws Exception { // Creation of a map to create a link between id regulation and regulation Map<String, RegulationTuto> mapLibelleRegulation = new HashMap<>(); //////////////////// //// READING THE CSV FILE to complete the map //////////////////// BufferedReader in = new BufferedReader(new FileReader(new File(ruleFile))); // The first line is the head in.readLine(); String line = \"\"; // For each line while ((line = in.readLine()) != null) { // We create a new regulation RegulationTuto r = new RegulationTuto(line); // We add it to the map with it is name if (r != null) { mapLibelleRegulation.put(r.getLibelle(), r); } } in.close(); //////////////////// //// ASSOCIATING UrbaZone and regulation //////////////////// for (UrbaZone zone : env.getUrbaZones()) { // We use the libelle to make a join between regulation and zone RegulationTuto regulation = mapLibelleRegulation.get(zone.getLibelle()); // We create the link in the two directions for convenience zone.setZoneRegulation(regulation); if (regulation != null) { regulation.setUrbaZone(zone); } } } On peut \u00e9galement noter par ailleurs l'utilisation de la m\u00e9thode hasToBeSimulated pour ne simuler que les parcelles ayant 1 comme valeur dans le champs simul du fichier contenant les parcelles. if (!currentCadastralParcel.hasToBeSimulated()) { continue; } Dans cet exemple, il n'y a qu'une seule sous-parcelle par parcelle (c'est-\u00e0-dire que chaque parcelle est compl\u00e8tement incluse dans une seule zone urbaine). N\u00e9anmoins, il est possible de consid\u00e9rer plusieurs r\u00e8glements au sein d'une parcelle et d'acc\u00e9der \u00e0 ces r\u00e8glements via les sous-parcelles. Cela n\u00e9cessite dans le pr\u00e9dicat de v\u00e9rifier pour chacun des objets \u00e0 quelle(s) sous-parcelle(s) il appartient et \u00e0 appliquer les v\u00e9rifications en fonction de ces r\u00e8glements. Une seconde complexit\u00e9 est de proposer une m\u00e9thode pour r\u00e9concilier ces diff\u00e9rents r\u00e8glements (Par exemple, comme mesure-t-on une contrainte de distance entre 2 objets qui se trouvent dans 2 zones diff\u00e9rentes ?). Cet aspect est compliqu\u00e9 \u00e0 formaliser, mais un exemple est d\u00e9fini dans la classe MultiplePredicateArtiScales du projet ArtiScales . Autres exemples d'utilisation de fichier de r\u00e8gles \uf0c1 Deux types de formats de r\u00e8gles ont \u00e9t\u00e9 utilis\u00e9s : Format OCL (Object Constraint Language) : le format OCL permet de mod\u00e9liser des contraintes \u00e0 partir d'instances d'un mod\u00e8le. Ainsi, l'utilisation de r\u00e8gles au format OCL permet une grande expressivit\u00e9 comme il peut utiliser et combiner tous les concepts du mod\u00e8le g\u00e9ographique de SimPLU3D. Cependant, cette expressivit\u00e9 a un co\u00fbt car le temps d'\u00e9valuation d'une contrainte formul\u00e9e en OCL est beaucoup plus longue que son \u00e9quivalent programm\u00e9e en Java. Pour en savoir plus, vous pouvez consulter la page Github de SimPLU3D-OCL ; Format CartoPLU+ : le format CartoPLU+ stocke les r\u00e8gles sous format d'un tableau CSV \u00e0 partir d'une s\u00e9lection de contraintes effectu\u00e9e par l' IAUIDF et la DRIEA . Pour en savoir plus, vous pouvez consulter la page Github du projet SimPLU3D-IAUIDF .","title":"Formats de r\u00e8gles"},{"location":"rules/formats/#formats-de-stockage-des-regles","text":"SimPLU3D ne poss\u00e8de pas de format pour stocker les r\u00e8gles morphologiques. En effet, les diff\u00e9rentes exp\u00e9riences ont montr\u00e9 que suivant les besoins, l'\u00e9chelle d'\u00e9tude et les r\u00e9glementations locales, les r\u00e8gles n\u00e9cessaires \u00e0 mod\u00e9liser pouvaient beaucoup varier. Ainsi, pour rester g\u00e9n\u00e9rique, c'est \u00e0 l'utilisateur de d\u00e9finir comment stocker ces r\u00e8gles et impl\u00e9menter l'interface Predicate en fonction de ces r\u00e8gles. Cependant, dans cette partie nous pr\u00e9senterons d'abord un exemple de code avec une d\u00e9marche conseill\u00e9e pour int\u00e9grer des r\u00e8gles \u00e0 partir d'un tableau. Puis, nous pointerons vers diff\u00e9rentes exp\u00e9rimentations utilisant diff\u00e9rents formats de r\u00e8gles.","title":"Formats de stockage des r\u00e8gles"},{"location":"rules/formats/#integration-de-regles-sous-forme-dun-tableau","text":"Ici, nous pr\u00e9senterons un exemple pour charger des r\u00e8gles stock\u00e9es dans un fichier .csv et pour appliquer ces r\u00e8gles aux diff\u00e9rentes zones d'un plan de zonage via le SamplerPredicate . Le code est disponible dans la classe fr.ign.simplu3d.simulRules.SimulWithRules du projet SimPLU3D-tutorial . Les donn\u00e9es utilis\u00e9es sont stock\u00e9es dans le dossier resources/simulationWithRules qui contient notamment un fichier rules.csv en plus (mis en tableau ci dessous). La jointure entre les zones urbaines et les valeurs de ce tableau s'effectue via le champ libelle . libelle distReculVoirie distReculFond distReculLat distanceInterBati maximalCES ub1 2 3 4 8 0.5 ub2 4 5 4 8 1 Le r\u00e9sultat de la simulation est visible ci dessous, seules 2 parcelles sont simul\u00e9es (celles avec 1 comme valeur pour l'attribut SIMUL)","title":"Int\u00e9gration de r\u00e8gles sous forme d'un tableau"},{"location":"rules/formats/#code-de-reglementation","text":"Au pr\u00e9alable, une classe de r\u00e9glementation a \u00e9t\u00e9 cr\u00e9\u00e9e ( fr.ign.simplu3d.simulRules.RegulationTuto ). Cette classe impl\u00e9mente l'interface IZoneRegulation qui permet de rattacher une r\u00e9glementation \u00e0 une zone (classe UrbaZone ). Cette interface a d\u00e9j\u00e0 \u00e9t\u00e9 vue dans la section pr\u00e9sentant le mod\u00e8le g\u00e9ographique . Il s'agit d'une simple classe ayant des accesseurs aux diff\u00e9rents param\u00e8tres du r\u00e8glement ainsi qu'\u00e0 son libell\u00e9.","title":"Code de r\u00e9glementation"},{"location":"rules/formats/#code-de-simulation","text":"Le code de simulation ressemble \u00e0 celui pr\u00e9sent\u00e9 dans la simulation de base avec quelques modifications. La plus importante diff\u00e9rence concerne la m\u00e9thode readAndAssociateRules qui parse le fichier rules.csv contenant les r\u00e8gles et cr\u00e9\u00e9 le lien entre les diff\u00e9rentes zones urbaines et les instances des diff\u00e9rents r\u00e8glements. public static void readAndAssociateRules(String ruleFile, Environnement env) throws Exception { // Creation of a map to create a link between id regulation and regulation Map<String, RegulationTuto> mapLibelleRegulation = new HashMap<>(); //////////////////// //// READING THE CSV FILE to complete the map //////////////////// BufferedReader in = new BufferedReader(new FileReader(new File(ruleFile))); // The first line is the head in.readLine(); String line = \"\"; // For each line while ((line = in.readLine()) != null) { // We create a new regulation RegulationTuto r = new RegulationTuto(line); // We add it to the map with it is name if (r != null) { mapLibelleRegulation.put(r.getLibelle(), r); } } in.close(); //////////////////// //// ASSOCIATING UrbaZone and regulation //////////////////// for (UrbaZone zone : env.getUrbaZones()) { // We use the libelle to make a join between regulation and zone RegulationTuto regulation = mapLibelleRegulation.get(zone.getLibelle()); // We create the link in the two directions for convenience zone.setZoneRegulation(regulation); if (regulation != null) { regulation.setUrbaZone(zone); } } } On peut \u00e9galement noter par ailleurs l'utilisation de la m\u00e9thode hasToBeSimulated pour ne simuler que les parcelles ayant 1 comme valeur dans le champs simul du fichier contenant les parcelles. if (!currentCadastralParcel.hasToBeSimulated()) { continue; } Dans cet exemple, il n'y a qu'une seule sous-parcelle par parcelle (c'est-\u00e0-dire que chaque parcelle est compl\u00e8tement incluse dans une seule zone urbaine). N\u00e9anmoins, il est possible de consid\u00e9rer plusieurs r\u00e8glements au sein d'une parcelle et d'acc\u00e9der \u00e0 ces r\u00e8glements via les sous-parcelles. Cela n\u00e9cessite dans le pr\u00e9dicat de v\u00e9rifier pour chacun des objets \u00e0 quelle(s) sous-parcelle(s) il appartient et \u00e0 appliquer les v\u00e9rifications en fonction de ces r\u00e8glements. Une seconde complexit\u00e9 est de proposer une m\u00e9thode pour r\u00e9concilier ces diff\u00e9rents r\u00e8glements (Par exemple, comme mesure-t-on une contrainte de distance entre 2 objets qui se trouvent dans 2 zones diff\u00e9rentes ?). Cet aspect est compliqu\u00e9 \u00e0 formaliser, mais un exemple est d\u00e9fini dans la classe MultiplePredicateArtiScales du projet ArtiScales .","title":"Code de simulation"},{"location":"rules/formats/#autres-exemples-dutilisation-de-fichier-de-regles","text":"Deux types de formats de r\u00e8gles ont \u00e9t\u00e9 utilis\u00e9s : Format OCL (Object Constraint Language) : le format OCL permet de mod\u00e9liser des contraintes \u00e0 partir d'instances d'un mod\u00e8le. Ainsi, l'utilisation de r\u00e8gles au format OCL permet une grande expressivit\u00e9 comme il peut utiliser et combiner tous les concepts du mod\u00e8le g\u00e9ographique de SimPLU3D. Cependant, cette expressivit\u00e9 a un co\u00fbt car le temps d'\u00e9valuation d'une contrainte formul\u00e9e en OCL est beaucoup plus longue que son \u00e9quivalent programm\u00e9e en Java. Pour en savoir plus, vous pouvez consulter la page Github de SimPLU3D-OCL ; Format CartoPLU+ : le format CartoPLU+ stocke les r\u00e8gles sous format d'un tableau CSV \u00e0 partir d'une s\u00e9lection de contraintes effectu\u00e9e par l' IAUIDF et la DRIEA . Pour en savoir plus, vous pouvez consulter la page Github du projet SimPLU3D-IAUIDF .","title":"Autres exemples d'utilisation de fichier de r\u00e8gles"},{"location":"rules/intro/","text":"Introduction \u00e0 la v\u00e9rification de r\u00e8gles \uf0c1 Dans le cadre du processus de simulation, l'\u00e9tape de v\u00e9rification des r\u00e8gles vise \u00e0 indiquer si le r\u00e9sultat de l'application d'une modification sur une configuration respecte les r\u00e8gles morphologiques d\u00e9finies ou non. Dans une premi\u00e8re partie, nous pr\u00e9sentons comment impl\u00e9menter un v\u00e9rificateur de r\u00e8gles dans SimPLU3D. Comme SimPLU3D effectue de base un tirage al\u00e9atoire dans un espace continu, il peut \u00eatre difficile de faire que certaines r\u00e8gles topologiques (Par exemple, \u00eatre coll\u00e9 contre un b\u00e2timent existant ou une limite s\u00e9parative) soient respect\u00e9es. Une section sera d\u00e9di\u00e9e \u00e0 la d\u00e9finition de telles r\u00e8gles topologiques . Il n'y a actuellement pas de format de r\u00e8gle propre \u00e0 SimPLU3D, comme le simulateur est tr\u00e8s g\u00e9n\u00e9rique et amen\u00e9 \u00e0 traiter des contextes diff\u00e9rents. N\u00e9anmoins, une section est d\u00e9di\u00e9e \u00e0 la pr\u00e9sentation rapide de quelques formats utilis\u00e9s et de pistes pour utiliser d'autres formats de r\u00e8gles .","title":"Introduction"},{"location":"rules/intro/#introduction-a-la-verification-de-regles","text":"Dans le cadre du processus de simulation, l'\u00e9tape de v\u00e9rification des r\u00e8gles vise \u00e0 indiquer si le r\u00e9sultat de l'application d'une modification sur une configuration respecte les r\u00e8gles morphologiques d\u00e9finies ou non. Dans une premi\u00e8re partie, nous pr\u00e9sentons comment impl\u00e9menter un v\u00e9rificateur de r\u00e8gles dans SimPLU3D. Comme SimPLU3D effectue de base un tirage al\u00e9atoire dans un espace continu, il peut \u00eatre difficile de faire que certaines r\u00e8gles topologiques (Par exemple, \u00eatre coll\u00e9 contre un b\u00e2timent existant ou une limite s\u00e9parative) soient respect\u00e9es. Une section sera d\u00e9di\u00e9e \u00e0 la d\u00e9finition de telles r\u00e8gles topologiques . Il n'y a actuellement pas de format de r\u00e8gle propre \u00e0 SimPLU3D, comme le simulateur est tr\u00e8s g\u00e9n\u00e9rique et amen\u00e9 \u00e0 traiter des contextes diff\u00e9rents. N\u00e9anmoins, une section est d\u00e9di\u00e9e \u00e0 la pr\u00e9sentation rapide de quelques formats utilis\u00e9s et de pistes pour utiliser d'autres formats de r\u00e8gles .","title":"Introduction \u00e0 la v\u00e9rification de r\u00e8gles"},{"location":"rules/predicate/","text":"Impl\u00e9mentation de la v\u00e9rification de r\u00e8gles dans SimPLU3D \uf0c1 Pour v\u00e9rifier les r\u00e8gles morphologiques, SimPLU3D utilise le concept de pr\u00e9dicat. Il s'agit d'un objet qui indique si une configuration respecte une r\u00e8gle ou non. Interface de predicat \uf0c1 L'interface de la librjmcmc4j fr.ign.rjmcmc.configuration.ConfigurationModificationPredicate , M extends Modification > impl\u00e9mente cette notion de pr\u00e9dicat et permet la d\u00e9finition \u00e0 elle seule du respect des r\u00e8gles. Cette interface ne d\u00e9finit que la m\u00e9thode boolean check(C c, M m); . Avec : c , une instance de configuration, qui contient la liste des objets de la configuration courante (c'est \u00e0 dire avant application de la modification) ; m , la modification qui serait appliqu\u00e9e \u00e0 la configuration c ; la m\u00e9thode renvoie un boolean qui indique si les r\u00e8gles sont respect\u00e9es suite \u00e0 l'application de la modification m sur la configuration c . Impl\u00e9mentation \u00e0 partir de l'interface de pr\u00e9dicat \uf0c1 Dans SimPLU3D, nous conseillons l'impl\u00e9mentation de cette interface \u00e0 travers la d\u00e9finition suivante (et de regarder la-dite classe qui donne une id\u00e9e de comment impl\u00e9menter la m\u00e9thode) : SamplePredicate<O extends ISimPLU3DPrimitive, C extends AbstractGraphConfiguration<O, C, M>, M extends AbstractBirthDeathModification<O, C, M>> implements ConfigurationModificationPredicate<C, M> Ainsi, \u00e0 travers la classe abstraite AbstractGraphConfiguration , il est possible d'acc\u00e9der \u00e0 la liste des objets de la configuration courante \u00e0 travers un it\u00e9rateur (m\u00e9thode iterator ) et \u00e0 travers la classe AbstractBirthDeathModification d'acc\u00e9der aux modifications \u00e0 travers la cr\u00e9ation m.getBirth() et la destruction d'objets m.getDeath() de la classe utilis\u00e9e pendant la g\u00e9n\u00e9ration. Une modification est vue comme l'ajout et la suppression d'objet. Dans les modifications usuellement utilis\u00e9es dans SimPLU3D, ces listes contiennent soit 0 soit 1 objet. Il suffit ensuite de coder la v\u00e9rification des r\u00e8gles pour les diff\u00e9rents objets de la configuration apr\u00e8s modification en utilisant les informations disponibles dans l' environnement g\u00e9ographique ). Ainsi, pour avoir la liste des objets de la classe O apr\u00e8s modification, on peut utiliser le code suivant : List<O> listOfObjects = new ArrayList<>(); Iterator<O> iTBat = c.iterator(); while ( iTBat.hasNext()) { listOfObjects.add(iTBat.next()); } //La m\u00e9thode equals() doit \u00eatre d\u00e9finie pour la classe O listOfObjects.removeAll(m.getDeath()); listOfObjects.addAll(m.getBirth()); Attention : comme l'\u00e9valuation de la m\u00e9thode check() s'effectue \u00e0 chaque it\u00e9ration et qu'une simulation peut compter des millions d'it\u00e9rations, optimiser le temps d'ex\u00e9cution de cette m\u00e9thode permet de diminuer de beaucoup le temps de calcul, d'autant plus que cette m\u00e9thode fait g\u00e9n\u00e9ralement appel \u00e0 des op\u00e9rateurs g\u00e9om\u00e9triques qui peuvent \u00eatre co\u00fbteux en termes de temps. Voici quelques astuces pour diminuer ce temps de calcul : 1/ Essayer de renvoyer false chaque fois d\u00e8s qu'une r\u00e8gle n'est pas respect\u00e9e ; 2/ Privil\u00e9gier les g\u00e9om\u00e9tries JTS aux g\u00e9om\u00e9tries GeOxygene (les op\u00e9rateurs g\u00e9om\u00e9triques appliqu\u00e9es aux g\u00e9om\u00e9tries GeOxygene n\u00e9cessitent une conversion JTS qui augmente le temps de calcul) ; 3/ Conserver des objets en cache lorsqu'ils sont fixes pour \u00e9viter de les re-g\u00e9n\u00e9rer \u00e0 chaque \u00e9tape ; 4/ Ne v\u00e9rifier les r\u00e8gles que pour les objets n\u00e9cessaires. En effet, les g\u00e9om\u00e9tries dans la configuration avant modification v\u00e9rifient d\u00e9j\u00e0 un certain nombre de r\u00e8gles, il n'est ainsi pas n\u00e9cessaire de devoir les r\u00e9\u00e9valuer pour celles-ci. Cela est par exemple vrai pour les r\u00e8gles de hauteur ou de distance 2D avec les limites s\u00e9paratives. Impl\u00e9mentation \u00e0 partir de la classe abstraite DefaultAbstractPredicate \uf0c1 La classe fr.ign.cogit.simplu3d.util.regulation.DefaultAbstractPredicate contient un certain nombre de fonctions de base qui sont issues de r\u00e8gles souvent utilis\u00e9es dans SimPLU3D. Les m\u00e9thodes de cette classe suivent les principes \u00e9voqu\u00e9s pr\u00e9c\u00e9demment et permettent de diminuer le temps de calcul. En \u00e9tendant cette classe abstraite et en utilisant son constructeur, il est possible de d\u00e9finir plus facilement la m\u00e9thode check() d'un pr\u00e9dicat en utilisant les fonctions pr\u00e9d\u00e9finies. On retrouve trois types de fonctions : des accesseurs , pour acc\u00e9der directement aux g\u00e9om\u00e9tries JTS d'un certain nombre d'objets issus du mod\u00e8le ; des v\u00e9rificateurs portant sur l'ensemble des objets de la configuration courante ; des v\u00e9rificateurs qui peuvent ne porter que sur les nouveaux objets propos\u00e9s par la modification (cf principe 4 \u00e9voqu\u00e9 pr\u00e9c\u00e9demment). Accesseurs \uf0c1 Ces m\u00e9thodes permettent d'acc\u00e9der directement \u00e0 certaines g\u00e9om\u00e9triques JTS sans avoir \u00e0 parcourir l'ensemble du mod\u00e8le Nom de la m\u00e9thode Commentaire getJtsCurveLimiteFondParcel G\u00e9om\u00e9trie des limites de fond de parcelle getJtsCurveLimiteFrontParcel G\u00e9om\u00e9trie des limites donnant sur la voirie getJtsCurveLimiteLatParcel G\u00e9om\u00e9trie des limites lat\u00e9rales getJtsCurveLimiteLatParcelLeft G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 gauche getJtsCurveLimiteLatParcelRight G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 droit getJtsCurveOppositeLimit G\u00e9om\u00e9trie des limites du c\u00f4t\u00e9 oppos\u00e9 \u00e0 la parcelle getbPUGeom G\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re Si une g\u00e9om\u00e9trie n'existe pas du fait de la configuration spatiale, elle aura null comme valeur. V\u00e9rificateur portant sur l'ensemble des objects \uf0c1 Il s'agit de m\u00e9thodes qui v\u00e9rifient certaines r\u00e8gles portant sur l'ensemble des objets apr\u00e8s modification. La m\u00e9thode getAllObjectsAfterModifcation(C c, M m) permet d'obtenir cette liste et de faire porter le test sur celle-ci. Par exemple, dans la m\u00e9thode check cela revient \u00e0 ajouter, par exemple, le code suivant : //On r\u00e9cup\u00e8re la liste des objets apr\u00e8s modification List<O> objects = this.getAllObjectsAfterModifcation(C c, M m); //Si le test qui v\u00e9rifie le nombre d'objets est faux, on consid\u00e8re que les r\u00e8gles ne sont pas respect\u00e9es, on renvoie faux au niveau de la m\u00e9thode check(). if(! checkNumberOfBuildings(objects, 8)){ return false; } On retrouve les m\u00e9thodes suivantes : Nom de la m\u00e9thode Commentaire checkNumberOfBuildings(allObjects, numberMaxOfObject) V\u00e9rifie que le nombre d'objets de la configuration est inf\u00e9rieure \u00e0 numberMaxOfObject checkBuiltRatio(allObjects, maxValue) V\u00e9rifie que le ratio de surface couverte de l'unit\u00e9 fonci\u00e8re est inf\u00e9rieure \u00e0 maxValue checkDistanceBetweenObjectandBuildings(allObjects, distMinInterBati) V\u00e9rifie que la distance entre chaque objet simul\u00e9 et les b\u00e2timents existants est sup\u00e9rieure \u00e0 distMinInterBati checkDistanceBetweenObjects(allObjects, distMinInterBati) V\u00e9rifie que la distance entre chaque paire d' objets simul\u00e9s est sup\u00e9rieure \u00e0 distMinInterBati V\u00e9rificateurs portant sur l'ensemble des nouveaux objets \uf0c1 Il s'agit de m\u00e9thodes qui peuvent \u00eatre v\u00e9rifi\u00e9s que sur les nouveaux objets cr\u00e9\u00e9s par la modification appliqu\u00e9e (dans le sens o\u00f9 l'ajout de nouveaux objets ne change pas le respect de la r\u00e8gles pour les objets d\u00e9j\u00e0 existants de la configuration). La liste des objets cr\u00e9\u00e9s par la modification peut \u00eatre obtenue avec la m\u00e9thode m.getBirth() . Ainsi, utiliser ces m\u00e9thodes dans la m\u00e9thode check revient par exemple \u00e0 ajouter le code suivant : //On r\u00e9cup\u00e8re la liste des objets ajout\u00e9s par la modification List<O> objects = m.getBirth(); //Si le test qui v\u00e9rifie si les nouveaux objets sont \u00e0 l'int\u00e9rieur de la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re est faux //On renvoie faux if(! checkIfInsideBPU(objects)){ return false; } On retrouve les m\u00e9thodes suivantes : Nom de la m\u00e9thode Commentaire checkDistanceToGeometry(objects, geom, distMin) V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure \u00e0 distMin checkDistanceToGeometry(objects, geom, dist, supOrInf) V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure ou inf\u00e9rieure \u00e0 distMin checkDistanceToLimitBySide(objects, distanceMin,lBoundaryType) V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des types fournis est sup\u00e9rieure \u00e0 distMin checkDistanceToLimitByType(objects, distanceMin, lBoundaryType) V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des c\u00f4t\u00e9s fournis est sup\u00e9rieure \u00e0 distMin checkDistanceToOppositeLimit(objects, distanceMin) V\u00e9rifie que la distance entre les objets les limites s\u00e9paratives des parcelles oppos\u00e9es est sup\u00e9rieure \u00e0 distMin checkIfContainedInGeometry(objects,geometry) V\u00e9rifie que la distance entre les objets sont contenues dans une g\u00e9om\u00e9trie checkIfInsideBPU(objects) V\u00e9rifie que la distance entre les objets sont inclus dans la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re checkIfIntersectsGeometry(objects, geometry) V\u00e9rifie que la distance entre les objets intersectent dans une g\u00e9om\u00e9trie Les m\u00e9thodes peuvent aussi \u00eatre utilis\u00e9es si on ne souhaite pas qu'une condition soit v\u00e9rifi\u00e9e. Par exemple, si on ne souhaite pas que les objets intersectent une g\u00e9om\u00e9trie, on peut utiliser la m\u00e9thode checkIfIntersectsGeometry et renvoyer faux si la condition est v\u00e9rifi\u00e9e.","title":"Principe de fonctionnement du v\u00e9rificateur"},{"location":"rules/predicate/#implementation-de-la-verification-de-regles-dans-simplu3d","text":"Pour v\u00e9rifier les r\u00e8gles morphologiques, SimPLU3D utilise le concept de pr\u00e9dicat. Il s'agit d'un objet qui indique si une configuration respecte une r\u00e8gle ou non.","title":"Impl\u00e9mentation de la v\u00e9rification de r\u00e8gles dans SimPLU3D"},{"location":"rules/predicate/#interface-de-predicat","text":"L'interface de la librjmcmc4j fr.ign.rjmcmc.configuration.ConfigurationModificationPredicate , M extends Modification > impl\u00e9mente cette notion de pr\u00e9dicat et permet la d\u00e9finition \u00e0 elle seule du respect des r\u00e8gles. Cette interface ne d\u00e9finit que la m\u00e9thode boolean check(C c, M m); . Avec : c , une instance de configuration, qui contient la liste des objets de la configuration courante (c'est \u00e0 dire avant application de la modification) ; m , la modification qui serait appliqu\u00e9e \u00e0 la configuration c ; la m\u00e9thode renvoie un boolean qui indique si les r\u00e8gles sont respect\u00e9es suite \u00e0 l'application de la modification m sur la configuration c .","title":"Interface de predicat"},{"location":"rules/predicate/#implementation-a-partir-de-linterface-de-predicat","text":"Dans SimPLU3D, nous conseillons l'impl\u00e9mentation de cette interface \u00e0 travers la d\u00e9finition suivante (et de regarder la-dite classe qui donne une id\u00e9e de comment impl\u00e9menter la m\u00e9thode) : SamplePredicate<O extends ISimPLU3DPrimitive, C extends AbstractGraphConfiguration<O, C, M>, M extends AbstractBirthDeathModification<O, C, M>> implements ConfigurationModificationPredicate<C, M> Ainsi, \u00e0 travers la classe abstraite AbstractGraphConfiguration , il est possible d'acc\u00e9der \u00e0 la liste des objets de la configuration courante \u00e0 travers un it\u00e9rateur (m\u00e9thode iterator ) et \u00e0 travers la classe AbstractBirthDeathModification d'acc\u00e9der aux modifications \u00e0 travers la cr\u00e9ation m.getBirth() et la destruction d'objets m.getDeath() de la classe utilis\u00e9e pendant la g\u00e9n\u00e9ration. Une modification est vue comme l'ajout et la suppression d'objet. Dans les modifications usuellement utilis\u00e9es dans SimPLU3D, ces listes contiennent soit 0 soit 1 objet. Il suffit ensuite de coder la v\u00e9rification des r\u00e8gles pour les diff\u00e9rents objets de la configuration apr\u00e8s modification en utilisant les informations disponibles dans l' environnement g\u00e9ographique ). Ainsi, pour avoir la liste des objets de la classe O apr\u00e8s modification, on peut utiliser le code suivant : List<O> listOfObjects = new ArrayList<>(); Iterator<O> iTBat = c.iterator(); while ( iTBat.hasNext()) { listOfObjects.add(iTBat.next()); } //La m\u00e9thode equals() doit \u00eatre d\u00e9finie pour la classe O listOfObjects.removeAll(m.getDeath()); listOfObjects.addAll(m.getBirth()); Attention : comme l'\u00e9valuation de la m\u00e9thode check() s'effectue \u00e0 chaque it\u00e9ration et qu'une simulation peut compter des millions d'it\u00e9rations, optimiser le temps d'ex\u00e9cution de cette m\u00e9thode permet de diminuer de beaucoup le temps de calcul, d'autant plus que cette m\u00e9thode fait g\u00e9n\u00e9ralement appel \u00e0 des op\u00e9rateurs g\u00e9om\u00e9triques qui peuvent \u00eatre co\u00fbteux en termes de temps. Voici quelques astuces pour diminuer ce temps de calcul : 1/ Essayer de renvoyer false chaque fois d\u00e8s qu'une r\u00e8gle n'est pas respect\u00e9e ; 2/ Privil\u00e9gier les g\u00e9om\u00e9tries JTS aux g\u00e9om\u00e9tries GeOxygene (les op\u00e9rateurs g\u00e9om\u00e9triques appliqu\u00e9es aux g\u00e9om\u00e9tries GeOxygene n\u00e9cessitent une conversion JTS qui augmente le temps de calcul) ; 3/ Conserver des objets en cache lorsqu'ils sont fixes pour \u00e9viter de les re-g\u00e9n\u00e9rer \u00e0 chaque \u00e9tape ; 4/ Ne v\u00e9rifier les r\u00e8gles que pour les objets n\u00e9cessaires. En effet, les g\u00e9om\u00e9tries dans la configuration avant modification v\u00e9rifient d\u00e9j\u00e0 un certain nombre de r\u00e8gles, il n'est ainsi pas n\u00e9cessaire de devoir les r\u00e9\u00e9valuer pour celles-ci. Cela est par exemple vrai pour les r\u00e8gles de hauteur ou de distance 2D avec les limites s\u00e9paratives.","title":"Impl\u00e9mentation \u00e0 partir de l'interface de pr\u00e9dicat"},{"location":"rules/predicate/#implementation-a-partir-de-la-classe-abstraite-defaultabstractpredicate","text":"La classe fr.ign.cogit.simplu3d.util.regulation.DefaultAbstractPredicate contient un certain nombre de fonctions de base qui sont issues de r\u00e8gles souvent utilis\u00e9es dans SimPLU3D. Les m\u00e9thodes de cette classe suivent les principes \u00e9voqu\u00e9s pr\u00e9c\u00e9demment et permettent de diminuer le temps de calcul. En \u00e9tendant cette classe abstraite et en utilisant son constructeur, il est possible de d\u00e9finir plus facilement la m\u00e9thode check() d'un pr\u00e9dicat en utilisant les fonctions pr\u00e9d\u00e9finies. On retrouve trois types de fonctions : des accesseurs , pour acc\u00e9der directement aux g\u00e9om\u00e9tries JTS d'un certain nombre d'objets issus du mod\u00e8le ; des v\u00e9rificateurs portant sur l'ensemble des objets de la configuration courante ; des v\u00e9rificateurs qui peuvent ne porter que sur les nouveaux objets propos\u00e9s par la modification (cf principe 4 \u00e9voqu\u00e9 pr\u00e9c\u00e9demment).","title":"Impl\u00e9mentation \u00e0 partir de la classe abstraite DefaultAbstractPredicate"},{"location":"rules/predicate/#accesseurs","text":"Ces m\u00e9thodes permettent d'acc\u00e9der directement \u00e0 certaines g\u00e9om\u00e9triques JTS sans avoir \u00e0 parcourir l'ensemble du mod\u00e8le Nom de la m\u00e9thode Commentaire getJtsCurveLimiteFondParcel G\u00e9om\u00e9trie des limites de fond de parcelle getJtsCurveLimiteFrontParcel G\u00e9om\u00e9trie des limites donnant sur la voirie getJtsCurveLimiteLatParcel G\u00e9om\u00e9trie des limites lat\u00e9rales getJtsCurveLimiteLatParcelLeft G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 gauche getJtsCurveLimiteLatParcelRight G\u00e9om\u00e9trie des limites lat\u00e9rales du c\u00f4t\u00e9 droit getJtsCurveOppositeLimit G\u00e9om\u00e9trie des limites du c\u00f4t\u00e9 oppos\u00e9 \u00e0 la parcelle getbPUGeom G\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re Si une g\u00e9om\u00e9trie n'existe pas du fait de la configuration spatiale, elle aura null comme valeur.","title":"Accesseurs"},{"location":"rules/predicate/#verificateur-portant-sur-lensemble-des-objects","text":"Il s'agit de m\u00e9thodes qui v\u00e9rifient certaines r\u00e8gles portant sur l'ensemble des objets apr\u00e8s modification. La m\u00e9thode getAllObjectsAfterModifcation(C c, M m) permet d'obtenir cette liste et de faire porter le test sur celle-ci. Par exemple, dans la m\u00e9thode check cela revient \u00e0 ajouter, par exemple, le code suivant : //On r\u00e9cup\u00e8re la liste des objets apr\u00e8s modification List<O> objects = this.getAllObjectsAfterModifcation(C c, M m); //Si le test qui v\u00e9rifie le nombre d'objets est faux, on consid\u00e8re que les r\u00e8gles ne sont pas respect\u00e9es, on renvoie faux au niveau de la m\u00e9thode check(). if(! checkNumberOfBuildings(objects, 8)){ return false; } On retrouve les m\u00e9thodes suivantes : Nom de la m\u00e9thode Commentaire checkNumberOfBuildings(allObjects, numberMaxOfObject) V\u00e9rifie que le nombre d'objets de la configuration est inf\u00e9rieure \u00e0 numberMaxOfObject checkBuiltRatio(allObjects, maxValue) V\u00e9rifie que le ratio de surface couverte de l'unit\u00e9 fonci\u00e8re est inf\u00e9rieure \u00e0 maxValue checkDistanceBetweenObjectandBuildings(allObjects, distMinInterBati) V\u00e9rifie que la distance entre chaque objet simul\u00e9 et les b\u00e2timents existants est sup\u00e9rieure \u00e0 distMinInterBati checkDistanceBetweenObjects(allObjects, distMinInterBati) V\u00e9rifie que la distance entre chaque paire d' objets simul\u00e9s est sup\u00e9rieure \u00e0 distMinInterBati","title":"V\u00e9rificateur portant sur l'ensemble des objects"},{"location":"rules/predicate/#verificateurs-portant-sur-lensemble-des-nouveaux-objets","text":"Il s'agit de m\u00e9thodes qui peuvent \u00eatre v\u00e9rifi\u00e9s que sur les nouveaux objets cr\u00e9\u00e9s par la modification appliqu\u00e9e (dans le sens o\u00f9 l'ajout de nouveaux objets ne change pas le respect de la r\u00e8gles pour les objets d\u00e9j\u00e0 existants de la configuration). La liste des objets cr\u00e9\u00e9s par la modification peut \u00eatre obtenue avec la m\u00e9thode m.getBirth() . Ainsi, utiliser ces m\u00e9thodes dans la m\u00e9thode check revient par exemple \u00e0 ajouter le code suivant : //On r\u00e9cup\u00e8re la liste des objets ajout\u00e9s par la modification List<O> objects = m.getBirth(); //Si le test qui v\u00e9rifie si les nouveaux objets sont \u00e0 l'int\u00e9rieur de la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re est faux //On renvoie faux if(! checkIfInsideBPU(objects)){ return false; } On retrouve les m\u00e9thodes suivantes : Nom de la m\u00e9thode Commentaire checkDistanceToGeometry(objects, geom, distMin) V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure \u00e0 distMin checkDistanceToGeometry(objects, geom, dist, supOrInf) V\u00e9rifie que la distance entre les objets et une g\u00e9om\u00e9trie est sup\u00e9rieure ou inf\u00e9rieure \u00e0 distMin checkDistanceToLimitBySide(objects, distanceMin,lBoundaryType) V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des types fournis est sup\u00e9rieure \u00e0 distMin checkDistanceToLimitByType(objects, distanceMin, lBoundaryType) V\u00e9rifie que la distance entre les objets et les limites s\u00e9paratives des c\u00f4t\u00e9s fournis est sup\u00e9rieure \u00e0 distMin checkDistanceToOppositeLimit(objects, distanceMin) V\u00e9rifie que la distance entre les objets les limites s\u00e9paratives des parcelles oppos\u00e9es est sup\u00e9rieure \u00e0 distMin checkIfContainedInGeometry(objects,geometry) V\u00e9rifie que la distance entre les objets sont contenues dans une g\u00e9om\u00e9trie checkIfInsideBPU(objects) V\u00e9rifie que la distance entre les objets sont inclus dans la g\u00e9om\u00e9trie de l'unit\u00e9 fonci\u00e8re checkIfIntersectsGeometry(objects, geometry) V\u00e9rifie que la distance entre les objets intersectent dans une g\u00e9om\u00e9trie Les m\u00e9thodes peuvent aussi \u00eatre utilis\u00e9es si on ne souhaite pas qu'une condition soit v\u00e9rifi\u00e9e. Par exemple, si on ne souhaite pas que les objets intersectent une g\u00e9om\u00e9trie, on peut utiliser la m\u00e9thode checkIfIntersectsGeometry et renvoyer faux si la condition est v\u00e9rifi\u00e9e.","title":"V\u00e9rificateurs portant sur l'ensemble des nouveaux objets"},{"location":"rules/topologique/","text":"Prise en compte de r\u00e8gles topologiques \uf0c1 Le fonctionnement de base de SimPLU3D qui consiste \u00e0 tirer des valeurs al\u00e9atoires dans un espace continu rend difficile l'application de contraintes topologiques. Si on prend l'exemple de l'alignement aux limites s\u00e9paratives donnant sur une route (cf image ci-dessous), il est totalement improbable que SimPLU3D effectue le tirage d'une bo\u00eete respectant cet alignement (cela revient \u00e0 tirer exactement le bonne valeur de x,y,w et \u03b8). Deux strat\u00e9gies sont possibles pour utiliser de telles r\u00e8gles. Strat\u00e9gie 1 : transformation en contrainte g\u00e9om\u00e9trique \uf0c1 La strat\u00e9gie na\u00efve consisterait \u00e0 transformer la contrainte topologique en contrainte g\u00e9om\u00e9trique. Par exemple, de v\u00e9rifier si l'un des c\u00f4t\u00e9s de la bo\u00eete est inclus dans un buffer de petite taille autour de la limite donnant sur la voirie. Cela rend probable la proposition de bo\u00eetes par le syst\u00e8me respectant cette r\u00e8gle, mais comme cette probabilit\u00e9 reste relativement faible, il peut \u00eatre n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations afin d'atteindre un r\u00e9sultat optimis\u00e9. Strat\u00e9gie 2 : g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es \uf0c1 La seconde strat\u00e9gie consiste \u00e0 non plus g\u00e9n\u00e9rer des bo\u00eetes libres, mais des bo\u00eetes directement align\u00e9es sur la limite consid\u00e9r\u00e9e. Il s'agit ainsi de d\u00e9finir un nouveau g\u00e9n\u00e9rateur de forme (comme d\u00e9crit dans la section G\u00e9n\u00e9rateur de formes - G\u00e9n\u00e9rer d'autres types de formes ). Dans ce cas, la g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e est non plus une bo\u00eete \u00e0 6 dimensions ( b = ( x , y , l , w , h , \u03b8 )), mais un bo\u00eete parall\u00e8le \u00e0 4 dimensions ( bp = ( x , y , l , h ), en consid\u00e9rant que l'orientation et la largeur sont impos\u00e9es par les coordonn\u00e9es du centre de l'objet. Ex\u00e9cutable pour la g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es \uf0c1 Dans le projet SimPLU3D-tutorial, une classe a \u00e9t\u00e9 ajout\u00e9e sur la base de l'exemple de base pour effectuer des simulation avec des bo\u00eetes qui seraient align\u00e9es \u00e0 la limite donnant sur la voirie. Il s'agit de la classe : fr.ign.simplu3d.topologicRule.ParallelSimulator // NEW HERE THE PARALELLE OPTIMOIZER IS USED ParallelCuboidOptimizer oCB = new ParallelCuboidOptimizer(); // IT REQUIRES AS INPUT THE GEOMETRY WHERE THE CUBOIDS HAVE TO BE ALIGNED IGeometry[] limits = createRoadLimits(bPU); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(Random.random(), bPU, p, env, 0, pred, limits, bPU.getGeom()); La diff\u00e9rence avec le code d'exemple de base tient en deux lignes : la r\u00e9cup\u00e9ration des limites le long desquelles les bo\u00eetes seront align\u00e9es ; l'utilisation du simulateur sp\u00e9cifique aux bo\u00eetes align\u00e9es (classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.paralellcuboid.ParallelCuboidOptimizer ) Le r\u00e9sultat est celui de la figure suivante. On visualise bien que la bo\u00eetes est align\u00e9e avec la limite s\u00e9parative ce qui fait que le r\u00e9sultat optimis\u00e9 n'occupe pas l'int\u00e9rieur du L. D\u00e9finition de l'optimiseur \uf0c1 L'optimiseur est d\u00e9fini comme g\u00e9n\u00e9rant des objets de la classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.simple.ParallelCuboid du projet SimPLU3D compos\u00e9 de 4 dimensions. N\u00e9anmoins, cette classe poss\u00e8de les attributs orientation et width pour permettre de g\u00e9n\u00e9rer la forme de la bo\u00eete. La diff\u00e9rence principale avec la simulation du b\u00e2timent en L se situe au niveau du builder (classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.builder.ParallelCuboidBuilder du projet SimPLU3D). Le builder est d\u00e9fini comme ayant 4 dimensions mais il va bien renseigner les 6 dimensions de l'objet ParallelCuboid . Pour d\u00e9terminer la largeur et l'orientation, une projection est effectu\u00e9e depuis le point tir\u00e9 al\u00e9atoirement vers la limite sur laquelle la forme est align\u00e9e. La longueur de la projection d\u00e9termine la moiti\u00e9 de la largeur de la bo\u00eete et son azimut l'orientation de la bo\u00eete (cf code ci-dessous). @Override public Cuboid build(double[] coordinates) { Coordinate p = new Coordinate(coordinates[0], coordinates[1]); DistanceOp op = new DistanceOp(this.limits, factory.createPoint(p)); Coordinate projected = op.nearestPoints()[0]; double distance = op.distance(); double orientation = Angle.angle(p, projected); AbstractParallelCuboid result; if (bandType == 1) { result = new ParallelCuboid(coordinates[0], coordinates[1], coordinates[2], distance * 2, coordinates[3], orientation + Math.PI / 2); } else { result = new ParallelCuboid2(coordinates[0], coordinates[1], coordinates[2], distance * 2, coordinates[3], orientation + Math.PI / 2); } return result; } Tous les autres aspects (impl\u00e9mentation des noyaux de proposition et du sampler) sont d\u00e9finis de la m\u00eame mani\u00e8re que vu pr\u00e9c\u00e9demment mais adapt\u00e9s pour ces objets \u00e0 4 dimensions.","title":"D\u00e9finition de contraintes topologiques"},{"location":"rules/topologique/#prise-en-compte-de-regles-topologiques","text":"Le fonctionnement de base de SimPLU3D qui consiste \u00e0 tirer des valeurs al\u00e9atoires dans un espace continu rend difficile l'application de contraintes topologiques. Si on prend l'exemple de l'alignement aux limites s\u00e9paratives donnant sur une route (cf image ci-dessous), il est totalement improbable que SimPLU3D effectue le tirage d'une bo\u00eete respectant cet alignement (cela revient \u00e0 tirer exactement le bonne valeur de x,y,w et \u03b8). Deux strat\u00e9gies sont possibles pour utiliser de telles r\u00e8gles.","title":"Prise en compte de r\u00e8gles topologiques"},{"location":"rules/topologique/#strategie-1-transformation-en-contrainte-geometrique","text":"La strat\u00e9gie na\u00efve consisterait \u00e0 transformer la contrainte topologique en contrainte g\u00e9om\u00e9trique. Par exemple, de v\u00e9rifier si l'un des c\u00f4t\u00e9s de la bo\u00eete est inclus dans un buffer de petite taille autour de la limite donnant sur la voirie. Cela rend probable la proposition de bo\u00eetes par le syst\u00e8me respectant cette r\u00e8gle, mais comme cette probabilit\u00e9 reste relativement faible, il peut \u00eatre n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations afin d'atteindre un r\u00e9sultat optimis\u00e9.","title":"Strat\u00e9gie 1 : transformation en contrainte g\u00e9om\u00e9trique"},{"location":"rules/topologique/#strategie-2-generation-de-boites-alignees","text":"La seconde strat\u00e9gie consiste \u00e0 non plus g\u00e9n\u00e9rer des bo\u00eetes libres, mais des bo\u00eetes directement align\u00e9es sur la limite consid\u00e9r\u00e9e. Il s'agit ainsi de d\u00e9finir un nouveau g\u00e9n\u00e9rateur de forme (comme d\u00e9crit dans la section G\u00e9n\u00e9rateur de formes - G\u00e9n\u00e9rer d'autres types de formes ). Dans ce cas, la g\u00e9om\u00e9trie param\u00e9trique utilis\u00e9e est non plus une bo\u00eete \u00e0 6 dimensions ( b = ( x , y , l , w , h , \u03b8 )), mais un bo\u00eete parall\u00e8le \u00e0 4 dimensions ( bp = ( x , y , l , h ), en consid\u00e9rant que l'orientation et la largeur sont impos\u00e9es par les coordonn\u00e9es du centre de l'objet.","title":"Strat\u00e9gie 2 :  g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es"},{"location":"rules/topologique/#executable-pour-la-generation-de-boites-alignees","text":"Dans le projet SimPLU3D-tutorial, une classe a \u00e9t\u00e9 ajout\u00e9e sur la base de l'exemple de base pour effectuer des simulation avec des bo\u00eetes qui seraient align\u00e9es \u00e0 la limite donnant sur la voirie. Il s'agit de la classe : fr.ign.simplu3d.topologicRule.ParallelSimulator // NEW HERE THE PARALELLE OPTIMOIZER IS USED ParallelCuboidOptimizer oCB = new ParallelCuboidOptimizer(); // IT REQUIRES AS INPUT THE GEOMETRY WHERE THE CUBOIDS HAVE TO BE ALIGNED IGeometry[] limits = createRoadLimits(bPU); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(Random.random(), bPU, p, env, 0, pred, limits, bPU.getGeom()); La diff\u00e9rence avec le code d'exemple de base tient en deux lignes : la r\u00e9cup\u00e9ration des limites le long desquelles les bo\u00eetes seront align\u00e9es ; l'utilisation du simulateur sp\u00e9cifique aux bo\u00eetes align\u00e9es (classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.paralellcuboid.ParallelCuboidOptimizer ) Le r\u00e9sultat est celui de la figure suivante. On visualise bien que la bo\u00eetes est align\u00e9e avec la limite s\u00e9parative ce qui fait que le r\u00e9sultat optimis\u00e9 n'occupe pas l'int\u00e9rieur du L.","title":"Ex\u00e9cutable pour la g\u00e9n\u00e9ration de bo\u00eetes align\u00e9es"},{"location":"rules/topologique/#definition-de-loptimiseur","text":"L'optimiseur est d\u00e9fini comme g\u00e9n\u00e9rant des objets de la classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.simple.ParallelCuboid du projet SimPLU3D compos\u00e9 de 4 dimensions. N\u00e9anmoins, cette classe poss\u00e8de les attributs orientation et width pour permettre de g\u00e9n\u00e9rer la forme de la bo\u00eete. La diff\u00e9rence principale avec la simulation du b\u00e2timent en L se situe au niveau du builder (classe fr.ign.cogit.simplu3d.rjmcmc.cuboid.builder.ParallelCuboidBuilder du projet SimPLU3D). Le builder est d\u00e9fini comme ayant 4 dimensions mais il va bien renseigner les 6 dimensions de l'objet ParallelCuboid . Pour d\u00e9terminer la largeur et l'orientation, une projection est effectu\u00e9e depuis le point tir\u00e9 al\u00e9atoirement vers la limite sur laquelle la forme est align\u00e9e. La longueur de la projection d\u00e9termine la moiti\u00e9 de la largeur de la bo\u00eete et son azimut l'orientation de la bo\u00eete (cf code ci-dessous). @Override public Cuboid build(double[] coordinates) { Coordinate p = new Coordinate(coordinates[0], coordinates[1]); DistanceOp op = new DistanceOp(this.limits, factory.createPoint(p)); Coordinate projected = op.nearestPoints()[0]; double distance = op.distance(); double orientation = Angle.angle(p, projected); AbstractParallelCuboid result; if (bandType == 1) { result = new ParallelCuboid(coordinates[0], coordinates[1], coordinates[2], distance * 2, coordinates[3], orientation + Math.PI / 2); } else { result = new ParallelCuboid2(coordinates[0], coordinates[1], coordinates[2], distance * 2, coordinates[3], orientation + Math.PI / 2); } return result; } Tous les autres aspects (impl\u00e9mentation des noyaux de proposition et du sampler) sont d\u00e9finis de la m\u00eame mani\u00e8re que vu pr\u00e9c\u00e9demment mais adapt\u00e9s pour ces objets \u00e0 4 dimensions.","title":"D\u00e9finition de l'optimiseur"},{"location":"visitor/intro/","text":"Principe des visiteurs \uf0c1 Les visiteurs sont des objets qui permettent de suivre l'\u00e9volution d'une simulation en produisant r\u00e9guli\u00e8rement des sorties. Les visiteurs impl\u00e9mentent l'interface de la libjrmcmc4j Visitor , M extends Modification > . Pour un visiteur, il est possible de d\u00e9finir deux types de sorties : les dumps , qui sont des sorties rapides en termes d'ex\u00e9cution qui sont effectu\u00e9es fr\u00e9quemment ; les saves , qui sont des sorties plus lentes en termes d'ex\u00e9cution et qui sont effectu\u00e9es moins fr\u00e9quemment. L'interface impose l'impl\u00e9mentation de 4 m\u00e9thodes : init(int dump, int save) : initialisation du visiteur avant la simulation (notamment avec l'affectation des valeurs dump et save qui correspondent \u00e0 la fr\u00e9quence de production ds sorties dump et save); begin(C config, Sampler sampler, Temperature t); : cette m\u00e9thode qui est ex\u00e9cut\u00e9e au d\u00e9but de la simulation ; visit(C config, Sampler sampler, Temperature t); : cette m\u00e9thode est ex\u00e9cut\u00e9e \u00e0 chaque it\u00e9ration, c'est ici que l'on distinguera les op\u00e9rations de save et de dump avec par exemple un test de ce type : if ((save > 0) && (iter % save == 0)) { ; end(C config, Sampler sampler, Temperature t); : cette m\u00e9thode est appliqu\u00e9e lors de la toute derni\u00e8re it\u00e9ration de la simulation. Dans le cadre de l'utilisation de SimPLU3D, plusieurs visiteurs ont \u00e9t\u00e9 impl\u00e9ment\u00e9s et sont activables et param\u00e9trables via le fichier params.json . Les valeurs save et dump peuvent notamment y \u00eatre d\u00e9finis pour tous les visiteurs. Vous pouvez tester ces visiteurs avec la simulation de base et pour toutes les autres. Les param\u00e8tres ont \u00e9t\u00e9 correctement fix\u00e9s, il suffit seulement de les activer et de mettre \u00e0 jour le param\u00e8tre save et background_img . Visiteurs de SimPLU3D \uf0c1 Sortie console : OutPutStreamVisitor \uf0c1 L' OutPutStreamVisitor est le visiteur qui affiche dans la console l'\u00e9tat d'avancement des simulations. Il est activable par la valeur outputstreamvisitor . Nom de la colonne Decription Iteration Num\u00e9ro de l'it\u00e9ration courante Objects Nombre d'objets dans la configuration courante A - Nom de noyau Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) que le noyau concern\u00e9 soit choisi P - Nom du noyau Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) que l'application de la modification du noyau soit accept\u00e9e Temp Valeur de la temp\u00e9rature Accept Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) qu'une modification soit accept\u00e9e Time (ms) Temps d'ex\u00e9cution u_1 Valeur de l'\u00e9nergie unaire u_2 Valeur de l'\u00e9nergie binaire u Valeur de l'\u00e9nergie combin\u00e9e Sortie shapefile : ShapefileVisitor \uf0c1 Le ShapefileVisitor est le visiteur qui permet de sauvegarder des shapefiles toutes les save it\u00e9ration. Il est activables par la valeur shapefilewriter . Il est n\u00e9cessaire \u00e9galement de param\u00e9trer la valeur result qui indique le dossier dans lequel les ShapeFiles seront export\u00e9s. Ils portent comme nom le num\u00e9ro de l'it\u00e9ration et les objets sauvegard\u00e9s auront comme attributs la valeur d'\u00e9nergie et de la m\u00e9thode toString() . Sortie sous forme de graphique : StatsVisitor \uf0c1 Le StatsVisitor permet la repr\u00e9sentation de l'\u00e9volution de l'\u00e9nergie au cours de la simulation sous forme d'un graphique. Il est activable par la valeur statsvisitor . Plusieurs informations sont repr\u00e9sent\u00e9es comme l'\u00e9nergie unaire, l'\u00e9nergie binaire, l'\u00e9nergie de la meilleure configuration rencontr\u00e9 et l'\u00e9nergie de la configuration actuel. L'image ci-dessous pr\u00e9sente le graphique qui peut \u00eatre visualis\u00e9. Petite astuce : comme le r\u00e9sultat d'une simulation est la derni\u00e8re configuration rencontr\u00e9e, ce graphique est utile pour visualiser si le meilleur candidat rencontr\u00e9 est bien cette derni\u00e8re configuration. Normalement, si le processus d'optimisation s'est bien d\u00e9roul\u00e9, les courbes \"Meilleur candidat\" et \"\u00c9nergie de la configuration actuelle\" doivent \u00eatre confondus en fin de simulation. Sinon, il peut s'av\u00e9rer n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations, la temp\u00e9rature et le coefficient de d\u00e9croissance. Sortie CSV : CSVvisitor et CSVendStats \uf0c1 Deux visiteurs permettent l'export de sorties sous forme de CSV : CSVvisitor et CSVendStats activables respectivement avec les valeurs csvvisitor et csvvisitorend . Dans les deux cas, la valeur de result d\u00e9termine le dossier de stockage des fichiers qui s'appelleront csvfilename et csvfilenamend . Le premier CSV contient une ligne par it\u00e9ration et stock des informations sur la configuration courante : num\u00e9ro de l'it\u00e9ration, taille de la configuration, \u00e9nergie de la configuration courante et \u00e9nergie moyenne sur les dump derni\u00e8res it\u00e9rations. Le second CSV contient les information de fin de simulation par parcelle (pratique lorsque l'on effectue des simulations sur de nombreuses parcelles) et notamment, le nombre d'it\u00e9rations, le temps d'ex\u00e9cution, la taille de la configuration et l'\u00e9nergie finale. Visualisation 3D \u00e0 la vol\u00e9e des r\u00e9sultats : ViewerVisitor \uf0c1 Le ViewerVisitor permet de visualiser en 3D les \u00e9volutions de la simulation en cours. Il est activable par la valeur visitorviewer et permet de repr\u00e9senter les donn\u00e9es charg\u00e9es et la simulation avec une mise \u00e0 jour toutes les dump it\u00e9rations. Quelques options d'affichage sont disponibles, comme le fait d'activer un plan contenant une image fixe avec l'option showbackground . Il est n\u00e9cessaire de fixer le chemin absolu vers l'image utilis\u00e9e background_img (\u00e0 mettre \u00e0 jour comme le chemin est absolu) et l'altitude de ce plan (valeur z .). Les coordonn\u00e9es de ce plan sont fix\u00e9es par les valeurs xminbg , yminbg , xmaxbg et ymaxbg . Il est \u00e9galement possible de choisir la couleur du fond de sc\u00e8ne avec les options filmvisitorr , filmvisitorg et filmvisitorb\":\"180 . Lors de l'utilisation de ce visiteur, la cam\u00e9ra se positionnera au centre de la sc\u00e8ne. Attention : : pour ce visiteur, la visualisation 3D n\u00e9cessite l'utilisation de la biblioth\u00e8que native de Java 3D (qui se trouve dans le projet). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant : -Djava.library.path=./lib/native_libraries/linux-amd64 La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9. Export d'image \u00e0 la vol\u00e9e : FilmVisitor \uf0c1 Le FilmVisitor permet d'exporter le rendu des simulations sous forme de .jpeg toutes les dump it\u00e9rations. Si le StatsVisitor est activ\u00e9, l'image de la simulation et l'image de ce visiteur se retrouvent conjointement export\u00e9es (cf image ci-dessous). Les param\u00e8tres du FilmVisitor sont tout d'abord ceux du ViewerVisitor . Il est \u00e9galement n\u00e9cessaire de d\u00e9finir la valeur save pour d\u00e9signer le r\u00e9pertoire dans lequel les images seront export\u00e9es. Il est \u00e9galement n\u00e9cessaire de d\u00e9finir les coordonn\u00e9es de la position de la cam\u00e9ra avec les coordonn\u00e9es filmvisitorx , filmvisitory et filmvisitorz et la direction dans laquelle regarde la cam\u00e9ra avec les coordonn\u00e9es : filmvisitorvecty , filmvisitorvectx et filmvisitorvectz . Utilisation d'autres visiteurs \uf0c1 Il est totalement possible d'impl\u00e9menter d'autres visiteurs en \u00e9tendant l'interface Visitor , M extends Modification > . Pour les optimiseur d\u00e9j\u00e0 d\u00e9finis, la classe fr.ign.cogit.simplu3d.rjmcmc.generic.visitor.PrepareVisitors du projet SimPLU3D permet d'initialiser les visiteurs et d'en rajouter d'autres via la liste lSupplementaryVisitors . Sinon, de mani\u00e8re g\u00e9n\u00e9rale les visiteurs sont pass\u00e9s en param\u00e8tre de la m\u00e9thode qui lance l'optimisation SimulatedAnnealing.optimize qui prend un objet de la classe CompositeVisitor en param\u00e8tre. L'instanciation d'un CompositeVisitor ne requiert qu'une liste de visiteur comme montr\u00e9 dans le code ci-dessous. List<Visitor<GraphConfiguration<C>, BirthDeathModification<C>>> list = new ArrayList<>(); list.addAll(lSupplementaryVisitors); CompositeVisitor<GraphConfiguration<C>, BirthDeathModification<C>> mVisitor = new CompositeVisitor<>(list);","title":"Suivre l'\u00e9volution d'une simulation"},{"location":"visitor/intro/#principe-des-visiteurs","text":"Les visiteurs sont des objets qui permettent de suivre l'\u00e9volution d'une simulation en produisant r\u00e9guli\u00e8rement des sorties. Les visiteurs impl\u00e9mentent l'interface de la libjrmcmc4j Visitor , M extends Modification > . Pour un visiteur, il est possible de d\u00e9finir deux types de sorties : les dumps , qui sont des sorties rapides en termes d'ex\u00e9cution qui sont effectu\u00e9es fr\u00e9quemment ; les saves , qui sont des sorties plus lentes en termes d'ex\u00e9cution et qui sont effectu\u00e9es moins fr\u00e9quemment. L'interface impose l'impl\u00e9mentation de 4 m\u00e9thodes : init(int dump, int save) : initialisation du visiteur avant la simulation (notamment avec l'affectation des valeurs dump et save qui correspondent \u00e0 la fr\u00e9quence de production ds sorties dump et save); begin(C config, Sampler sampler, Temperature t); : cette m\u00e9thode qui est ex\u00e9cut\u00e9e au d\u00e9but de la simulation ; visit(C config, Sampler sampler, Temperature t); : cette m\u00e9thode est ex\u00e9cut\u00e9e \u00e0 chaque it\u00e9ration, c'est ici que l'on distinguera les op\u00e9rations de save et de dump avec par exemple un test de ce type : if ((save > 0) && (iter % save == 0)) { ; end(C config, Sampler sampler, Temperature t); : cette m\u00e9thode est appliqu\u00e9e lors de la toute derni\u00e8re it\u00e9ration de la simulation. Dans le cadre de l'utilisation de SimPLU3D, plusieurs visiteurs ont \u00e9t\u00e9 impl\u00e9ment\u00e9s et sont activables et param\u00e9trables via le fichier params.json . Les valeurs save et dump peuvent notamment y \u00eatre d\u00e9finis pour tous les visiteurs. Vous pouvez tester ces visiteurs avec la simulation de base et pour toutes les autres. Les param\u00e8tres ont \u00e9t\u00e9 correctement fix\u00e9s, il suffit seulement de les activer et de mettre \u00e0 jour le param\u00e8tre save et background_img .","title":"Principe des visiteurs"},{"location":"visitor/intro/#visiteurs-de-simplu3d","text":"","title":"Visiteurs de SimPLU3D"},{"location":"visitor/intro/#sortie-console-outputstreamvisitor","text":"L' OutPutStreamVisitor est le visiteur qui affiche dans la console l'\u00e9tat d'avancement des simulations. Il est activable par la valeur outputstreamvisitor . Nom de la colonne Decription Iteration Num\u00e9ro de l'it\u00e9ration courante Objects Nombre d'objets dans la configuration courante A - Nom de noyau Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) que le noyau concern\u00e9 soit choisi P - Nom du noyau Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) que l'application de la modification du noyau soit accept\u00e9e Temp Valeur de la temp\u00e9rature Accept Probabilit\u00e9 moyenne (sur les dump derni\u00e8re it\u00e9rations) qu'une modification soit accept\u00e9e Time (ms) Temps d'ex\u00e9cution u_1 Valeur de l'\u00e9nergie unaire u_2 Valeur de l'\u00e9nergie binaire u Valeur de l'\u00e9nergie combin\u00e9e","title":"Sortie console : OutPutStreamVisitor"},{"location":"visitor/intro/#sortie-shapefile-shapefilevisitor","text":"Le ShapefileVisitor est le visiteur qui permet de sauvegarder des shapefiles toutes les save it\u00e9ration. Il est activables par la valeur shapefilewriter . Il est n\u00e9cessaire \u00e9galement de param\u00e9trer la valeur result qui indique le dossier dans lequel les ShapeFiles seront export\u00e9s. Ils portent comme nom le num\u00e9ro de l'it\u00e9ration et les objets sauvegard\u00e9s auront comme attributs la valeur d'\u00e9nergie et de la m\u00e9thode toString() .","title":"Sortie shapefile : ShapefileVisitor"},{"location":"visitor/intro/#sortie-sous-forme-de-graphique-statsvisitor","text":"Le StatsVisitor permet la repr\u00e9sentation de l'\u00e9volution de l'\u00e9nergie au cours de la simulation sous forme d'un graphique. Il est activable par la valeur statsvisitor . Plusieurs informations sont repr\u00e9sent\u00e9es comme l'\u00e9nergie unaire, l'\u00e9nergie binaire, l'\u00e9nergie de la meilleure configuration rencontr\u00e9 et l'\u00e9nergie de la configuration actuel. L'image ci-dessous pr\u00e9sente le graphique qui peut \u00eatre visualis\u00e9. Petite astuce : comme le r\u00e9sultat d'une simulation est la derni\u00e8re configuration rencontr\u00e9e, ce graphique est utile pour visualiser si le meilleur candidat rencontr\u00e9 est bien cette derni\u00e8re configuration. Normalement, si le processus d'optimisation s'est bien d\u00e9roul\u00e9, les courbes \"Meilleur candidat\" et \"\u00c9nergie de la configuration actuelle\" doivent \u00eatre confondus en fin de simulation. Sinon, il peut s'av\u00e9rer n\u00e9cessaire d'augmenter le nombre d'it\u00e9rations, la temp\u00e9rature et le coefficient de d\u00e9croissance.","title":"Sortie sous forme de graphique : StatsVisitor"},{"location":"visitor/intro/#sortie-csv-csvvisitor-et-csvendstats","text":"Deux visiteurs permettent l'export de sorties sous forme de CSV : CSVvisitor et CSVendStats activables respectivement avec les valeurs csvvisitor et csvvisitorend . Dans les deux cas, la valeur de result d\u00e9termine le dossier de stockage des fichiers qui s'appelleront csvfilename et csvfilenamend . Le premier CSV contient une ligne par it\u00e9ration et stock des informations sur la configuration courante : num\u00e9ro de l'it\u00e9ration, taille de la configuration, \u00e9nergie de la configuration courante et \u00e9nergie moyenne sur les dump derni\u00e8res it\u00e9rations. Le second CSV contient les information de fin de simulation par parcelle (pratique lorsque l'on effectue des simulations sur de nombreuses parcelles) et notamment, le nombre d'it\u00e9rations, le temps d'ex\u00e9cution, la taille de la configuration et l'\u00e9nergie finale.","title":"Sortie CSV : CSVvisitor et CSVendStats"},{"location":"visitor/intro/#visualisation-3d-a-la-volee-des-resultats-viewervisitor","text":"Le ViewerVisitor permet de visualiser en 3D les \u00e9volutions de la simulation en cours. Il est activable par la valeur visitorviewer et permet de repr\u00e9senter les donn\u00e9es charg\u00e9es et la simulation avec une mise \u00e0 jour toutes les dump it\u00e9rations. Quelques options d'affichage sont disponibles, comme le fait d'activer un plan contenant une image fixe avec l'option showbackground . Il est n\u00e9cessaire de fixer le chemin absolu vers l'image utilis\u00e9e background_img (\u00e0 mettre \u00e0 jour comme le chemin est absolu) et l'altitude de ce plan (valeur z .). Les coordonn\u00e9es de ce plan sont fix\u00e9es par les valeurs xminbg , yminbg , xmaxbg et ymaxbg . Il est \u00e9galement possible de choisir la couleur du fond de sc\u00e8ne avec les options filmvisitorr , filmvisitorg et filmvisitorb\":\"180 . Lors de l'utilisation de ce visiteur, la cam\u00e9ra se positionnera au centre de la sc\u00e8ne. Attention : : pour ce visiteur, la visualisation 3D n\u00e9cessite l'utilisation de la biblioth\u00e8que native de Java 3D (qui se trouve dans le projet). Il est n\u00e9cessaire de passer \u00e0 la VM l'argument suivant : -Djava.library.path=./lib/native_libraries/linux-amd64 La ligne pr\u00e9c\u00e9dente est d\u00e9finie pour Linux 64 bits, au besoin, il faut remplacer linux-amd64 par windows-i586 (windows 32bits), windows-amd64 (windows 64bits) ou linux-i386 (linux 32bits) en fonction de l'OS utilis\u00e9.","title":"Visualisation 3D \u00e0 la vol\u00e9e des r\u00e9sultats : ViewerVisitor"},{"location":"visitor/intro/#export-dimage-a-la-volee-filmvisitor","text":"Le FilmVisitor permet d'exporter le rendu des simulations sous forme de .jpeg toutes les dump it\u00e9rations. Si le StatsVisitor est activ\u00e9, l'image de la simulation et l'image de ce visiteur se retrouvent conjointement export\u00e9es (cf image ci-dessous). Les param\u00e8tres du FilmVisitor sont tout d'abord ceux du ViewerVisitor . Il est \u00e9galement n\u00e9cessaire de d\u00e9finir la valeur save pour d\u00e9signer le r\u00e9pertoire dans lequel les images seront export\u00e9es. Il est \u00e9galement n\u00e9cessaire de d\u00e9finir les coordonn\u00e9es de la position de la cam\u00e9ra avec les coordonn\u00e9es filmvisitorx , filmvisitory et filmvisitorz et la direction dans laquelle regarde la cam\u00e9ra avec les coordonn\u00e9es : filmvisitorvecty , filmvisitorvectx et filmvisitorvectz .","title":"Export d'image \u00e0 la vol\u00e9e : FilmVisitor"},{"location":"visitor/intro/#utilisation-dautres-visiteurs","text":"Il est totalement possible d'impl\u00e9menter d'autres visiteurs en \u00e9tendant l'interface Visitor , M extends Modification > . Pour les optimiseur d\u00e9j\u00e0 d\u00e9finis, la classe fr.ign.cogit.simplu3d.rjmcmc.generic.visitor.PrepareVisitors du projet SimPLU3D permet d'initialiser les visiteurs et d'en rajouter d'autres via la liste lSupplementaryVisitors . Sinon, de mani\u00e8re g\u00e9n\u00e9rale les visiteurs sont pass\u00e9s en param\u00e8tre de la m\u00e9thode qui lance l'optimisation SimulatedAnnealing.optimize qui prend un objet de la classe CompositeVisitor en param\u00e8tre. L'instanciation d'un CompositeVisitor ne requiert qu'une liste de visiteur comme montr\u00e9 dans le code ci-dessous. List<Visitor<GraphConfiguration<C>, BirthDeathModification<C>>> list = new ArrayList<>(); list.addAll(lSupplementaryVisitors); CompositeVisitor<GraphConfiguration<C>, BirthDeathModification<C>> mVisitor = new CompositeVisitor<>(list);","title":"Utilisation d'autres visiteurs"}]}