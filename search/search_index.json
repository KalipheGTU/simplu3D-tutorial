{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"title: Introduction - Documentation de SimPLU3D authors: - Micka\u00ebl Brasebin date: 2018-10-39 Documentation de SimPLU3D \uf0c1 SimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties en 3D optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utiliser pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementation) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisations ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation Github SimPLU3D . Principe de fonctionnement de SimPLU3D Cette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de Plans Locaux d'Urbanisme (PLU) et permet de r\u00e9pondre \u00e0 ce type de questions : Quelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ? Comment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU ? Est-ce que des b\u00e2timents faisaient une ombre trop importante sur les parcelles voisines peuvent \u00eatre construits ? SimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter la liste des r\u00e9alisations et publications . SimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire LASTIG de l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . N'h\u00e9sitez pas \u00e0 nous contacter pour nous fait un retour sur SimPLU3D ou pour utiliser le code. Cette documentation a pour but de montrer comment utiliser SimPLU3D et de param\u00e9trer l'approche en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation (par ici) . La conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se : Brasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014 M\u00e9moire , Pr\u00e9sentation","title":"Accueil"},{"location":"#documentation-de-simplu3d","text":"SimPLU3D est un ensemble de biblioth\u00e8ques Java Open-Source qui permet de simuler des formes b\u00e2ties en 3D optimisant une fonction \u00e0 partir de contraintes morphologiques. Ces codes peuvent \u00eatre utiliser pour questionner le rapport entre des contraintes morphologiques (par exemple issues de r\u00e9glementation) et les formes produites \u00e0 l'\u00e9chelle du quartier ou de l'agglom\u00e9ration. L'approche de SimPLU3D est g\u00e9n\u00e9rique dans le sens o\u00f9 il est possible de d\u00e9finir ses propres contraintes, fonctions d'optimisations ou types de formes. L'ensemble de ces biblioth\u00e8que est disponible dans l'organisation Github SimPLU3D . Principe de fonctionnement de SimPLU3D Cette biblioth\u00e8que a notamment \u00e9t\u00e9 utilis\u00e9e pour mod\u00e9liser des formes b\u00e2ties \u00e0 partir de contraintes issues de Plans Locaux d'Urbanisme (PLU) et permet de r\u00e9pondre \u00e0 ce type de questions : Quelle est la quantit\u00e9 de logements que l'on peut b\u00e2tir sur une parcelle ? Comment est-ce que la forme de mon quartier va \u00e9voluer si l'on change un PLU ? Est-ce que des b\u00e2timents faisaient une ombre trop importante sur les parcelles voisines peuvent \u00eatre construits ? SimPLU3D a d\u00e9j\u00e0 fait l'objet de plusieurs applications et publications, n'h\u00e9sitez pas consulter la liste des r\u00e9alisations et publications . SimPLU3D est d\u00e9velopp\u00e9 et maintenu par le laboratoire LASTIG de l' Institut National de l'Information G\u00e9ographique et Foresti\u00e8re . N'h\u00e9sitez pas \u00e0 nous contacter pour nous fait un retour sur SimPLU3D ou pour utiliser le code. Cette documentation a pour but de montrer comment utiliser SimPLU3D et de param\u00e9trer l'approche en fonction de vos besoins. Pour commencer, la premi\u00e8re \u00e9tape est d'installer les biblioth\u00e8ques et de lancer une premi\u00e8re simulation (par ici) . La conception et le d\u00e9veloppement de SimPLU3D ont \u00e9t\u00e9 initi\u00e9s dans le cadre de la th\u00e8se : Brasebin, M. (2014) Les donn\u00e9es g\u00e9ographiques 3D pour simuler l'impact de la r\u00e9glementation urbaine sur la morphologie du b\u00e2ti, Th\u00e8se de doctorat, sp\u00e9cialit\u00e9 Sciences et Technologies de l'Information G\u00e9ographique, Universit\u00e9 Paris-Est, apr 2014 M\u00e9moire , Pr\u00e9sentation","title":"Documentation de SimPLU3D"},{"location":"about/","text":"Qui contacter ? Qui a fait quoi ? Nous contacter : Si vous souhaitez utiliser SimPLU3D, n'h\u00e9sitez pas \u00e0 nous contacter, Pour signaler un bug n'h\u00e9sitez pas \u00e0 faire un pull request dans l'un des projets Remerciements :","title":"\u00c0 propos"},{"location":"bibliographie/","text":"Liste d'articles et lien vers des r\u00e9alisations","title":"R\u00e9alisations et bibliographie"},{"location":"development/","text":"Page listant les futurs d\u00e9veloppements : Persistance de l'environnement g\u00e9ographique (par exemple pour reprendre manuellement des \u00e9tapes du processus d'int\u00e9gration) Aspect esth\u00e9tique","title":"Futurs d\u00e9veloppements"},{"location":"export/","text":"Page sur les m\u00e9thodes pour exporter les r\u00e9sultats, en shapefile, \u00e0 la main, en base de donn\u00e9es.","title":"Exporter les r\u00e9sultats d'une simulation"},{"location":"begin/first_simulation/","text":"Introduction \uf0c1 L'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9 de boites qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi au fur et \u00e0 mesure de cette documentation. Pour commencer, il est n\u00e9cessaire d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la page d'installation . Le code utilis\u00e9 dans cette page est dans la classe : fr.ign.simplu3d.firstSimulation.BasicSimulator. Donn\u00e9es d'entr\u00e9e \uf0c1 Les donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources resources/firstSimulation/ . Il s'agit du plus petit ensemble de donn\u00e9es possible n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers : - data : qui contient un fichier ShapeFile de parcelles (parcelle.shp) avec un attribut id . Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans la section consacr\u00e9 \u00e0 l'environnement g\u00e9ographique ) ; - scenario : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de forme (d\u00e9crits dans la section d\u00e9di\u00e9e aux param\u00e8tres de la g\u00e9n\u00e9ration de formes ) et des visiteurs qui seront ex\u00e9cut\u00e9s pendant la simulation ( d\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs ). Code de simulation \uf0c1 Le code \u00e0 ex\u00e9cuter est repris ci-dessous comment\u00e9. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation : la cr\u00e9ation d'un environnement g\u00e9ographique ; la d\u00e9finition de contraintes morphologiques , \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , bas\u00e9 sur des boites ; l' export de r\u00e9sultats . public static void main(String[] args) throws Exception { //Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environnement using the repository that contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM( new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); //Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 2; // Distance to bottom of the parcel double distReculFond = 3; // Distance to lateral parcel limits double distReculLat = 4; // Distance between two buildings of a parcel double distanceInterBati = 0; // Maximal ratio built area double maximalCES = 0.5; //Instanciation of a predicate class SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); //Step 3 : Defining the regulation that will be applied during the simulation // Instantiation of the sampler OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath(); String fileName = \"params.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); //4 - Writting the output SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0); } Ex\u00e9cution du code de simulation \uf0c1 Avant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable outputFolder qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s. Une fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code. Pendant le code, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section suivre l'\u00e9volution d'une simulation ). Deux sorties sont visualisables pendant la simulation : - Dans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives \u00e0 la simulation et notamment le nombre d'objets et la valeur de la fonction d'optimisation ; - Dans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est - le volume de la configuration (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant). R\u00e9sultats de la premi\u00e8re simulation \uf0c1 La sortie est stock\u00e9e sous la forme d'un ShapeFile out.shp qui contient les diff\u00e9rentes boites avec des attributs : id : l'identifiant de la parcelle simul\u00e9e ; hauteur : la hauteur de la boite ; longueur : la longueur de la boite ; largeur : la largeur de la boite ; orient : l'azimut de la boite ; centerX , centerY : les coordonn\u00e9es du centre de la boite. La g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ. Vous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diffrentes variables de r\u00e8gles. Dans la section suivante , nous d\u00e9taillons le principe de fonctionnement de la simulation.","title":"Premiers pas - Premi\u00e8re simulation"},{"location":"begin/first_simulation/#introduction","text":"L'objectif de cette page est de lancer une premi\u00e8re simulation tr\u00e8s simple afin de voir comment se d\u00e9roule une simulation de SimPLU3D. Cette simulation consiste \u00e0 g\u00e9n\u00e9rer une forme compos\u00e9 de boites qui s'intersectent \u00e0 partir d'un code exemple qui sera enrichi au fur et \u00e0 mesure de cette documentation. Pour commencer, il est n\u00e9cessaire d'installer les codes de tutoriel comme pr\u00e9cis\u00e9 dans la page d'installation . Le code utilis\u00e9 dans cette page est dans la classe : fr.ign.simplu3d.firstSimulation.BasicSimulator.","title":"Introduction"},{"location":"begin/first_simulation/#donnees-dentree","text":"Les donn\u00e9es en entr\u00e9e se trouvent dans le r\u00e9pertoire de ressources resources/firstSimulation/ . Il s'agit du plus petit ensemble de donn\u00e9es possible n\u00e9cessaire pour ex\u00e9cuter SimPLU3D. Il contient deux dossiers : - data : qui contient un fichier ShapeFile de parcelles (parcelle.shp) avec un attribut id . Ces parcelles d\u00e9finissent l'environnement g\u00e9ographique dans lequel se d\u00e9roule la simulation, cet environnement g\u00e9ographique peut \u00eatre enrichi d'autres objets d\u00e9j\u00e0 pr\u00e9vus dans SimPLU3D (vous trouverez plus d'informations dans la section consacr\u00e9 \u00e0 l'environnement g\u00e9ographique ) ; - scenario : qui contient un fichier params.json qui contient la description des param\u00e8tres de la g\u00e9n\u00e9ration de forme (d\u00e9crits dans la section d\u00e9di\u00e9e aux param\u00e8tres de la g\u00e9n\u00e9ration de formes ) et des visiteurs qui seront ex\u00e9cut\u00e9s pendant la simulation ( d\u00e9crits dans la section d\u00e9di\u00e9e aux visiteurs ).","title":"Donn\u00e9es d'entr\u00e9e"},{"location":"begin/first_simulation/#code-de-simulation","text":"Le code \u00e0 ex\u00e9cuter est repris ci-dessous comment\u00e9. On note qu'il y a 4 \u00e9tapes n\u00e9cessaires pour ex\u00e9cuter la simulation : la cr\u00e9ation d'un environnement g\u00e9ographique ; la d\u00e9finition de contraintes morphologiques , \u00e0 partir d'une classe de v\u00e9rification de r\u00e8gles d\u00e9j\u00e0 impl\u00e9ment\u00e9e ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , bas\u00e9 sur des boites ; l' export de r\u00e9sultats . public static void main(String[] args) throws Exception { //Step 0 ; Defining an output existing folder String outputFolder = \"/tmp/\"; // Step 1 : Creating the geographic environnement using the repository that contains the data // Load default environment (data are in resource directory) Environnement env = LoaderSHP.loadNoDTM( new File(BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/data/\").getPath())); // Select a parcel on which generation is proceeded BasicPropertyUnit bPU = env.getBpU().get(2); //Step 2 : Defining the regulation that will be applied during the simulation // Rules parameters.8 // Distance to road double distReculVoirie = 2; // Distance to bottom of the parcel double distReculFond = 3; // Distance to lateral parcel limits double distReculLat = 4; // Distance between two buildings of a parcel double distanceInterBati = 0; // Maximal ratio built area double maximalCES = 0.5; //Instanciation of a predicate class SamplePredicate<Cuboid, GraphConfiguration<Cuboid>, BirthDeathModification<Cuboid>> pred = new SamplePredicate<>( bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES); //Step 3 : Defining the regulation that will be applied during the simulation // Instantiation of the sampler OptimisedBuildingsCuboidFinalDirectRejection oCB = new OptimisedBuildingsCuboidFinalDirectRejection(); // Loading the parameters for the building shape generation String folderName = BasicSimulator.class.getClassLoader().getResource(\"firstSimulation/scenario/\").getPath(); String fileName = \"params.json\"; SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName)); // Run of the optimisation on a parcel with the predicate GraphConfiguration<Cuboid> cc = oCB.process(bPU, p, env, 1, pred); //4 - Writting the output SaveGeneratedObjects.saveShapefile(outputFolder + \"out.shp\", cc, bPU.getId(), 0); }","title":"Code de simulation"},{"location":"begin/first_simulation/#execution-du-code-de-simulation","text":"Avant d'ex\u00e9cuter ce code, il est n\u00e9cessaire de d\u00e9finir la variable outputFolder qui d\u00e9termine le dossier dans lequel les r\u00e9sultats de la simulation seront export\u00e9s. Une fois cette valeur fix\u00e9e, vous pouvez ex\u00e9cuter le code. Pendant le code, des informations sur l'avancement de la simulation seront affich\u00e9es (pour en savoir plus la section suivre l'\u00e9volution d'une simulation ). Deux sorties sont visualisables pendant la simulation : - Dans la console, un tableau repr\u00e9sente durant les it\u00e9rations des informations relatives \u00e0 la simulation et notamment le nombre d'objets et la valeur de la fonction d'optimisation ; - Dans une fen\u00eatre, la valeur de la fonction d'optimisation (en rouge fonc\u00e9) \u00e9volue au fur et \u00e0 mesure des it\u00e9rations. Dans ce cas, la valeur repr\u00e9sent\u00e9e est - le volume de la configuration (l'algorithme d'optimisation utilis\u00e9 minimisant la valeur d'une fonction d'optimisation, c'est pour cela que la valeur \u00e9volue en diminuant).","title":"Ex\u00e9cution du code de simulation"},{"location":"begin/first_simulation/#resultats-de-la-premiere-simulation","text":"La sortie est stock\u00e9e sous la forme d'un ShapeFile out.shp qui contient les diff\u00e9rentes boites avec des attributs : id : l'identifiant de la parcelle simul\u00e9e ; hauteur : la hauteur de la boite ; longueur : la longueur de la boite ; largeur : la largeur de la boite ; orient : l'azimut de la boite ; centerX , centerY : les coordonn\u00e9es du centre de la boite. La g\u00e9om\u00e9trie est une g\u00e9om\u00e9trie 3D stock\u00e9e sous la forme d'un multipolygoneZ. Vous pouvez essayer de modifier le code pour tester les r\u00e9sultats sur diff\u00e9rentes parcelles ou diffrentes variables de r\u00e8gles. Dans la section suivante , nous d\u00e9taillons le principe de fonctionnement de la simulation.","title":"R\u00e9sultats de la premi\u00e8re simulation"},{"location":"begin/installation/","text":"Installer SimPLU3D \uf0c1 Les biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN. Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet SimPLU3D-tutorial ou sinon vous pouvez directement l'installer dans votre projet. Attention : il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions : Installer localement le certificat comme d\u00e9crit dans le lien suivant http://ignf.github.io/geoxygene/documentation/developer/install.html Faire une installation s\u00e9curis\u00e9e lorsqu'il faudra construire le projet : mvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true Installer le code SimPLU3D-tutorial \uf0c1 Les \u00e9tapes suivantes sont n\u00e9cessaires : 1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes : http://ignf.github.io/geoxygene/documentation/developer/install.html 2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial 3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\" 4 - Lancer une installation avec Maven : Click droit sur le projet et \" Run as Maven Install \" ou directement en ligne de commande : mvn clean install 5 - Lancer une construction du projet avec Eclipse : Project > Build project Vous pouvez d\u00e9sormais ex\u00e9cuter la premi\u00e8re simulation . Installer SimPLU3D dans un autre projet \uf0c1 L'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes : 1 - Cr\u00e9ation d'un projet Maven 2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises dependencies , en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D. <dependency> <groupId>fr.ign.cogit</groupId> <artifactId>simplu3d</artifactId> <version>1.2-SNAPSHOT</version> </dependency> 3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises repositories <repository> <id>ign-snapshots</id> <name>Cogit Snapshots Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url> <snapshots> <enabled>true</enabled> </snapshots> <releases> <enabled>false</enabled> </releases> </repository> <repository> <id>ign-releases</id> <name>Cogit Releases Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url> <snapshots> <enabled>false</enabled> </snapshots> <releases> <enabled>true</enabled> </releases> </repository> 4 - Faire un build du projet en utilisant par exemple : maven install .","title":"Premiers pas - Installation"},{"location":"begin/installation/#installer-simplu3d","text":"Les biblioth\u00e8ques de SimPLU3D sont construites avec Maven et cod\u00e9es en Java (la version 8 de la JDK est requise) et sont r\u00e9guli\u00e8rement d\u00e9ploy\u00e9es sur le serveur Maven de l'IGN. Si vous voulez essayer les codes d\u00e9crits dans cette documentation, vous pouvez installer le projet SimPLU3D-tutorial ou sinon vous pouvez directement l'installer dans votre projet. Attention : il se peut que la compilation du projet ne se fasse pas \u00e0 cause de probl\u00e8mes li\u00e9es \u00e0 la v\u00e9rification du certificat ssh de la forge IGN. Pour cela deux solutions : Installer localement le certificat comme d\u00e9crit dans le lien suivant http://ignf.github.io/geoxygene/documentation/developer/install.html Faire une installation s\u00e9curis\u00e9e lorsqu'il faudra construire le projet : mvn clean install -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true","title":"Installer SimPLU3D"},{"location":"begin/installation/#installer-le-code-simplu3d-tutorial","text":"Les \u00e9tapes suivantes sont n\u00e9cessaires : 1 - Installer un environnement de d\u00e9veloppement compatible avec Maven, nous recommandons de suivre ces \u00e9tapes : http://ignf.github.io/geoxygene/documentation/developer/install.html 2 - Cloner avec Git le projet https://github.com/SimPLU3D/simplu3D-tutorial 3 - Importer le projet dans l'environnement de d\u00e9veloppement. Dans Eclipse \"Fichier > Importer un projet > Importer un projet Maven\" 4 - Lancer une installation avec Maven : Click droit sur le projet et \" Run as Maven Install \" ou directement en ligne de commande : mvn clean install 5 - Lancer une construction du projet avec Eclipse : Project > Build project Vous pouvez d\u00e9sormais ex\u00e9cuter la premi\u00e8re simulation .","title":"Installer le code SimPLU3D-tutorial"},{"location":"begin/installation/#installer-simplu3d-dans-un-autre-projet","text":"L'installation s'effectue simplement en cr\u00e9ant un projet qui pointe vers les d\u00e9pendances de SimPLU3D. Les \u00e9tapes sont les suivantes : 1 - Cr\u00e9ation d'un projet Maven 2 - Ajout de la d\u00e9pendance \u00e0 SimPLU3D dans le pom.xml dans les balises dependencies , en pensant \u00e0 v\u00e9rifier la version actuelle de SimPLU3D. <dependency> <groupId>fr.ign.cogit</groupId> <artifactId>simplu3d</artifactId> <version>1.2-SNAPSHOT</version> </dependency> 3 - Ajouter les d\u00e9p\u00f4ts sur lesquels est d\u00e9ploy\u00e9 SimPLU3D et les biblioth\u00e8ques dans le pom.xml dans les balises repositories <repository> <id>ign-snapshots</id> <name>Cogit Snapshots Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/snapshots/</url> <snapshots> <enabled>true</enabled> </snapshots> <releases> <enabled>false</enabled> </releases> </repository> <repository> <id>ign-releases</id> <name>Cogit Releases Repository</name> <url>https://forge-cogit.ign.fr/nexus/content/repositories/releases/</url> <snapshots> <enabled>false</enabled> </snapshots> <releases> <enabled>true</enabled> </releases> </repository> 4 - Faire un build du projet en utilisant par exemple : maven install .","title":"Installer SimPLU3D dans un autre projet"},{"location":"begin/intro/","text":"Introduction \uf0c1 SimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re. Cela signifie que pour \u00eatre capable d'utiliser SimPLU3D il est n\u00e9cessaire d'avoir des comp\u00e9tences : dans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des g\u00e9n\u00e9rics ; dans le gestionnaire de projet Maven afin de pouvoir utiliser les biblioth\u00e8ques de SimPLU3D. La documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D : L'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son environnement g\u00e9ographique ; La g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation ; La d\u00e9finition des contraintes morphologiques . Pour illustrer comment utiliser SimPLU3D, des codes sont mis \u00e0 disposition dans le projet SimPLU3D-tutorial . Ces codes partent de l'exemple d'une premi\u00e8re simulation et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles. Pour d\u00e9buter, il est tout d'abord n\u00e9cessaire d'installer SimPLU3D .","title":"Premiers pas - Introduction"},{"location":"begin/intro/#introduction","text":"SimPLU3D est une biblioth\u00e8que de recherche ce qui signifie qu'il n'y a actuellement pas d'interface graphique d\u00e9di\u00e9e \u00e0 la param\u00e9trisation du code et que la maintenance du code n'est pas effectu\u00e9e de mani\u00e8re tr\u00e8s r\u00e9guli\u00e8re. Cela signifie que pour \u00eatre capable d'utiliser SimPLU3D il est n\u00e9cessaire d'avoir des comp\u00e9tences : dans le langage de programmation Java et notamment une bonne connaissance de l'h\u00e9ritage et des g\u00e9n\u00e9rics ; dans le gestionnaire de projet Maven afin de pouvoir utiliser les biblioth\u00e8ques de SimPLU3D. La documentation s'organise autour de trois parties pr\u00e9sentant les trois aspects principaux du code de SimPLU3D : L'utilisation de donn\u00e9es g\u00e9ographiques \u00e0 travers son environnement g\u00e9ographique ; La g\u00e9n\u00e9ration de formes b\u00e2ties par optimisation ; La d\u00e9finition des contraintes morphologiques . Pour illustrer comment utiliser SimPLU3D, des codes sont mis \u00e0 disposition dans le projet SimPLU3D-tutorial . Ces codes partent de l'exemple d'une premi\u00e8re simulation et des \u00e9volutions sont apport\u00e9es suivant les aspects abord\u00e9es dans ces parties. Pour chacune des parties, le degr\u00e9 de personnalisation progresse de mani\u00e8re croissante avec une difficult\u00e9 \u00e9galement croissante. Cela d\u00e9bute par une simple param\u00e9trisation de fichiers de configuration pour aller jusqu'\u00e0 la cr\u00e9ation de nouvelles classes pour g\u00e9n\u00e9rer par exemple de nouvelles formes ou int\u00e9grer de nouvelles r\u00e8gles. Pour d\u00e9buter, il est tout d'abord n\u00e9cessaire d'installer SimPLU3D .","title":"Introduction"},{"location":"envgeo/integration-test/","text":"L'objectif de cette page est de proposer deux m\u00e9thodes pour v\u00e9rifier la bonne int\u00e9gration des donn\u00e9es \u00e0 partir d'un jeu de donn\u00e9es complet. Pr\u00e9sentation du jeu de donn\u00e9es \uf0c1 Export des informations du mod\u00e8le sous forme de Shapefile \uf0c1 Visualisation 3D des informations du mod\u00e8le \uf0c1","title":"Environnement g\u00e9ographique - V\u00e9rifier le processus d'int\u00e9gration"},{"location":"envgeo/integration-test/#presentation-du-jeu-de-donnees","text":"","title":"Pr\u00e9sentation du jeu de donn\u00e9es"},{"location":"envgeo/integration-test/#export-des-informations-du-modele-sous-forme-de-shapefile","text":"","title":"Export des informations du mod\u00e8le sous forme de Shapefile"},{"location":"envgeo/integration-test/#visualisation-3d-des-informations-du-modele","text":"","title":"Visualisation 3D des informations du mod\u00e8le"},{"location":"envgeo/integration/","text":"Introduction \uf0c1 Un processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe Environnement en renseignant un certain nombre d'attributs. Le processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP ) ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS ). Quelque soit la classe choisie, les deux classes ont une m\u00e9thode load , qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de IFeature de GeOxygene et faire appelle \u00e0 la m\u00e9thode load de la classe fr.ign.cogit.simplu3d.io.LoadFromCollection . Dans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en fonction de la source de donn\u00e9es utilis\u00e9e , puis d\u00e9crire dans le d\u00e9tail le processus d'int\u00e9gration . Attention : actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen d'utiliser le mod\u00e8le g\u00e9ographique convenablement. Sources de donn\u00e9es utilis\u00e9es \uf0c1 La donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es d\u00e9pendent du choix de la source de donn\u00e9es ShapeFiles ou PostGIS . Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires. Cependant, les noms des attributs utilis\u00e9s sont les m\u00eames quelque soit la source et sont stock\u00e9s au m\u00eame endroit dans le code. Source de donn\u00e9es ShapeFile \uf0c1 La classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_FICHIER_PLU doc_urba.shp Non utilis\u00e9es Zonage r\u00e9glementaire NOM_FICHIER_ZONAGE zone_urba.shp (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle.shp Polygones 2D (sans intersection) B\u00e2timents NOM_FICHIER_BATIMENTS batiment.shp\" Multi-Polygone 3D Route NOM_FICHIER_VOIRIE route.shp (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt.asc MNT grille maill\u00e9 Prescriptions ponctuelles NOM_FICHIER_PRESC_PONCTUELLE prescription_pct.shp (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_FICHIER_PRESC_LINEAIRE prescription_lin.shp (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_FICHIER_PRESC_SURFACIQUE prescription_surf.shp (Multi-) Surfacique 2D Source de donn\u00e9es PostGIS \uf0c1 La classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tabmes est fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS. Le MNT est stock\u00e9 comme un raster dans PostGIS. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_TABLE_PLU plu Non utilis\u00e9es Zonage r\u00e9glementaire NOM_TABLE_ZONAGE zonage (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle Polygones 2D (sans intersection) B\u00e2timents NOM_TABLE_BATIMENTS batiment Multi-Polygone 3D Route NOM_TABLE_VOIRIE route (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt MNT grille maill\u00e9 Prescriptions ponctuelles NOM_TABLE_PRESC_PCT prescriptionpct (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_TABLE_PRESC_LINEAIRE prescriptionlin (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_TABLE_PRESC_SURF prescriptionsurf (Multi-) Surfacique 2D Nom des attributs \uf0c1 Pour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe : fr.ign.cogit.simplu3d.io.feature.AttribNames. Document d'urbanisme \uf0c1 Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant ATT_ID_URBA IDURBA String Type de document ATT_TYPE_DOC TYPEDOC String Date Approbation ATT_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date Fin ATT_DATE_FIN DATEFIN Date (yyyyMMdd) Intercommunalit\u00e9 ATT_INTER_CO INTERCO String Num\u00e9ro SIREN ATT_SIREN SIREN String \u00c9tat du document ATT_ETAT ETAT String Nom de la r\u00e9gion ATT_NOM_REG NOMREG String URL de la r\u00e9gion ATT_URL_REG URLREG String Nom du plan ATT_NOM_PLAN NOMPLAN String URL du plan ATT_URL_PLAN URLPLAN String Site web ATT_SITE_WEB SITEWEB String Type ref ATT_TYPE_REF TYPEREF String Date de r\u00e9f\u00e9rence ATT_DATE_REF DATEREF Date (yyyy) Zonage r\u00e9glementaire \uf0c1 Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Libell\u00e9 ATT_LIBELLE LIBELLE String Libell\u00e9 long ATT_LIBELONG LIBELONG String Type de zone ATT_TYPE_ZONE TYPEZONE String Destination dominante ATT_DESTDOMI DESTDOMI String Nom de fichier associ\u00e9 ATT_NOMFIC NOMFIC String URL du fichier associ\u00e9 ATT_URLFIC URLFIC String INSEE ATT_INSEE INSEE String Date d'approbation VALIDITY_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date de validation VALIDITY_DATE_VALID DATVALID Date (yyyyMMdd) Commentaires \u00e9ventuels ATT_TEXT TEXT String Parcelles \uf0c1 Chaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut ATT_CODE_PARC ou il construit par la concat\u00e9nation des attributs valeurs des ATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO et accessible par la m\u00e9thode getCode de la classe CadastralParcel . L'attribut ATT_HAS_TO_BE_SIMULATED est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false). Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant de la parcelle ATT_CODE_PARC CODE String Code du d\u00e9partement ATT_BDP_CODE_DEP CODE_DEP String Code de la commune ATT_BDP_CODE_COM CODE_COM String Compl\u00e9ment pour code INSEE ATT_BDP_COM_ABS COM_ABS String Section cadastrale ATT_BDP_SECTION SECTION String Num\u00e9ro de parcelle ATT_BDP_NUMERO NUMERO String Indique si la parcelle doit \u00eatre simul\u00e9e ATT_HAS_TO_BE_SIMULATED SIMUL Boolean, Integer, String B\u00e2timents \uf0c1 Pas d'attribut utilis\u00e9. Route \uf0c1 Attribut Nom de la variable Valeur par d\u00e9faut Type Nom de la rue ATT_NOM_RUE NOM_RUE_G String Largeur en m ATT_LARGEUR LARGEUR Double Type de la rue ATT_TYPE_ROAD NATURE String MNT \uf0c1 Pas d'attribut utilis\u00e9. Prescriptions ponctuelles, lin\u00e9aires et surfaciques \uf0c1 Attribut Nom de la variable Valeur par d\u00e9faut Type Type de prescription ATT_TYPE_PRESCRIPTION TYPEPSC String Libell\u00e9 de la prescription ATT_LABEL LIBELLE Double Valeur de recul ATT_RECOIL RECOIL String Code d'int\u00e9gration \uf0c1 Le code d'int\u00e9gration se trouve si dessous, il est compos\u00e9 de 12 \u00e9tapes. La premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible de fixer \u00e0 vrai le boolean Environnement.TRANSLATE_TO_ZERO pour activer cette transformation et d'assigner un jeu de coordonn\u00e9es (classe DirectPosition de GeOxygene) \u00e0 la variable Environnement.dpTranslate . Afin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D : parcelles, prescriptions, zonage et \u00e9ventuellement voirie (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe fr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ. Deux types de transformations sont possibles : - Si le MNT set d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ; - S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut). public static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl, IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl, IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions, AbstractDTM dtm, Environnement env) throws Exception { // Etape 0 : doit on translater tous les objets ? if (Environnement.TRANSLATE_TO_ZERO) { Environnement.dpTranslate = zoneColl.envelope().center(); for (IFeature feat : zoneColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : parcelleColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : voirieColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : batiColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : prescriptions) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } } // Etape 1 : cr\u00e9ation de l'objet PLU logger.info(\"Read UrbaDocument...\"); UrbaDocument plu; if (featPLU == null) { plu = new UrbaDocument(); } else { UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader(); plu = urbaDocumentReader.read(featPLU); } env.setUrbaDocument(plu); // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones logger.info(\"Loading UrbaZone...\"); UrbaZoneReader urbaZoneReader = new UrbaZoneReader(); IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>(); zones.addAll(urbaZoneReader.readAll(zoneColl)); // Etape 3 : assignement des zonages au PLU env.setUrbaZones(zones); logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\"); // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader .assignBordureToParcelleWithOrientation(parcelleColl); env.setCadastralParcels(parcelles); // Etape 5 : import des sous parcelles logger.info(\"Loading SubParcels...\"); { IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>(); SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones); for (CadastralParcel cadastralParcel : parcelles) { sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel)); } env.setSubParcels(sousParcelles); } // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es logger.info(\"Loading BasicPropertyUnits...\"); BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles); IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits(); env.setBpU(collBPU); // Etape 7 : import des b\u00e2timents logger.info(\"Loading Buildings...\"); BuildingReader buildingReader = new BuildingReader(); Collection<Building> buildings = buildingReader.readAll(batiColl); env.getBuildings().addAll(buildings); // Etape 7.1 : assignation des batiments aux BpU logger.info(\"Assigning building to SubParcels...\"); AssignBuildingPartToSubParcel.assign(buildings, collBPU); // Etape 8 : chargement des voiries logger.info(\"Loading Roads...\"); RoadReader roadReader = new RoadReader(); IFeatureCollection<Road> roads = new FT_FeatureCollection<>(); roads.addAll(roadReader.readAll(voirieColl)); env.setRoads(roads); // Etape 9 : on affecte les liens entres une bordure et ses objets // adjacents (bordure sur route => route + relation entre les limites de // parcelles) logger.info(\"Assigning Roads to ParcelBoundaries...\"); AssignRoadToParcelBoundary.process(parcelles, roads); // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es logger.info(\"Assigning opposite boundaries to parcel boundaries...\"); AssignOppositeToBoundary.process(parcelles); // Etape 11 : on importe les alignements logger.info(\"Loading Prescriptions...\"); { PrescriptionReader prescriptionReader = new PrescriptionReader(); Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions); env.getPrescriptions().addAll(prescriptionsRead); } logger.info(\"Assign Z to features...\"); // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles, // sous-parcelles route sans z, zonage, les bordures etc... env.setTerrain(dtm); try { AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED); AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED); AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED); AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED); AssignZ.toZone(env.getUrbaZones(), dtm, false); } catch (Exception e) { e.printStackTrace(); } logger.info(\"Loading complete\"); return env; } Dans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).","title":"Environnement g\u00e9ographique - Processus d'int\u00e9gration"},{"location":"envgeo/integration/#introduction","text":"Un processus d'int\u00e9gration est d\u00e9j\u00e0 d\u00e9fini dans SimPLU3D. Il permet de cr\u00e9er un objet de la classe Environnement en renseignant un certain nombre d'attributs. Le processus d'int\u00e9gration peut prendre en entr\u00e9e des donn\u00e9es au format ShapeFile (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP ) ou des donn\u00e9es dans une base de donn\u00e9es PostGIS (avec la classe fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.loadPostGIS ). Quelque soit la classe choisie, les deux classes ont une m\u00e9thode load , qui va traduire les entit\u00e9s provenant de ces sources de donn\u00e9es en collection de IFeature de GeOxygene et faire appelle \u00e0 la m\u00e9thode load de la classe fr.ign.cogit.simplu3d.io.LoadFromCollection . Dans cette page, nous allons d\u00e9crire tout d'abord les pr\u00e9-requis en fonction de la source de donn\u00e9es utilis\u00e9e , puis d\u00e9crire dans le d\u00e9tail le processus d'int\u00e9gration . Attention : actuellement la persistance n'est pas g\u00e9r\u00e9e, donc le processus d'int\u00e9gration automatique est pour le moment le seul moyen d'utiliser le mod\u00e8le g\u00e9ographique convenablement.","title":"Introduction"},{"location":"envgeo/integration/#sources-de-donnees-utilisees","text":"La donn\u00e9es utilis\u00e9es pendant le processus d'int\u00e9gration peuvent provenir de Shapefiles ou de PostGIS. Les classes permettant de lancer le processus et les constantes stockant le nom des sources de donn\u00e9es utilis\u00e9es d\u00e9pendent du choix de la source de donn\u00e9es ShapeFiles ou PostGIS . Dans tous les cas, seules les donn\u00e9es parcellaires sont obligatoires. Cependant, les noms des attributs utilis\u00e9s sont les m\u00eames quelque soit la source et sont stock\u00e9s au m\u00eame endroit dans le code.","title":"Sources de donn\u00e9es utilis\u00e9es"},{"location":"envgeo/integration/#source-de-donnees-shapefile","text":"La classe permettant de charger les donn\u00e9es provenant de ShapeFiles et contenant le nom des fichiers est fr.ign.cogit.simplu3d.io.nonStructDatabase.shp.LoaderSHP. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_FICHIER_PLU doc_urba.shp Non utilis\u00e9es Zonage r\u00e9glementaire NOM_FICHIER_ZONAGE zone_urba.shp (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle.shp Polygones 2D (sans intersection) B\u00e2timents NOM_FICHIER_BATIMENTS batiment.shp\" Multi-Polygone 3D Route NOM_FICHIER_VOIRIE route.shp (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt.asc MNT grille maill\u00e9 Prescriptions ponctuelles NOM_FICHIER_PRESC_PONCTUELLE prescription_pct.shp (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_FICHIER_PRESC_LINEAIRE prescription_lin.shp (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_FICHIER_PRESC_SURFACIQUE prescription_surf.shp (Multi-) Surfacique 2D","title":"Source de donn\u00e9es ShapeFile"},{"location":"envgeo/integration/#source-de-donnees-postgis","text":"La classe permettant de charger les donn\u00e9es provenant de PostGIS et contenant le nom des tabmes est fr.ign.cogit.simplu3d.io.nonStructDatabase.postgis.LoaderPostGIS. Le MNT est stock\u00e9 comme un raster dans PostGIS. Source de donn\u00e9es Nom de la variable Valeur par d\u00e9faut Type de g\u00e9om\u00e9trie Document d'Urbanisme NOM_TABLE_PLU plu Non utilis\u00e9es Zonage r\u00e9glementaire NOM_TABLE_ZONAGE zonage (Multi-) Polygone 2D (sans intersection) Parcelles NOM_FICHIER_PARCELLE parcelle Polygones 2D (sans intersection) B\u00e2timents NOM_TABLE_BATIMENTS batiment Multi-Polygone 3D Route NOM_TABLE_VOIRIE route (Multi-) Lin\u00e9aire 2D ou 3D MNT NOM_FICHIER_TERRAIN mnt MNT grille maill\u00e9 Prescriptions ponctuelles NOM_TABLE_PRESC_PCT prescriptionpct (Multi -) Ponctuelle 2D Prescriptions lin\u00e9aires NOM_TABLE_PRESC_LINEAIRE prescriptionlin (Multi-) Lin\u00e9aire 2D Prescriptions surfaciques NOM_TABLE_PRESC_SURF prescriptionsurf (Multi-) Surfacique 2D","title":"Source de donn\u00e9es PostGIS"},{"location":"envgeo/integration/#nom-des-attributs","text":"Pour les diff\u00e9rentes sources de donn\u00e9es, les noms des attributs utilis\u00e9s dans le processus d'int\u00e9gration sont stock\u00e9es dans la classe : fr.ign.cogit.simplu3d.io.feature.AttribNames.","title":"Nom des attributs"},{"location":"envgeo/integration/#document-durbanisme","text":"Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant ATT_ID_URBA IDURBA String Type de document ATT_TYPE_DOC TYPEDOC String Date Approbation ATT_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date Fin ATT_DATE_FIN DATEFIN Date (yyyyMMdd) Intercommunalit\u00e9 ATT_INTER_CO INTERCO String Num\u00e9ro SIREN ATT_SIREN SIREN String \u00c9tat du document ATT_ETAT ETAT String Nom de la r\u00e9gion ATT_NOM_REG NOMREG String URL de la r\u00e9gion ATT_URL_REG URLREG String Nom du plan ATT_NOM_PLAN NOMPLAN String URL du plan ATT_URL_PLAN URLPLAN String Site web ATT_SITE_WEB SITEWEB String Type ref ATT_TYPE_REF TYPEREF String Date de r\u00e9f\u00e9rence ATT_DATE_REF DATEREF Date (yyyy)","title":"Document d'urbanisme"},{"location":"envgeo/integration/#zonage-reglementaire","text":"Les attributs utilis\u00e9s ont \u00e9t\u00e9 \u00e9tablis en accord avec la norme CNIG - COVADIS sur la d\u00e9mat\u00e9risalisation des documents d'urbanisme. Attribut Nom de la variable Valeur par d\u00e9faut Type Libell\u00e9 ATT_LIBELLE LIBELLE String Libell\u00e9 long ATT_LIBELONG LIBELONG String Type de zone ATT_TYPE_ZONE TYPEZONE String Destination dominante ATT_DESTDOMI DESTDOMI String Nom de fichier associ\u00e9 ATT_NOMFIC NOMFIC String URL du fichier associ\u00e9 ATT_URLFIC URLFIC String INSEE ATT_INSEE INSEE String Date d'approbation VALIDITY_DATE_APPRO DATAPPRO Date (yyyyMMdd) Date de validation VALIDITY_DATE_VALID DATVALID Date (yyyyMMdd) Commentaires \u00e9ventuels ATT_TEXT TEXT String","title":"Zonage r\u00e9glementaire"},{"location":"envgeo/integration/#parcelles","text":"Chaque parcelle a un identifiant, il est soit encod\u00e9 directement avec l'attribut ATT_CODE_PARC ou il construit par la concat\u00e9nation des attributs valeurs des ATT_BDP_CODE_DEP + ATT_BDP_CODE_COM + ATT_BDP_COM_ABS + ATT_BDP_SECTION + ATT_BDP_NUMERO et accessible par la m\u00e9thode getCode de la classe CadastralParcel . L'attribut ATT_HAS_TO_BE_SIMULATED est facultatif et peut \u00eatre utilis\u00e9 pour indiquer s'il faut simuler ou non un parcelle. Il peut \u00eatre boolean, entier (0 pour false et 1 pour true) ou m\u00eame une cha\u00eene de caract\u00e8re (true ou false). Attribut Nom de la variable Valeur par d\u00e9faut Type Identifiant de la parcelle ATT_CODE_PARC CODE String Code du d\u00e9partement ATT_BDP_CODE_DEP CODE_DEP String Code de la commune ATT_BDP_CODE_COM CODE_COM String Compl\u00e9ment pour code INSEE ATT_BDP_COM_ABS COM_ABS String Section cadastrale ATT_BDP_SECTION SECTION String Num\u00e9ro de parcelle ATT_BDP_NUMERO NUMERO String Indique si la parcelle doit \u00eatre simul\u00e9e ATT_HAS_TO_BE_SIMULATED SIMUL Boolean, Integer, String","title":"Parcelles"},{"location":"envgeo/integration/#batiments","text":"Pas d'attribut utilis\u00e9.","title":"B\u00e2timents"},{"location":"envgeo/integration/#route","text":"Attribut Nom de la variable Valeur par d\u00e9faut Type Nom de la rue ATT_NOM_RUE NOM_RUE_G String Largeur en m ATT_LARGEUR LARGEUR Double Type de la rue ATT_TYPE_ROAD NATURE String","title":"Route"},{"location":"envgeo/integration/#mnt","text":"Pas d'attribut utilis\u00e9.","title":"MNT"},{"location":"envgeo/integration/#prescriptions-ponctuelles-lineaires-et-surfaciques","text":"Attribut Nom de la variable Valeur par d\u00e9faut Type Type de prescription ATT_TYPE_PRESCRIPTION TYPEPSC String Libell\u00e9 de la prescription ATT_LABEL LIBELLE Double Valeur de recul ATT_RECOIL RECOIL String","title":"Prescriptions ponctuelles, lin\u00e9aires et surfaciques"},{"location":"envgeo/integration/#code-dintegration","text":"Le code d'int\u00e9gration se trouve si dessous, il est compos\u00e9 de 12 \u00e9tapes. La premi\u00e8re \u00e9tape vise \u00e0 changer de r\u00e9f\u00e9rentiel les sources de donn\u00e9es pour \u00e9viter des erreurs num\u00e9riques dues \u00e0 la grande taille de coordonn\u00e9es utilis\u00e9e. Ainsi, il est possible de fixer \u00e0 vrai le boolean Environnement.TRANSLATE_TO_ZERO pour activer cette transformation et d'assigner un jeu de coordonn\u00e9es (classe DirectPosition de GeOxygene) \u00e0 la variable Environnement.dpTranslate . Afin de produire un r\u00e9f\u00e9rentiel 3D, les donn\u00e9es 2D : parcelles, prescriptions, zonage et \u00e9ventuellement voirie (si les donn\u00e9es n'ont pas de Z) sont modifi\u00e9es lors de la derni\u00e8re \u00e9tape dans la classe fr.ign.cogit.geoxygene.api.feature.IFeatureCollection.AssignZ. Deux types de transformations sont possibles : - Si le MNT set d\u00e9fini, les objets sont projet\u00e9s \u00e0 la surface de ce MNT ; - S'il n'est pas d\u00e9fini, un plan Z constant est utilis\u00e9 (et fix\u00e9 \u00e0 travers la variable statique AssignZ.DEFAULT_Z ayant 0 comme valeur par d\u00e9faut). public static Environnement load(IFeature featPLU, IFeatureCollection<IFeature> zoneColl, IFeatureCollection<IFeature> parcelleColl, IFeatureCollection<IFeature> voirieColl, IFeatureCollection<IFeature> batiColl, IFeatureCollection<IFeature> prescriptions, AbstractDTM dtm, Environnement env) throws Exception { // Etape 0 : doit on translater tous les objets ? if (Environnement.TRANSLATE_TO_ZERO) { Environnement.dpTranslate = zoneColl.envelope().center(); for (IFeature feat : zoneColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : parcelleColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : voirieColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : batiColl) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } for (IFeature feat : prescriptions) { feat.setGeom(feat.getGeom().translate(-Environnement.dpTranslate.getX(), -Environnement.dpTranslate.getY(), 0)); } } // Etape 1 : cr\u00e9ation de l'objet PLU logger.info(\"Read UrbaDocument...\"); UrbaDocument plu; if (featPLU == null) { plu = new UrbaDocument(); } else { UrbaDocumentReader urbaDocumentReader = new UrbaDocumentReader(); plu = urbaDocumentReader.read(featPLU); } env.setUrbaDocument(plu); // Etape 2 : cr\u00e9ation des zones et assignation des r\u00e8gles aux zones logger.info(\"Loading UrbaZone...\"); UrbaZoneReader urbaZoneReader = new UrbaZoneReader(); IFeatureCollection<UrbaZone> zones = new FT_FeatureCollection<>(); zones.addAll(urbaZoneReader.readAll(zoneColl)); // Etape 3 : assignement des zonages au PLU env.setUrbaZones(zones); logger.info(\"Loading CadastralParcel and compute ParcelBoundary...\"); // Etape 4 : chargement des parcelles et cr\u00e9ations des bordures IFeatureCollection<CadastralParcel> parcelles = CadastralParcelLoader .assignBordureToParcelleWithOrientation(parcelleColl); env.setCadastralParcels(parcelles); // Etape 5 : import des sous parcelles logger.info(\"Loading SubParcels...\"); { IFeatureCollection<SubParcel> sousParcelles = new FT_FeatureCollection<>(); SubParcelGenerator subParcelGenerator = new SubParcelGenerator(zones); for (CadastralParcel cadastralParcel : parcelles) { sousParcelles.addAll(subParcelGenerator.createSubParcels(cadastralParcel)); } env.setSubParcels(sousParcelles); } // Etape 6 : cr\u00e9ation des unit\u00e9s foncir\u00e8es logger.info(\"Loading BasicPropertyUnits...\"); BasicPropertyUnitGenerator bpuBuilder = new BasicPropertyUnitGenerator(parcelles); IFeatureCollection<BasicPropertyUnit> collBPU = bpuBuilder.createPropertyUnits(); env.setBpU(collBPU); // Etape 7 : import des b\u00e2timents logger.info(\"Loading Buildings...\"); BuildingReader buildingReader = new BuildingReader(); Collection<Building> buildings = buildingReader.readAll(batiColl); env.getBuildings().addAll(buildings); // Etape 7.1 : assignation des batiments aux BpU logger.info(\"Assigning building to SubParcels...\"); AssignBuildingPartToSubParcel.assign(buildings, collBPU); // Etape 8 : chargement des voiries logger.info(\"Loading Roads...\"); RoadReader roadReader = new RoadReader(); IFeatureCollection<Road> roads = new FT_FeatureCollection<>(); roads.addAll(roadReader.readAll(voirieColl)); env.setRoads(roads); // Etape 9 : on affecte les liens entres une bordure et ses objets // adjacents (bordure sur route => route + relation entre les limites de // parcelles) logger.info(\"Assigning Roads to ParcelBoundaries...\"); AssignRoadToParcelBoundary.process(parcelles, roads); // Etape 10 : on d\u00e9tecte les limites s\u00e9paratives oppos\u00e9es logger.info(\"Assigning opposite boundaries to parcel boundaries...\"); AssignOppositeToBoundary.process(parcelles); // Etape 11 : on importe les alignements logger.info(\"Loading Prescriptions...\"); { PrescriptionReader prescriptionReader = new PrescriptionReader(); Collection<Prescription> prescriptionsRead = prescriptionReader.readAll(prescriptions); env.getPrescriptions().addAll(prescriptionsRead); } logger.info(\"Assign Z to features...\"); // Etape 12 : on affecte des z \u00e0 tout ce bon monde // - parcelles, // sous-parcelles route sans z, zonage, les bordures etc... env.setTerrain(dtm); try { AssignZ.toParcelle(env.getCadastralParcels(), dtm, SURSAMPLED); AssignZ.toSousParcelle(env.getSubParcels(), dtm, SURSAMPLED); AssignZ.toVoirie(env.getRoads(), dtm, SURSAMPLED); AssignZ.toPrescriptions(env.getPrescriptions(), dtm, SURSAMPLED); AssignZ.toZone(env.getUrbaZones(), dtm, false); } catch (Exception e) { e.printStackTrace(); } logger.info(\"Loading complete\"); return env; } Dans cette page, nous avons d\u00e9crit les sources de donn\u00e9es et les attributs n\u00e9cessaires pour utiliser le processus d'int\u00e9gration actuellement impl\u00e9ment\u00e9 dans SimPLU3D. Dans l'\u00e9tape suivante, nous pr\u00e9senterons deux m\u00e9thodes pour visualiser et contr\u00f4ler le processus d'int\u00e9gration (pour rappel, il n'y a pour l'instant pas la possibilit\u00e9 de rendre persistant les instances du mod\u00e8le).","title":"Code d'int\u00e9gration"},{"location":"envgeo/intro/","text":"L'environnement g\u00e9ographique de SimPLU3D permet de d\u00e9crire l'ensemble des objets g\u00e9ographiques n\u00e9cessaires \u00e0 la g\u00e9n\u00e9ration de formes b\u00e2ties et notamment \u00e0 la v\u00e9rification des contraintes morphologiques. Ces objets g\u00e9ographiques peuvent concerner d'autres objets de la ville qui seront utilis\u00e9s pour v\u00e9rifier le respect des contraintes morphologiques (Par exemple, les routes, les types de limites s\u00e9paratives) ou en lien avec l'application de r\u00e8glements d'urbanisme d'un territoire (Par exemple, les plans de zonage ou les servitudes d'utilit\u00e9 publique). L'ensemble des codes g\u00e9rant cet aspect se trouve dans le d\u00e9p\u00f4t SimPLU3D-rules . Il contient : un mod\u00e8le g\u00e9ographique ; des m\u00e9thodes automatiques d'int\u00e9gration , pour renseigner automatiquement les classes, les attributs et les relations n\u00e9cessaires au mod\u00e8le \u00e0 partir de donn\u00e9es g\u00e9ographiques usuelles \u00e0 partir de sources de donn\u00e9es Shapefile ou PostGIS ; un exporteur pour visualiser dans un SIG les \u00e9l\u00e9ments cr\u00e9\u00e9.","title":"Environnement g\u00e9ographique - Introduction"},{"location":"envgeo/modelgeo/","text":"Introduction \uf0c1 Le mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels on peut appliquer des contraintes morphologiques et d\u00e9crire la r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des Plans Locaux d'Urbanisme . Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents \u00e0 partir d'un \u00e9tat de l'art. Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante : le mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non cette r\u00e8gle et cela est d\u00e9crit dans la section d\u00e9finition de contraintes morphologiques . Pour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014 Vue global du mod\u00e8le \uf0c1 Le mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package fr.ign.cogit.simplu3d.model du projet SimPLU3D-rules . La javadoc est consultable en ligne La figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es : les classes repr\u00e9sentant la r\u00e9glementation , c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ; les classes mod\u00e9lisant le parcellaire ; les classes concernant la mod\u00e9lisation 3D des b\u00e2timents ; les classes concernant les espaces publiques . Avant de pr\u00e9senter les classes, la classe parent Environnement sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le. Le mod\u00e8le est certes complexe dans l'absolu, mais il n'est n\u00e9anmoins (comme pr\u00e9sent\u00e9 dans l' exemple de la simulation basique ) pas n\u00e9cessaire de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une autre page . Les diagrammes de classes sont g\u00e9n\u00e9r\u00e9es avec le plugin ObjectAID d'Eclipse et les fichiers sont disponibles dans le dossier diagram de SimPLU3D-rules . Classe Environnement \uf0c1 La classe Environnement est une classe central dans le mod\u00e8le de SimPLU3D car elle le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques. Elle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et \u00e9galement au terrain qui servira de r\u00e9f\u00e9rence. L'instanciation d'un environnement s'effectue : soit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur les processus d'int\u00e9gration ) ; soit par le biais de la m\u00e9thode statique Environnement.createEnvironnement() qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide. Dans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique Environnement.getInstance() . L'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. TRANSLATE_TO_ZERO indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et dpTranslate la valeur de cette translation. Classes de r\u00e9glementation \uf0c1 Les classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent \u00e0 quelle endroit de la zone. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS sur la d\u00e9mat\u00e9rialisation des documents d'urbanisme qui visent \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce mod\u00e8le ( disponible en ligne ). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9es dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas car ces attributs sont purement informatifs, mais n'ont, a priori, pas vraiment d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire. La classe UrbaDocument est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration UrbaDocumentType comme POS, PLU, etc. . La classe UrbaDocument poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode getGeom() ). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque UrbaZone et accessible \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface IZoneRegulation ). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone. Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie ( getUrbaZone() ) et un convertisseur en texte pour consulter les informations contenues ( toText() ). La classe Prescription vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, surfacique ou lin\u00e9aire et a un type qui set d\u00e9finie \u00e0 travers l'\u00e9numartion PrescriptionType . Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans la norme. Classes du parcellaire \uf0c1 Ces classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image a les diff\u00e9rentes relations d'incluses entre BasicPropertyUnit , CadastralParcel et SubPArcel )les diff\u00e9rentes relations entre les parcelles, leur limites s\u00e9paratives ( ParcelBoundary ) et les objets environnants. Les unit\u00e9s fonci\u00e8res (classe BasicPropertyUnit ) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re, elles regroupent un ensemble de parcelles cadastral (classe CadastralParcel ). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents ( getBuildings() ) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode getPol2D() et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode generateGeom() . Les parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles ( SubParcel ). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 ( UrbaZone ). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode ( getCode() ) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode hasToBeSimulated() ). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets ( ParcelBoundary ) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode getBoundaries() ) ou de les filtrer en fonction de leurs attributs (m\u00e9thode getBoundariesByType() ou getBoundariesBySide() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les sous-parcelles (classe SubParcel ) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe UrbaZone ). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode getUrbaZone() . Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode ( getBoundaries() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par getGeom() ). Ils mod\u00e9lisent les limites des parcelles ou sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration ParcelBoundaryType et accessible par la m\u00e9thode getType() ) : BOT : pour les limites de fond de parcelle ; LAT : pour les limites lat\u00e9rales parcelle ; UNKNOWN : pour les limites dont on ne conna\u00eet pas le type ; INTRA : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ; ROAD : pour les limites donnant sur une route ( cf les classes concernant les espaces publiques ) ; PUB : pour les limites donnant sur l'espace publique ( cf les classes concernant les espaces publiques ). Les limites de type LAT ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration ParcelBoundarySide et accessible par la m\u00e9thode getSide() ) qui peut prendre les valeur RIGHT ou LEFT pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche. Les limites permettent d'acc\u00e9der aux objets topologiquement voisins comme une route ( getRoad() ), un espace public ( getPublicSpace() ) ou une parcelle ( getCadastralParcel() ). Les deux premiers objets ne sont acessibles que pour les limites de type ROAD ou PUB et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode getFeatAdj() mais n\u00e9cessite de caster l'objet en sortie. La m\u00e9thode getOppositeBoundary() permet d'obtenir pour les limites de type ROAD ou PUB , si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle. Classes des b\u00e2timents \uf0c1 Les classes mod\u00e9lisant les b\u00e2timents sont issues du standard CityGML V2.0 . Il y a deux classes de b\u00e2timents les b\u00e2timents (classe Building ) et les parties de b\u00e2timents (classe BuildingPart ) qui instancient toutes les deux la classe abstraite AbstractBuilding . Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode getBPU() ). Ces b\u00e2timents sont d\u00e9coup\u00e9es en parties de b\u00e2timent en fonction des sous-parcelles (accessible avec la classe getSubParcel() ). La plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite AbstractBuilding , parmi celles-ci les plus importante pour un usage de SimPLU3D sont : isNew() : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ; getLOD2MultiSurface() : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ; getBuildingParts() : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ; getDestination() : renvoie le type du b\u00e2timent ; getFootPrint() : renvoie en 2D l'emprise du b\u00e2timent. Deux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes : prospect(IGeometry geom, double slope, double hIni) : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie. height(int pB, int pH) : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas. Valeurs de point haut : 0 : point en haut du plus haut \u00e9tage du b\u00e2timent ; 1 : point le plus bas du toit ; 2 : point le plus haut du b\u00e2timents. Valeurs de point bas : 0 : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ; 1 : point le plus bas de la parcelle ; 2 : point le plus bas du terrain ; 3 : point le plus haut du terrain. Les b\u00e2timents sont compos\u00e9s d'un objet de toit (classe RoofSurface ) accessible par la m\u00e9thode getRoof() et des objets de type surface de murs classe WallSurface accessibles par la m\u00e9thode getWallSurfaces() . L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits. Le toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode getGutter() ) en vert dans l'image, des ar\u00eates de pignons ( getGable() ) en orange dans l'image et des ar\u00eates sommets ( getRoofing() ) en bordeau sur l'image. Des angles minimaux (m\u00e9thode getAngleMin() ) et maximaux (m\u00e9thode getAngleMax() ) sont \u00e9galement disonibles. Concernant les surfaces de murs, chaque objet de la classe WallSurface repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration WallSurfaceType ) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode isWindowLess() ). Ces deux types de surface poss\u00e8des des mat\u00e9riaux (classe Materiau ) qui poss\u00e8dent un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuelles repr\u00e9sentations. Classes de l'espace publique \uf0c1 Les classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les configurations b\u00e2ties simul\u00e9es. Ces objets seront accessibles via les limites s\u00e9paratives (classe ParcelBoundary ). La classe PublicSpace repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode getType() ). Les routes (classe Road ) ont quelques informations attributaires classiques comme un nom (m\u00e9thode getName() ), une largeur (m\u00e9thode getWidth() ) et une liste d'usages (m\u00e9thode getUsages() ). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe ( getAxis() ) ou par une surface ( getGeom() ).","title":"Environnement g\u00e9ographique - Mod\u00e8le g\u00e9ographique"},{"location":"envgeo/modelgeo/#introduction","text":"Le mod\u00e8le g\u00e9ographique a pour objet de d\u00e9crire les objets \u00e0 partir desquels on peut appliquer des contraintes morphologiques et d\u00e9crire la r\u00e9glementation urbaine. Le mod\u00e8le propos\u00e9 dans SimPLU3D a \u00e9t\u00e9 \u00e9tabli pour mod\u00e9liser les contraintes sp\u00e9cifiquement issues des Plans Locaux d'Urbanisme . Ainsi, le mod\u00e8le contient les concepts que l'on retrouve dans ces documents \u00e0 partir d'un \u00e9tat de l'art. Par exemple, si l'on consid\u00e8re la r\u00e8gle suivante : le mod\u00e8le permet de repr\u00e9senter les objets g\u00e9ographiques (en rouge), les propri\u00e9t\u00e9s (en bleu) et les relations (en vert). Ensuite, ces informations seront utilis\u00e9es pendant la simulation pour v\u00e9rifier si une configuration b\u00e2tie respecte ou non cette r\u00e8gle et cela est d\u00e9crit dans la section d\u00e9finition de contraintes morphologiques . Pour en savoir plus, le mod\u00e8le a fait l'objet d'une publication scientifique : Brasebin, M., J. Perret, S. Musti\u00e8re and C. Weber (2016) A Generic Model to Exploit Urban Regulation Knowledge, ISPRS International Journal of Geo-Information, vol. 5, n. 2, pp. 14, doi:10.3390/ijgi5020014","title":"Introduction"},{"location":"envgeo/modelgeo/#vue-global-du-modele","text":"Le mod\u00e8le g\u00e9ographique est instanci\u00e9 dans le package fr.ign.cogit.simplu3d.model du projet SimPLU3D-rules . La javadoc est consultable en ligne La figure pr\u00e9c\u00e9dente pr\u00e9sente l'ensemble des classes (sans leurs attributs) composant le mod\u00e8le g\u00e9ographique de SimPLU3D. Quatre ensembles de classes seront pr\u00e9sent\u00e9es : les classes repr\u00e9sentant la r\u00e9glementation , c'est \u00e0 dire les documents, les r\u00e8gles et les plans de zonage issus du PLU (ou d'autres r\u00e9glementations locales) ; les classes mod\u00e9lisant le parcellaire ; les classes concernant la mod\u00e9lisation 3D des b\u00e2timents ; les classes concernant les espaces publiques . Avant de pr\u00e9senter les classes, la classe parent Environnement sera d\u00e9crite, elle permet d'acc\u00e9der aux diff\u00e9rents objets du mod\u00e8le. Le mod\u00e8le est certes complexe dans l'absolu, mais il n'est n\u00e9anmoins (comme pr\u00e9sent\u00e9 dans l' exemple de la simulation basique ) pas n\u00e9cessaire de renseigner toutes les classes pour permettre l'ex\u00e9cution du mod\u00e8le. Seules les classes relatives aux parcelles doivent absolument \u00eatre instanci\u00e9es. Le fait de ne pas instancier une des classes du mod\u00e8le rend impossible la capacit\u00e9 d'\u00e9valuer des contraintes s'appuyant sur les \u00e9l\u00e9ments non instanci\u00e9s. Dans cette page, nous ne d\u00e9crivons que le logique du mod\u00e8le. Le processus d'int\u00e9gration existant est d\u00e9crit dans une autre page . Les diagrammes de classes sont g\u00e9n\u00e9r\u00e9es avec le plugin ObjectAID d'Eclipse et les fichiers sont disponibles dans le dossier diagram de SimPLU3D-rules .","title":"Vue global du mod\u00e8le"},{"location":"envgeo/modelgeo/#classe-environnement","text":"La classe Environnement est une classe central dans le mod\u00e8le de SimPLU3D car elle le point d'entr\u00e9e pour acc\u00e9der \u00e0 l'ensemble des objets n\u00e9cessaires pour v\u00e9rifier le respect des r\u00e8gles morphologiques. Elle est compos\u00e9e d'une s\u00e9rie d'accesseurs qui permettent d'acc\u00e9der aux objets pr\u00e9sent\u00e9s dans ce mod\u00e8le (cf image ci dessus) et \u00e9galement au terrain qui servira de r\u00e9f\u00e9rence. L'instanciation d'un environnement s'effectue : soit lors du chargement de donn\u00e9es gr\u00e2ce \u00e0 l'un des processus d'int\u00e9gration existant (voir section sur les processus d'int\u00e9gration ) ; soit par le biais de la m\u00e9thode statique Environnement.createEnvironnement() qui cr\u00e9\u00e9 un environnement compl\u00e8tement vide. Dans tous les cas, l'objet environnement est unique, il s'agit d'un singleton que l'on peut r\u00e9cup\u00e9rer par la m\u00e9thode statique Environnement.getInstance() . L'objet Environnement peut \u00e9galement contenir les informations relatives \u00e0 une translation qui serait appliqu\u00e9e \u00e0 l'ensemble de la sc\u00e8ne. TRANSLATE_TO_ZERO indique si une translation a \u00e9t\u00e9 appliqu\u00e9e et dpTranslate la valeur de cette translation.","title":"Classe Environnement"},{"location":"envgeo/modelgeo/#classes-de-reglementation","text":"Les classes de r\u00e9glementation visent \u00e0 d\u00e9terminer quelle contraintes r\u00e9glementaires s'appliquent \u00e0 quelle endroit de la zone. Les diff\u00e9rentes classes de cette partie du mod\u00e8le s'inspirent de la norme CNIG-COVADIS sur la d\u00e9mat\u00e9rialisation des documents d'urbanisme qui visent \u00e0 mod\u00e9liser les territoires sur lesquels s'appliquent les r\u00e9glementations. Le mod\u00e8le utilise la version 2014 de ce mod\u00e8le ( disponible en ligne ). Un certain nombre d'attributs provenant de ces sp\u00e9cifications et mod\u00e9lis\u00e9es dans SimPLU3D ne sont pas d\u00e9crits ici. Cela est le cas car ces attributs sont purement informatifs, mais n'ont, a priori, pas vraiment d'influence sur les simulations effectu\u00e9es avec SimPLU3D. Cependant, ils pourraient \u00eatre utilis\u00e9es dans le cadre d'un syst\u00e8me information de gestion r\u00e9glementaire. La classe UrbaDocument est la classe parent qui d\u00e9crit le document mod\u00e9lis\u00e9. Il poss\u00e8de un type d\u00e9fini parmi les possibilit\u00e9s offertes par l'\u00e9num\u00e9ration UrbaDocumentType comme POS, PLU, etc. . La classe UrbaDocument poss\u00e8de des zones d'urbanisme (UrbaZone) qui poss\u00e8dent une g\u00e9om\u00e9trie surfacique (accessible avec la m\u00e9thode getGeom() ). Les contraintes r\u00e9glementaires sont d\u00e9finies pour chaque UrbaZone et accessible \u00e0 travers une r\u00e9glementation de zone (d\u00e9crite dans l'interface IZoneRegulation ). L'impl\u00e9mentation de cette interface permet de d\u00e9finir les valeurs des contraintes qui s'appliquent sur la zone. Il est seulement n\u00e9cessaire de d\u00e9finir la zone r\u00e9glementaire urbaine sur laquelle cette r\u00e9glementation est d\u00e9finie ( getUrbaZone() ) et un convertisseur en texte pour consulter les informations contenues ( toText() ). La classe Prescription vise \u00e0 d\u00e9finir des contraintes qui s'appliquent localement. Une prescription peut avoir une g\u00e9om\u00e9trie qui soit ponctuelle, surfacique ou lin\u00e9aire et a un type qui set d\u00e9finie \u00e0 travers l'\u00e9numartion PrescriptionType . Cette \u00e9num\u00e9ration provient de la norme CNIG-COVADIS et reroupe les diff\u00e9rents types d\u00e9finis dans la norme.","title":"Classes de r\u00e9glementation"},{"location":"envgeo/modelgeo/#classes-du-parcellaire","text":"Ces classes visent \u00e0 organiser les parcelles et le objets reli\u00e9s au parcellaire. Le sch\u00e9ma ci dessous vise \u00e0 pr\u00e9senter (dans l'image a les diff\u00e9rentes relations d'incluses entre BasicPropertyUnit , CadastralParcel et SubPArcel )les diff\u00e9rentes relations entre les parcelles, leur limites s\u00e9paratives ( ParcelBoundary ) et les objets environnants. Les unit\u00e9s fonci\u00e8res (classe BasicPropertyUnit ) sont l'unit\u00e9 de base en termes de propri\u00e9t\u00e9 fonci\u00e8re, elles regroupent un ensemble de parcelles cadastral (classe CadastralParcel ). L'unit\u00e9 fonci\u00e8re contient un certain nombre de b\u00e2timents ( getBuildings() ) qui se trouvent, normalement, totalement inclus dans les unit\u00e9s fonci\u00e8res. Il est possible d'obtenir la g\u00e9om\u00e9trie 2D par la m\u00e9thode getPol2D() et la g\u00e9om\u00e9trie 3D avec la m\u00e9thode generateGeom() . Les parcelles cadastrales sont compos\u00e9es d'un ensemble de sous-parcelles ( SubParcel ). Les sous-parcelles correspondent \u00e0 la partition d'une parcelle en fonction du zonage r\u00e9glementaire utilis\u00e9 ( UrbaZone ). En effet, rien ne garantit qu'une parcelle ne soit pas incluse que dans une seule zone r\u00e9glementaire. Une parcelle poss\u00e8de un identifiant unique accessible avec le m\u00e9thode ( getCode() ) et il est possible de pr\u00e9ciser si celle-ci est simulable ou non (m\u00e9thode hasToBeSimulated() ). Les limites s\u00e9paratives des objets sont d\u00e9crits comme des objets ( ParcelBoundary ) qui peuvent servir lors de la v\u00e9rification de r\u00e8gles. Il est possible d'acc\u00e9der directement \u00e0 ces objets (m\u00e9thode getBoundaries() ) ou de les filtrer en fonction de leurs attributs (m\u00e9thode getBoundariesByType() ou getBoundariesBySide() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les sous-parcelles (classe SubParcel ) sont une d\u00e9composition des parcelles cadastrales par rapport aux zones de r\u00e9glementation (classe UrbaZone ). Ainsi, chaque sous parcelle est associ\u00e9 \u00e0 une zone de r\u00e9glementation urbaine accessible par la m\u00e9thode getUrbaZone() . Elle permet de faire le lien pendant la simulation entre le parcellaire et les r\u00e8gles associ\u00e9es. Les limites s\u00e9paratives sont \u00e9galement associ\u00e9es aux sous-parcelles et accessibles par la m\u00e9thode ( getBoundaries() ). La g\u00e9om\u00e9trie est accessible avec la m\u00e9thode getGeom() . Les limites s\u00e9paratives sont des objets mod\u00e9lis\u00e9s par des segments (accessibles par getGeom() ). Ils mod\u00e9lisent les limites des parcelles ou sous-parcelles. Ces parcelles sont caract\u00e9ris\u00e9es par un type (parmi les types de l'\u00e9num\u00e9ration ParcelBoundaryType et accessible par la m\u00e9thode getType() ) : BOT : pour les limites de fond de parcelle ; LAT : pour les limites lat\u00e9rales parcelle ; UNKNOWN : pour les limites dont on ne conna\u00eet pas le type ; INTRA : pour les limites entre deux parcelles internes \u00e0 une unit\u00e9 fonci\u00e8re, on ne va g\u00e9n\u00e9ralement pas appliquer de contraintes sur celles l\u00e0 ; ROAD : pour les limites donnant sur une route ( cf les classes concernant les espaces publiques ) ; PUB : pour les limites donnant sur l'espace publique ( cf les classes concernant les espaces publiques ). Les limites de type LAT ont \u00e9galement un c\u00f4t\u00e9 de renseign\u00e9 (parmi les types de l'\u00e9num\u00e9ration ParcelBoundarySide et accessible par la m\u00e9thode getSide() ) qui peut prendre les valeur RIGHT ou LEFT pour indiquer de s'il s'agit de limites s\u00e9paratives de droite ou de gauche. Les limites permettent d'acc\u00e9der aux objets topologiquement voisins comme une route ( getRoad() ), un espace public ( getPublicSpace() ) ou une parcelle ( getCadastralParcel() ). Les deux premiers objets ne sont acessibles que pour les limites de type ROAD ou PUB et le dernier pour les autres types de limite. Un seul de ces trois accesseurs devrait renvoyer une valeur autre que null. Il est cependant accessible d'acc\u00e9der \u00e0 l'entit\u00e9 voisine gr\u00e2ce \u00e0 la m\u00e9thode getFeatAdj() mais n\u00e9cessite de caster l'objet en sortie. La m\u00e9thode getOppositeBoundary() permet d'obtenir pour les limites de type ROAD ou PUB , si elle existe, la limite s\u00e9parative donnant de l'autre c\u00f4t\u00e9 de cet espace. Cela permet de prendre en compte les objets de l'autre c\u00f4t\u00e9 d'une route pour d\u00e9finir les contraintes d'une parcelle.","title":"Classes du parcellaire"},{"location":"envgeo/modelgeo/#classes-des-batiments","text":"Les classes mod\u00e9lisant les b\u00e2timents sont issues du standard CityGML V2.0 . Il y a deux classes de b\u00e2timents les b\u00e2timents (classe Building ) et les parties de b\u00e2timents (classe BuildingPart ) qui instancient toutes les deux la classe abstraite AbstractBuilding . Les b\u00e2timents sont des objets b\u00e2timents issues de base de donn\u00e9es 3D et associ\u00e9es \u00e0 une unit\u00e9 fonci\u00e8re (accessible avec la m\u00e9thode getBPU() ). Ces b\u00e2timents sont d\u00e9coup\u00e9es en parties de b\u00e2timent en fonction des sous-parcelles (accessible avec la classe getSubParcel() ). La plupart des m\u00e9thodes pour ces classes proviennent de la classe abstraite AbstractBuilding , parmi celles-ci les plus importante pour un usage de SimPLU3D sont : isNew() : qui indique si un b\u00e2timent est simul\u00e9 (valeur true) ou existant (valeur false) ; getLOD2MultiSurface() : qui permet d'obtenir la g\u00e9om\u00e9trie de tout le b\u00e2timent ; getBuildingParts() : qui renvoie la liste des parties de b\u00e2timents lorsque ceux-ci sont d\u00e9coup\u00e9s ; getDestination() : renvoie le type du b\u00e2timent ; getFootPrint() : renvoie en 2D l'emprise du b\u00e2timent. Deux autres m\u00e9thodes permettent directement d'\u00e9valuer certaines contraintes : prospect(IGeometry geom, double slope, double hIni) : \u00e9value si une contrainte de prospect est respect\u00e9e. Cette contrainte illustr\u00e9e, dans la figure ci-dessus, vise \u00e0 \u00e9valuer si un b\u00e2timent se trouve sous un certain plan d\u00e9fini par une g\u00e9om\u00e9trie (ici celle de la parcelle voisine), une certaine pente et une hauteur initiale contre cette g\u00e9om\u00e9trie. height(int pB, int pH) : calcule la hauteur par rapport \u00e0 la d\u00e9finition d'un point bas et d'un point haut. Le premier param\u00e8tre d\u00e9finit un type de point haut et le second un type de point bas. Valeurs de point haut : 0 : point en haut du plus haut \u00e9tage du b\u00e2timent ; 1 : point le plus bas du toit ; 2 : point le plus haut du b\u00e2timents. Valeurs de point bas : 0 : point le plus bas de l'espace public adjacent, s'il existe sinon point le plus bas de la parcelle ; 1 : point le plus bas de la parcelle ; 2 : point le plus bas du terrain ; 3 : point le plus haut du terrain. Les b\u00e2timents sont compos\u00e9s d'un objet de toit (classe RoofSurface ) accessible par la m\u00e9thode getRoof() et des objets de type surface de murs classe WallSurface accessibles par la m\u00e9thode getWallSurfaces() . L'image ci-dessous illustre le principe de d\u00e9composition de b\u00e2timents en murs et toits. Le toit poss\u00e8de diff\u00e9rentes informations concernant sa structure : une goutti\u00e8re (m\u00e9thode getGutter() ) en vert dans l'image, des ar\u00eates de pignons ( getGable() ) en orange dans l'image et des ar\u00eates sommets ( getRoofing() ) en bordeau sur l'image. Des angles minimaux (m\u00e9thode getAngleMin() ) et maximaux (m\u00e9thode getAngleMax() ) sont \u00e9galement disonibles. Concernant les surfaces de murs, chaque objet de la classe WallSurface repr\u00e9sente un ensemble de g\u00e9om\u00e9tries coplanaires. Ces murs poss\u00e8des un type, similaire au type des limites s\u00e9paratives (\u00e9num\u00e9ration WallSurfaceType ) et un attribut indiquant s'ils poss\u00e8dent des fen\u00eatres (m\u00e9thode isWindowLess() ). Ces deux types de surface poss\u00e8des des mat\u00e9riaux (classe Materiau ) qui poss\u00e8dent un nom pour les discriminer et \u00e9ventuellement des coordonn\u00e9es de texture pour d'\u00e9ventuelles repr\u00e9sentations.","title":"Classes des b\u00e2timents"},{"location":"envgeo/modelgeo/#classes-de-lespace-publique","text":"Les classes servent \u00e0 mod\u00e9liser l'espace en dehors des parcelles qui peuvent imposer des contraintes sur les configurations b\u00e2ties simul\u00e9es. Ces objets seront accessibles via les limites s\u00e9paratives (classe ParcelBoundary ). La classe PublicSpace repr\u00e9sente des objets surfaciques (parcs, places, etc.) qui sont d\u00e9finis par un type (m\u00e9thode getType() ). Les routes (classe Road ) ont quelques informations attributaires classiques comme un nom (m\u00e9thode getName() ), une largeur (m\u00e9thode getWidth() ) et une liste d'usages (m\u00e9thode getUsages() ). Elles sont \u00e0 la fois mod\u00e9lis\u00e9es par un axe ( getAxis() ) ou par une surface ( getGeom() ).","title":"Classes de l'espace publique"},{"location":"generator/custom-generator/","text":"Comment customizer le g\u00e9n\u00e9rateur de formes en jouant sur les param\u00e8tres md.","title":"Custom generator"},{"location":"generator/custom-optimisation/","text":"Comment customizer la fonction d'optimisation ? Principe de graph d'\u00e9valuation ?","title":"Custom optimisation"},{"location":"generator/custom-shape/","text":"Comment customizer les formes utilis\u00e9es ?","title":"Custom shape"},{"location":"generator/intro/","text":"Principe g\u00e9n\u00e9ral de la g\u00e9n\u00e9ration avec SimPLU3D et l'utilisation de la librjmcmc4j. Dire que le code est dans SimPLU3D","title":"Intro"},{"location":"generator/principe/","text":"Principe d\u00e9taill\u00e9 de la g\u00e9n\u00e9ration avec SimPLU3D et l'utilisation de la librjmcmc4j. (cf chapitre 3)","title":"Principe"},{"location":"openmole/intro/","text":"1 pr\u00e9sentation d'OpenMole 2 cr\u00e9ation d'un plugin avec osgi bundle 3 lancer la distribution avec le script ....","title":"Intro"},{"location":"principe/intro/","text":"Principe du fonctionnement de SimPLU3D \uf0c1 Le simulateur de base fait bien ressortir trois composants principaux de SimPLU3D : l'environnement g\u00e9ographique environnement g\u00e9ographique qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , qui d\u00e9finit \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9 par le simulateur et la forme des configurations simul\u00e9es ; la d\u00e9finition de contraintes morphologiques , qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique. Pr\u00e9sentaiton simple de l'approche \uf0c1 Pendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation est la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le recuit simul\u00e9 ). Dans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.","title":"Principe de fonctionnement de SimPLU3D"},{"location":"principe/intro/#principe-du-fonctionnement-de-simplu3d","text":"Le simulateur de base fait bien ressortir trois composants principaux de SimPLU3D : l'environnement g\u00e9ographique environnement g\u00e9ographique qui contient les objets g\u00e9ographiques mod\u00e9lis\u00e9s n\u00e9cessaires \u00e0 la simulation avec SimPLU3D ; la d\u00e9finition d'un g\u00e9n\u00e9rateur de formes , qui d\u00e9finit \u00e0 la fois la strat\u00e9gie d'optimisation employ\u00e9 par le simulateur et la forme des configurations simul\u00e9es ; la d\u00e9finition de contraintes morphologiques , qui s'appuient sur les \u00e9l\u00e9ments du mod\u00e8le de l'environnement g\u00e9ographique.","title":"Principe du fonctionnement de SimPLU3D"},{"location":"principe/intro/#presentaiton-simple-de-lapproche","text":"Pendant une simulation, SimPLU3D essaye it\u00e9rativement diff\u00e9rentes configurations g\u00e9n\u00e9r\u00e9es en accord avec la g\u00e9n\u00e9rateur de formes. \u00c0 chaque it\u00e9ration, une configuration est test\u00e9e. Il faut tout d'abord que celle-ci respecte les r\u00e8gles morphologiques utilis\u00e9es et d\u00e9finies relativement \u00e0 l'environnement g\u00e9ographique (Par exemple, recul par rapport \u00e0 la voirie, distance aux b\u00e2timents existants, etc.). Ensuite, la configuration propos\u00e9e est \u00e9valu\u00e9e relativement \u00e0 une fonction d'optimisation est la configuration est test\u00e9e suivant des crit\u00e8res d'acceptation propres \u00e0 la m\u00e9thode employ\u00e9e (\u00e0 savoir le recuit simul\u00e9 ). Dans les prochaines sections, ces diff\u00e9rents points seront abord\u00e9s ainsi que la pr\u00e9sentation plus d\u00e9taill\u00e9e de l'algorithme.","title":"Pr\u00e9sentaiton simple de l'approche"},{"location":"rules/formats/","text":"Comment utiliser des formats de fichiers de r\u00e8gles ? - Pas de formats d\u00e9finis pour le moment car il n'existe pas de normes et besoin souvent de changer les r\u00e8gles utilis\u00e9es, mais on va prendre les exemples d'ArtiScales et de smartPLU pour montrer comment faire avec les zones","title":"Formats"},{"location":"rules/intro/","text":"Gestion des r\u00e8gles d'urbanisme (principe et page d'accueil de la sous section)","title":"Intro"},{"location":"rules/predicate/","text":"Principe du pr\u00e9dicate et comment en d\u00e9finir un (avec l'extension de la m\u00e9thode qui va bien)","title":"Predicate"},{"location":"rules/topologique/","text":"Comment d\u00e9finir une contrainte topologique en utilisant des formes sp\u00e9ciales ?","title":"Topologique"},{"location":"visitor/intro/","text":"Les visiteurs qui existent pour suivrent l'\u00e9volution et produire des sorties au fil de la simulation","title":"Intro"}]}