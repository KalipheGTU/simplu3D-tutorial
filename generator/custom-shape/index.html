<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="MBrasebin">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Personnaliser les formes utilisées - SimPLU3D tutorial</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Personnaliser les formes utilis\u00e9es";
    var mkdocs_page_input_path = "generator/custom-shape.md";
    var mkdocs_page_url = "/simplu3D-tutorial/generator/custom-shape/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> SimPLU3D tutorial</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Accueil</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Premiers pas</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../begin/intro/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../begin/installation/">Installation</a>
                </li>
                <li class="">
                    
    <a class="" href="../../begin/first_simulation/">Première simulation</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../principe/intro/">Principe</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Environnement géographique</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../envgeo/intro/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../envgeo/modelgeo/">Modèle géographique détaillé</a>
                </li>
                <li class="">
                    
    <a class="" href="../../envgeo/integration/">Processus d'intégration</a>
                </li>
                <li class="">
                    
    <a class="" href="../../envgeo/integration-test/">Tester l'intégration</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Générateur de formes</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../intro/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../principe/">Principe de fonctionnement du générateur</a>
                </li>
                <li class="">
                    
    <a class="" href="../custom-generator/">Paramétrer la génération de boîtes</a>
                </li>
                <li class="">
                    
    <a class="" href="../custom-optimisation/">Personnaliser la fonction d'optimisation</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Personnaliser les formes utilisées</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#generation-de-batiments-en-l">Génération de bâtiments en L</a></li>
    

    <li class="toctree-l3"><a href="#code-exemple">Code exemple</a></li>
    

    <li class="toctree-l3"><a href="#definition-de-la-classe-representant-la-forme">Définition de la classe représentant la forme</a></li>
    

    <li class="toctree-l3"><a href="#definition-dune-classe-de-constructeur">Définition d'une classe de constructeur</a></li>
    

    <li class="toctree-l3"><a href="#definition-de-loptimiseur">Définition de l'optimiseur</a></li>
    

    <li class="toctree-l3"><a href="#implementation-de-lexecution">Implémentation de l'exécution</a></li>
    

    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Définition des contraintes morphologiques</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../rules/intro/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../rules/predicate/">Principe de fonctionnement du vérificateur</a>
                </li>
                <li class="">
                    
    <a class="" href="../../rules/formats/">Formats de règles</a>
                </li>
                <li class="">
                    
    <a class="" href="../../rules/topologique/">Définition de contraintes topologiques</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../export/">Exporter les résultats d'une simulation</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../visitor/intro/">Suivre l'évolution d'une simulation</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../openmole/intro/">Distribuer avec OpenMole</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../development/">Futurs développements</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../about/">À propos</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../bibliographie/">Réalisations et bibliographie</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">SimPLU3D tutorial</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Générateur de formes &raquo;</li>
        
      
    
    <li>Personnaliser les formes utilisées</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/SimPLU3D/simplu3D-tutorial?query=root/path/docs/generator/custom-shape.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="generation-de-batiments-en-l">Génération de bâtiments en L<a class="headerlink" href="#generation-de-batiments-en-l" title="Permanent link"></a></h1>
<p>L'objectif de cette partie est de présenter un code permettant de générer des bâtiments en forme de L avec un toit typifié et de décrire les étapes à suivre pour générer des configurations avec d'autres types de forme à partir du simulateur basique présenté dans la <a href="../../begin/first_simulation/">première expérimentation</a>.</p>
<h1 id="code-exemple">Code exemple<a class="headerlink" href="#code-exemple" title="Permanent link"></a></h1>
<p>L'exécution du code présenté ici se trouve dans la classe  <em>fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection</em> du projet SimPLU3D-tutorial.</p>
<p><img alt="Vue du bâtiment en L" src="../img/lshape.png" /></p>
<p>La classe de géométrie paramétrique utilisée (présentée dans le schéma précédent) comporte 10 dimensions :</p>
<ul>
<li><strong>x</strong> : coordonnée x du centre de la forme ;</li>
<li><strong>y</strong> : coordonnée y du centre de la forme ;</li>
<li><strong>l1</strong> : longueur de la forme hors barre du L ;</li>
<li><strong>l2</strong> : longueur de la barre du L ;</li>
<li><strong>h1</strong> : hauteur totale de la forme hors barre du L;</li>
<li><strong>h2</strong> : hauteur totale de la barre du L;</li>
<li><strong>height</strong> : hauteur maximale de la forme ;</li>
<li><strong>orientation</strong> : orientation (azimut) du L ;</li>
<li><strong>hgutter</strong> : hauteur à la gouttière.</li>
<li><strong>shift</strong> : pente du toit aux extrémités du L (entre 0 pas de pente et 1 pente jusqu'au milieu de la forme).</li>
</ul>
<h1 id="definition-de-la-classe-representant-la-forme">Définition de la classe représentant la forme<a class="headerlink" href="#definition-de-la-classe-representant-la-forme" title="Permanent link"></a></h1>
<p>La classe définissant la géométrie simulée est la classe <em>fr.ign.cogit.simplu3d.rjmcmc.paramshp.geometry.impl.LBuildingWithRoof</em> du projet SimPLU3D. Cette classe implémente la classe <strong>AbstractSimpleBuilding</strong> (comme nous simulons un objet de type bâtiment, comme c'est le cas pour la classe <strong>Cubboid</strong>). Cela implique l'instanciation de 3 niveaux de classes abstraites et d'interfaces :
-  la classe <em>fr.ign.cogit.simplu3d.rjmcmc.cuboid.geometry.impl.AbstractSimpleBuilding</em> de <em>SimPLU3D-rules</em>: qui contient les informations nécessaires pour modéliser un objet de type bâtiment de SimPLU3D ;
- l'interface <em>fr.ign.cogit.simplu3d.rjmcmc.generic.objectISimPLU3DPrimitive</em> : qui contient les méthodes propres à SimPLU3D concernant l'optimisation de forme ;
- l'interface  de la librjmcmc4j <em>fr.ign.geometry.Primitive</em> : qui contient les informations nécessaires pour simuler des objets géographiques avec la librjmcmc4j.
Seule l'implémentation de la dernière interface est nécessaire pour générer des formes, les deux autres niveaux enrichissent les méthodes accessibles pour la vérification des règles et la définition de la fonction d'optimisation. Elles facilitent également la ré-utilisation du code de la première simulation.</p>
<p>L'implémentation de l'interface <em>Primitive</em>  nécessite la définition des méthodes suivantes :</p>
<ul>
<li><em>int size();</em> : renvoie la taille de la dimension de la forme (ici 10 pour le bâtiment en L) ;</li>
<li><em>double[] toArray()</em> :  traduit les attributs de la classe en un tableau de double (il s'agit ici d'un tableau de dimension 10 contenant les valeurs des différentes dimensions de la forme) ;</li>
<li><em>Object[] getArray();</em> : même méthode que précédemment, mais avec des valeurs sous forme d'objets ;</li>
<li><em>void set(List<Double> list);</em> : affecte aux attributs de la classe les valeurs provenant d'un tableau de double (ici une liste de 10 chiffres qui correspondent aux 10 dimensions de la classe) ;</li>
<li><em>double intersectionArea(Primitive p);</em> : évalue la surface de l'intersection 2D avec une autre primitive (ici avec d'autres bâtiments en L) ;</li>
<li><em>Geometry toGeometry();</em> : convertit la forme en géométrie 2D JTS (ici l'emprise 2D du bâtiment, la conversion JTS permet d'optimiser les temps de calcul par rapport à l'utilisation de géométries GeOxygene) ;</li>
<li><em>double getArea();</em> : l'aire 2D de l'emprise de la forme.</li>
</ul>
<p>La classe <em>LBuildingWithRoof</em> implémente cette interface à travers la classe <em>AbstractSimpleBuilding</em>. Elle implémente également l'interface  <em>fr.ign.cogit.simplu3d.rjmcmc.generic.object.ISimPLU3DPrimitive</em> qui est nécessaire pour pouvoir appliquer le vérificateur de forme. Cela nécessite l'implémentation de trois méthodes :</p>
<ul>
<li><em>double getHeight();</em> : la hauteur maximale de la forme ;</li>
<li><em>double getVolume();</em> : le volume de la forme ;</li>
<li><em>IGeometry generated3DGeom();</em> renvoie une géométrie GeOXygene3D de la forme, utile pour la vérification de règles ou pour l'export des données.</li>
</ul>
<h1 id="definition-dune-classe-de-constructeur">Définition d'une classe de constructeur<a class="headerlink" href="#definition-dune-classe-de-constructeur" title="Permanent link"></a></h1>
<p>Il s'agit de la classe <em>fr.ign.cogit.simplu3d.rjmcmc.paramshp.builder.LBuildingWithRoofBuilder</em> qui étend la classe de la librjmcmc4j <em>fr.ign.mpp.kernelObjectBuilder<LBuildingWithRoof></em> cela implique l'implémentation de 3 méthodes :</p>
<ul>
<li><em>T build(double[] val);</em> : instance un objet de la classe paramétrée (ici LBuildingWithRoof) à partir d'un tableau de valeurs de double ;</li>
<li><em>void setCoordinates(T t, double[] val);</em> : affecte les coordonnées d'un tableau de doubles à un objet de la classe paramétrée ;</li>
<li><em>int size();</em> : la dimension de la taille des objets construits par le constructeur (ici 10).</li>
</ul>
<h1 id="definition-de-loptimiseur">Définition de l'optimiseur<a class="headerlink" href="#definition-de-loptimiseur" title="Permanent link"></a></h1>
<p>L'optimiseur est défini dans la classe <em>fr.ign.cogit.simplu3d.rjmcmc.paramshp.optimizer. OptimisedLShapeDirectRejection</em> dans le projet SimPLU3D. L'étape peut sembler complexe car le code de la classe est très long, néanmoins, comme presque toutes les méthodes à définir sont les mêmes que celles  utilisée pour simuler des formes composées de boîtes (<em>fr.ign.cogit.simplu3d.rjmcmc.cuboid.optimizer.cuboid.OptimisedBuildingsCuboidFinalDirectRejection</em>) mais paramétrées avec la classe <em>LBuildingWithRoof</em>.</p>
<p>La seule méthode significativement différente est <strong>create_sampler</strong> qui créé l'échantillonneur de bâtiments en L. L'implémentation de cette méthode est similaire à celle des boîtes avec la définition des intervalles de tirage, du constructeur d'objets et des noyaux de modification. Le code de cette méthode est repris et commenté ci-dessous :</p>
<pre><code class="JAVA">
    /**
     *
     * @param rng     a random generator
     * @param p       a json parameter files
     * @param bpU     a basic property unit
     * @param pred    a predicate to check the rules
     * @param polygon a polygon that contains al the cuboid
     * @return a sampler for the optimization process
     */
    public Sampler&lt;GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; create_sampler(
            RandomGenerator rng, SimpluParameters p, BasicPropertyUnit bpU,
            ConfigurationModificationPredicate&lt;GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; pred,
            IGeometry polygon) {

        // On créé les bornes min et max pour le sampler (10 paramètres dans le
        // cas du LBuildingWithRoof)
        IEnvelope env = polygon.envelope();

        double xmin = env.getLowerCorner().getX();
        double xmax = env.getUpperCorner().getX();

        double ymin = env.getLowerCorner().getY();
        double ymax = env.getUpperCorner().getY();

        double l1min = p.getDouble(&quot;l1min&quot;);
        double l1max = p.getDouble(&quot;l1max&quot;);

        double l2min = p.getDouble(&quot;l2min&quot;);
        double l2max = p.getDouble(&quot;l2max&quot;);

        double h1min = p.getDouble(&quot;h1min&quot;);
        double h1max = p.getDouble(&quot;h1max&quot;);

        double h2min = p.getDouble(&quot;h2min&quot;);
        double h2max = p.getDouble(&quot;h2max&quot;);

        double heightToTopMin = p.getDouble(&quot;heightToTopMin&quot;);
        double heightToTopgMax = p.getDouble(&quot;heightToTopgMax&quot;);

        double orientationMin = 0;
        double orientationMax =  Math.PI;

        double heightgutterMin = p.getDouble(&quot;heightgutterMin&quot;);
        ;
        double heightguterrMax = p.getDouble(&quot;heightgutterMax&quot;);
        ;

        double shiftMin = 0;
        double shiftMax = 1;

        // A priori on redéfini le constructeur de l'objet
        // A priori on redéfini le constructeur de l'objet
        LBuildingWithRoofBuilder builder = new LBuildingWithRoofBuilder();

        // On initialise la surface sur laquelle on fait la simulation
        if (samplingSurface == null) {
            samplingSurface = bpU.getPol2D();
        }

        // On initialise l'espace sur lequel on va calculer les objets
        // (normalement tu as juste à changer le nom des classes)
        UniformBirth&lt;LBuildingWithRoof&gt; birth = new UniformBirth&lt;LBuildingWithRoof&gt;(rng,
                new LBuildingWithRoof(xmin, ymin, l1min, l2min, h1min, h2min, heightToTopMin, orientationMin,
                        heightgutterMin, shiftMin),
                new LBuildingWithRoof(xmax, ymax, l1max, l2max, h1max, h2max, heightToTopgMax, orientationMax,
                        heightguterrMax, shiftMax),
                builder, TransformToSurface.class, (IGeometry) polygon);

        // La distribution de poisson qui drive le nombre total d'objets
        PoissonDistribution distribution = new PoissonDistribution(rng, p.getDouble(&quot;poisson&quot;));

        // Le sampler qui détermine comment on tire aléatoirement un objet dans
        // l'espace défini
        DirectSampler&lt;LBuildingWithRoof, GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; ds = new DirectRejectionSampler&lt;&gt;(
                distribution, birth, pred);

        // Probabilité de naissance-morts modifications
        List&lt;Kernel&lt;GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt;&gt; kernels = new ArrayList&lt;&gt;(
                3);
        KernelFactory&lt;LBuildingWithRoof, GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; factory = new KernelFactory&lt;&gt;();

        // On liste les kernels, pour le premier, tu devrais probablement le
        // définir toi ....
        kernels.add(
                factory.make_uniform_birth_death_kernel(rng, builder, birth, p.getDouble(&quot;pbirth&quot;), 1.0, &quot;BirthDeath&quot;));
        double amplitudeMove = p.getDouble(&quot;amplitudeMove&quot;);
        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new MoveLShapeBuilding(amplitudeMove), 0.2,
                &quot;Move&quot;));

        // Pour les autres, le ChangeValue peut être utiliser (attention, le
        // deuxième arguement est la taille de ton builder +1)
        // car il utilise un tableau pour stocker les paramètres et le +1 est
        // pour stocker de manière temporaire le tirage aléatoire
        double amplitudeMaxDim = p.getDouble(&quot;amplitudeMaxDim&quot;);
        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 2), 0.2, &quot;h1Change&quot;));

        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 3), 0.2, &quot;h2Change&quot;));

        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 4), 0.2, &quot;l1Change&quot;));

        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeMaxDim, builder.size() + 1, 5), 0.2, &quot;l2Change&quot;));

        double amplitudeHeight = p.getDouble(&quot;amplitudeHeight&quot;);

        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeHeight, builder.size() + 1, 6), 0.2, &quot;heightChange&quot;));

        double amplitudeRotate = p.getDouble(&quot;amplitudeRotate&quot;) * Math.PI / 180;
        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeRotate, builder.size() + 1, 7), 0.2, &quot;Rotate&quot;));

        kernels.add(factory.make_uniform_modification_kernel(rng, builder,
                new ChangeValue(amplitudeHeight, builder.size() + 1, 8), 0.2, &quot;changeHeightGutter&quot;));

        kernels.add(factory.make_uniform_modification_kernel(rng, builder, new ChangeValue(0.1, builder.size() + 1, 9),
                0.2, &quot;changeShift&quot;));

        // On instancie le sampler avec tous les objets.
        Sampler&lt;GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; s = new GreenSamplerBlockTemperature&lt;&gt;(
                rng, ds, new MetropolisAcceptance&lt;SimpleTemperature&gt;(), kernels);
        return s;
    }
</code></pre>

<h1 id="implementation-de-lexecution">Implémentation de l'exécution<a class="headerlink" href="#implementation-de-lexecution" title="Permanent link"></a></h1>
<p>Le code exécuté se trouve dans la classe <em>fr.ign.simplu3d.shapeGenerator.OptimisedLShapeDirectRejection</em> du projet SimPLU3D-tutoriel. Les différences par rapport à la simulation basique de formes composées de boîtes sont :
- l'utilisation du nouvel optimiseur ;
- la prise en compte d'un autre fichier de configurations, le bâtiment en L ayant besoin de la définition de plus d'intervalles de valeurs ;
- un code spécifique pour écrire les sorties des formes.</p>
<p>On peut noter que le vérificateur de règles utilisé est le même que pour la simulation de formes composées de boîtes et qu'il n'est pas nécessaire de le définir grâce aux interfaces implémentées.</p>
<pre><code class="JAVA">    // Step 0 ; Defining an output existing folder
        String outputFolder = &quot;/tmp/&quot;;

        // Step 1 : Creating the geographic environment using the repository that
        // contains the data

        // Load default environment (data are in resource directory)
        Environnement env = LoaderSHP.loadNoDTM(new File(
                BasicParametricShapeSimulator.class.getClassLoader().getResource(&quot;firstSimulation/data/&quot;).getPath()));

        // Select a parcel on which generation is proceeded
        BasicPropertyUnit bPU = env.getBpU().get(2);

        // Step 2 : Defining the regulation that will be applied during the simulation

        // Rules parameters.8
        // Distance to road
        double distReculVoirie = 0;
        // Distance to bottom of the parcel
        double distReculFond = 0;
        // Distance to lateral parcel limits
        double distReculLat = 0;
        // Distance between two buildings of a parcel
        double distanceInterBati = 3;
        // Maximal ratio built area
        double maximalCES = 1;

        // Instanciation of a predicate class
        // Same as in the first sample fr.ign.simplu3d.firstSimulation.BasicSimulator
        // As LBuildingWithRoof and Cuboid extends ISimPLU3DPrimitive
        SamplePredicate&lt;LBuildingWithRoof, GraphConfiguration&lt;LBuildingWithRoof&gt;, BirthDeathModification&lt;LBuildingWithRoof&gt;&gt; pred = new SamplePredicate&lt;&gt;(
                bPU, distReculVoirie, distReculFond, distReculLat, distanceInterBati, maximalCES);

        // Step 3 : Defining the sampler that will be applied during the simulation
        // Instantiation of the sampler
        OptimisedLShapeDirectRejection optimisedLShapedSampler = new OptimisedLShapeDirectRejection();

        // Loading the parameters for the building shape generation
        String folderName = BasicParametricShapeSimulator.class.getClassLoader()
                .getResource(&quot;firstSimulation/scenario/&quot;).getPath();
        // We use a specific scenario dedicated to LShape
        String fileName = &quot;paramsLShape.json&quot;;
        SimpluParameters p = new SimpluParametersJSON(new File(folderName + fileName));

        // Run of the optimisation on a parcel with the predicate
        GraphConfiguration&lt;? extends ISimPLU3DPrimitive&gt; cc = optimisedLShapedSampler.process(bPU, p, env, bPU.getId(),
                pred, bPU.getGeom());

        // 4 - Writing the output
        IFeatureCollection&lt;IFeature&gt; iFeatC = new FT_FeatureCollection&lt;&gt;();
        for (GraphVertex&lt;? extends ISimPLU3DPrimitive&gt; v : cc.getGraph().vertexSet()) {

            IFeature feat = new DefaultFeature(v.getValue().generated3DGeom());
            // On ajoute des attributs aux entités (dimension des objets)
            AttributeManager.addAttribute(feat, &quot;Info&quot;, v.getValue().toString(), &quot;Double&quot;);

            iFeatC.add(feat);

        }

        // Writng the shapefile from the collection
    ShapefileWriter.write(iFeatC, outputFolder + &quot;out.shp&quot;);
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../rules/intro/" class="btn btn-neutral float-right" title="Introduction">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../custom-optimisation/" class="btn btn-neutral" title="Personnaliser la fonction d'optimisation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>IGNF 2018-2019</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/SimPLU3D/simplu3D-tutorial" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../custom-optimisation/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../rules/intro/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
